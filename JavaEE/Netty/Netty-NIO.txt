一、Netty 核心技术与源码剖析
	1. 本套课程学习要求
		① 本套课程不适用于 0 基础的学员
		② 要求已经掌握了 Java 编程，主要技术构成：Java OOP 编程、Java 多线程编程、Java IO 编程、Java 网络编程、常用的Java 设计模式（比如：
		观察者模式、命令模式、责任链模式）、常用的数据结构（比如链表）
		③ 本课程的 《Netty 核心源码剖析章节》要求最好有项目开发和阅读源码的经历
	2. Netty 的介绍
		① Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github 上的独立项目
		② Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序
		③ Netty 主要针对 TCP 协议下，面向 Client 端的高并发应用，或者 Peer-to-Peer 场景下的大量数据持续传输的应用
		④ Netty 本质是一个 NIO 框架，适用于服务器通讯相关的多种应用场景
		⑤ 要透彻理解 Netty，需要先学习 NIO，这样我们才能阅读 Netty 的源码
	3. Netty 的应用场景
		① 互联网行业：
			A. 互联网行业:在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为
			基础通信组件被这些 RPC 框架使用
			B. 典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于
			实现进程节点之间的内部通信
		② 游戏行业：
			A. 无论是手游服务端还是大型网络游戏，Java 语言得到了越来越广泛的应用
			B. Netty 作为高性能的基础通信组件，提供了 TCP/UDP 和 HTTP 协议栈，方便定制和开发私有协议栈，账号登陆服务器
			C. 地图服务器之间可以方便的通过 Netty 进行高性能的通信
		③ 大数据领域
			A. 经典的 Hadoop 的高性能通信和序列化组件（AVRO 实现数据文件共享）的 RPC 框架，默认采用 Netty 进行跨界点通信 
			B. 它的	Netty Service 基于 Netty 框架二次封装实现
		④ 其他开源项目使用到 Netty
			A. 网址：https://netty.io/wiki/related-projects.html
	4. Netty 的学习参考资料
		① Netty IN ACTION 
		② Netty 权威指南
二、Java BIO 编程
	1. I/O 模型
		① I/O 模型基本说明
			A. I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能
			B. Java 共支持 3 种网络编程模型/IO模式：BIO、NIO 和 AIO
			C. Java BIO：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求服务器端就需要启动一个线程进行处理，如果这个
			连接不做任何事情会造成不必要的线程开销
			D. Java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的请求都会注册到多路复用器上，多路复用器轮询到连接有
			I/O 请求就进行处理
			E. Java AIO（NIO2）：异步非阻塞，AIO 引入异步通信的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作
			系统完成后才通知服务端程序启动线程去处理，一般适用于连接次数较多且连接时间较长的应用
		② BIO、NIO、AIO 适用场景分析
			A. BIO 方式适用于连接数目比较少且固定的架构，这种方式对服务器资源要求比较高，并发局限限于应用中，JDK1.4 以前的唯一选择，但程序简单易理解。
			B. NIO 方式适用于连接数目比较多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通信等。编程比较复杂，JDK1.4开始支持
			C. AIO 方式适用于连接数目比较多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK1.7开始支持
	2. Java BIO 基本介绍
		① Java BIO 就是传统的 Java IO 编程，其相关的类和接口在 java.io
		② BIO（blocking I/O）：同步阻塞，服务器实现模式一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何
		事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户端连接服务器）
		③ BIO 方式适用于连接数目比较少且固定的架构，这种方式对服务器资源要求比较高，并发局限限于应用中，JDK1.4 以前的唯一选择，但程序简单易理解。
	3. Java BIO 的工作机制
		① 工作原理图
			----------				----------------			----------
			| Thread | ------------ | Read / Write | ---------- | Socket |
			----------				----------------			----------
			
			----------				----------------			----------
			| Thread | ------------ | Read / Write | ---------- | Socket |
			----------				----------------			----------
		② BIO 编程简单流程
			A. 服务端启动一个 ServerSocket
			B. 客户端启动一个 Socket 对服务器进行通信，默认情况下服务端需要对每个客户端建立一个线程与之通信
			C. 客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者遭到拒绝
			D. 如果有响应，客户端线程会等待请求结束后，在继续执行
	4. Java BIO 应用实例
		① 实例说明：
			A. 使用 BIO 模式编程一个服务器，监听 2648 端口，当有客户端连接时，就启动一个线程与之通讯。
			B. 要求使用线程池机制改善，可以连接多个客户端
			C. 服务端可以接收客户端发送的数据（telnet 方式即可）。
				a. win+R，输入 cmd
				b. 在命令行窗口输入：telnet 127.0.0.1 2648，连接到服务端后，服务端会打印“练级到客户端”
				c. 使用 ctrl+] 就可以使客户端和服务器进行通信
				d. 使用 send + “消息”，即可实现客户端先服务端发生消息
		②  问题分析：
			A. 每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write，体现在多次使用 telnet 连接服务端端，发现每个客户端使用的
			线程都不一样，而同一个客户端始终是使用同一个线程进行通信
			B. 当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大
			B. 没有客户端连接时，服务端会阻塞在 accept() 操作上；当客户端连接没有数据发送数据时，服务端会阻塞在 read() 操作上，造成线程资源浪费
		③ 相关代码
			import java.io.IOException;
			import java.io.InputStream;
			import java.net.ServerSocket; 
			import java.net.Socket;
			import java.util.concurrent.ExecutorService;
			import java.util.concurrent.Executors;

			public class BIOServer {

				public static void main(String[] args) throws IOException {

					// 思路：使用线程池机制改善
					// 1. 创建一个线程池
					ExecutorService pool = Executors.newCachedThreadPool();

					// 2. 创建一个 ServerSocket 等待客户端的连接
					ServerSocket serverSocket = new ServerSocket(2648);
					System.out.println("服务端已启动");

					while (true) {

						// 3. 如果有客户端连接，就创建一个线程，与之通讯
						final Socket socket = serverSocket. ;
						System.out.println("连接到客户端");
						pool.execute(() -> {

							// 4. 处理客户端发送的数据
							handler(socket);
						});
					}

				}

				// 接收客户端发送的消息
				public static void handler(Socket socket) {

					// 获取输入流
					try {
						System.out.println("当前线程：" + Thread.currentThread().getId() + ", " + Thread.currentThread().getName());
						InputStream inputStream = socket.getInputStream();
						byte[] b = new byte[1024];
						int len;
						// 循环读取客户端发送的数据
						while ((len = inputStream.read(b)) != -1) {
							System.out.println("当前线程：" + Thread.currentThread().getId() + ", " + Thread.currentThread().getName());
							System.out.println(new String(b, 0, len));
						}

					} catch (IOException e) {
						e.printStackTrace();
					} finally {
						if (socket != null) {
							try {
								socket.close();
							} catch (IOException e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
三、Java NIO 编程	
	1. Java NIO 基本介绍
		① Java NIO 全称 Java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入 / 输出的新特性，被称为为 
		NIO（即 New IO），是同步非阻塞的
		② NIO 相关类都放进 java.nio 包及子包下，并且对原 java.io 包中很多类进行改写。
		③ NIO 有三大核心部分：Channel（通道）、Buffer（缓冲区）和 Selector（选择器）
		④ NIO 是面向缓冲区，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，
		使用它可以提供非阻塞式的高伸缩性网络
		⑤ Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获
		取，而不是保持线程阻塞，所以直至数据变得可读之前，该线程可以继续做其他事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需
		要等待它完全写入，这个线程同时可以做别的事情
		⑥ 通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有一万个请求过来，根据实际情况，可以分配 50 或者 100 个线程来处理。不像之前
		阻塞 IO 那样，非得分配一万个线程
		⑦ HTTP 2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP 1.1 大了好几个数量级
	2. NIO 和 BIO 的比较
		① BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I/O 的效率比流 I/O高很多
		② BIO 是阻塞的，NIO 则是非阻塞的
		③ BIO 基于字节流和字符流进行操作，而 NIO 基于Channel（通道）和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区，或者从缓冲区写入
		通道中。Selector（选择器）用于监听多个通道事件（比如：连接请求，数据到达等），因次使用单个线程就可以监听多个客户端通道
	3. NIO 三大核心原理示意图
		① Selector、Channel 和 Buffer 的关系图
												-----------			----------			--------
											|-> | Channel | ------> | Buffer | -------> | 程序 |
											|	-----------			----------			--------
			----------		------------	|	-----------			----------			--------
			| Thread | ---> | Selector | -----> | Channel | ------> | Buffer | -------> | 程序 |
			----------		------------	|	-----------			----------			--------
											|	-----------			----------			--------
											|-> | Channel | ------> | Buffer | -------> | 程序 |
												-----------			----------			--------
		② 关系图的说明：				
			A. 每个 channel 都会对应一个 Buffer
			B. Selector 对应一个线程，一个线程对应多个 channel（连接）
			C. 该图反映了有三个 channel 注册到该 selector
			D. 程序切换到哪个 channel 是由事件决定的，Event就是一个重要的概念
			E. Selector 会根据不同的事件，在各个通道上切换
			F. Buffer 就是一个内存块，底层是有一个数组
			G. 数据的读取写入是通过 Buffer，这个和BIO不一样，BIO 中要么是输入流，或者是输出流，不能双向，但是 NIO 的 Buffer 是可以读也可以写，需要
			flip() 方法切换
			H. channel 是双向的，可以返回底层操作系统的情况，比如 Linux，底层的操作系统通道就是双向的。
	4. 缓冲区(Buffer)












































































































































































































































































































































































































































