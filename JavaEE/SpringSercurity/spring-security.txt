一. spring security基础篇
	1. spring-security简介并与shiro对比
		① SpringSecurity 框架简介
			A. 官网：https://projects.spring.io/spring-security/
			B. 源代码: https://github.com/spring-projects/spring-security/
			C. Spring Security 是强大的，且容易定制的，基于Spring开发的实现认证登录与资源授权的应用安全框架。
			D. SpringSecurity 的核心功能：
				a. Authentication：认证，用户登陆的验证（解决你是谁的问题）
				b. Authorization：授权，授权系统资源的访问权限（解决你能干什么的问题）
				c. 安全防护，防止跨站请求，session 攻击等
		② shiro与Spring Security的比较
			A. 目前在java web应用安全框架中，与Spring Security形成直接竞争的就是shiro，二者在核心功能上几乎差不多，但从使用的角度各有优缺点。
			B. 没有最好的，只有最合适的。
			C. 用户量：从使用情况上看，二者都在逐步提高使用量。shiro的使用量一直高于spring security.
			D. 使用的方便程度
				a. 通常来说，shiro入门更加容易，使用起来也非常简单，这也是造成shiro的使用量一直高于Spring Security的主要原因
				b. 在没有Spring Boot之前，Spring Security的大部分配置要通过XML实现，配置还是还是非常复杂的。但是有了 Spring Boot之后，这一情况已经得到显著改善。
				c. Spring Security之所以看上去比shiro更复杂，其实是因为它引入了一些不常用的概念与规则。大家应该都知道2/8法则，这在Spring Security里面体现的特别明显，
				如果你只学Spring Security最重要的那20%，这20%的复杂度和shiro基本是一致的。也就是说，不重要的那80%，恰恰是Spring Security比shiro的“复杂度”。
				d. 也就是说，如果有人能帮你把Spring Security最重要的那20%摘出来，二者的入门门槛、复杂度其实是差不太多的。
			E. 社区支持
				a. Spring Security依托于Spring庞大的社区支持，这点自不必多说。shiro属于apache社区，因为它的广泛使用，文档也非常的全面。二者从社区支持来看，几乎不相上下。
				b. 但是从社区发展的角度看，Spring Security明显更占优势，随着Spring Cloud、Spring Boot、Spring Social的长足进步，这种优势会越来越大。因为Spring Security
				毕竟是Spring的亲儿子，Spring Security未来在于Spring系列框架集成的时候一定会有更好的融合性，前瞻性、兼容性！这也是为什么我们要学Spring Security的主要原因！
			F. 功能丰富性：Spring Security因为它的复杂，所以从功能的丰富性的角度更胜一筹。其中比较典型的如
				a. Spring Security默认含有对OAuth2.0的支持，与Spring Social一起使用完成社交媒体登录也比较方便。shiro在这方面只能靠自己写代码实现。
				b. 还有一种普遍说法：Spring Security在网络安全的方面下的功夫更多
			G. 总结：如果你只是想实现一个简单的web应用，shiro更加的轻量级，学习成本也更低。如果您正在开发一个分布式的、微服务的、或者与Spring Cloud系列框架深度集成的项目，
			建议使用Spring Security。
	2. 需求分析与基础环境准备	
		① 需求分析
			A. login.html登录页面，登录页面访问不受限制
			B. 在登录页面登录之后，进入index.html首页（登录验证Authentication）
			C. 首页可以看到syslog、sysuer、biz1、biz2四个页面选项
			D. 我们希望syslog（日志管理）和sysuser(用户管理)只有admin管理员可以访问（权限管理Authorization）
			E. biz1、biz2普通的操作用户auser就可以访问（权限管理Authorization）
		② 环境准备	
			A. 新建spring boot2.0版本的web应用springboot-security
			B. 改POM
				<properties>
					<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
					<maven.compiler.source>1.8</maven.compiler.source>
					<maven.compiler.target>1.8</maven.compiler.target>
					<mysql.version>5.1.47</mysql.version>
					<druid.version>1.1.16</druid.version>
					<mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>
				</properties>

				<parent>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-parent</artifactId>
					<version>2.2.2.RELEASE</version>
				</parent>

				<dependencies>
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-web</artifactId>
					</dependency>
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-actuator</artifactId>
					</dependency>
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-thymeleaf</artifactId>
					</dependency>

					<dependency>
						<groupId>org.mybatis.spring.boot</groupId>
						<artifactId>mybatis-spring-boot-starter</artifactId>
						<version>${mybatis.spring.boot.version}</version>
					</dependency>
					<dependency>
						<groupId>com.alibaba</groupId>
						<artifactId>druid</artifactId>
						<version>${druid.version}</version>
					</dependency>
					<dependency>
						<groupId>mysql</groupId>
						<artifactId>mysql-connector-java</artifactId>
						<version>${mysql.version}</version>
					</dependency>

					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-devtools</artifactId>
						<scope>runtime</scope>
						<optional>true</optional>
					</dependency>
					<dependency>
						<groupId>org.projectlombok</groupId>
						<artifactId>lombok</artifactId>
						<optional>true</optional>
					</dependency>
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-test</artifactId>
						<scope>test</scope>
					</dependency>

					<dependency>
						<groupId>org.webjars</groupId>
						<artifactId>jquery</artifactId>
						<version>3.5.1</version>
					</dependency>
					<dependency>
						<groupId>org.webjars</groupId>
						<artifactId>bootstrap</artifactId>
						<version>4.5.0</version>
					</dependency>
				</dependencies>

				<build>
					<plugins>
						<plugin>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-maven-plugin</artifactId>
						</plugin>

						<plugin>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-maven-plugin</artifactId>
							<configuration>
								<fork>true</fork>
								<addResources>true</addResources>
							</configuration>
						</plugin>
					</plugins>
				</build>
			C. 写YML
				server:
				  port: 8081
				  servlet:
					context-path: /springboot-security
				spring:
				  datasource:
					username: root
					password: 2648
					url: jdbc:mysql://192.168.107.6:3306/test
					driver-class-name: com.mysql.jdbc.Driver
					type: com.alibaba.druid.pool.DruidDataSource
				  thymeleaf:
					cache: false
				  application:
					name: springboot-security
			D. 主启动
				@SpringBootApplication
				@MapperScan("com.li.security.dao")
				public class SpringBootSecurityMain {

					public static void main(String[] args) {
						SpringApplication.run(SpringBootSecurityMain.class, args);
					}
				}
			E. 业务类
				a. DruidConfig
					@Configuration
					public class DruidConfig {

						@ConfigurationProperties(
								prefix = "spring.datasource"
						)
						@Bean
						public DataSource druid() {
							return new DruidDataSource();
						}
					}
				b. MyBatisConfig
					@org.springframework.context.annotation.Configuration
					public class MyBatisConfig {

						@Bean
						public ConfigurationCustomizer configurationCustomizer() {
							return new ConfigurationCustomizer(){

								@Override
								public void customize(Configuration configuration) {
									configuration.setMapUnderscoreToCamelCase(true);
								}
							};
						}
					}
				c. WebConfig
					@Configuration
					public class WebConfig implements WebMvcConfigurer {

						@Bean
						public WebMvcConfigurer webMvcConfigurer() {
							return new WebMvcConfigurer() {
								@Override
								public void addViewControllers(ViewControllerRegistry registry) {
									registry.addViewController("/").setViewName("login");
									registry.addViewController("/login.html").setViewName("login");
								}
							};
						}
					}
				d. UserController
					@Controller
					public class UserController {

						@ResponseBody
						@GetMapping("/hello")
						public String hello() {
							return "hello world";
						}

						@PostMapping("/login")
						public String index() {
							return "index";
						}

						@GetMapping("/syslog")
						public String syslog() {
							return "syslog";
						}

						@GetMapping("/sysuser")
						public String sysuser() {
							return "sysuser";
						}

						@GetMapping("/biz1")
						public String biz1() {
							return "biz1";
						}

						@GetMapping("/biz2")
						public String biz2() {
							return "biz2";
						}

					}
			F. templates
				a. login.html
				b. index.html
				c. syslog.html
				d. sysuser.html
				e. biz1.html
				f. biz2.html
		③ 注：spring-boot 1.5与spring-boot 2.0的区别
			A. spring-boot 2.0 弃用 server.context-path知道根路径，而改成server.servlet.context-path，根据前需要加上“/”
			B. spring-boot 2.0 定制MVC时弃用了继承WebMvcConfigurerAdapyer的方式，而采用实现WebMvcConfigurer接口
	3. HttpBasic模式登录认证
		① HttpBasic登录验证模式是Spring Security实现登录验证最简单的一种方式，也可以说是最简陋的一种方式。它的目的并不是保障登录验证的绝对安全，而是提供一种“防君子不防小人”的登录验证。
		② spring boot2.0整合Spring security
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-security</artifactId>
			</dependency>
		③ HttpBasic登录认证模式
			A. 如果使用的Spring Boot版本为1.X版本,依赖的Security 4.X版本，那么就无需任何配置，启动项目访问则会弹出默认的httpbasic认证.
			B. 我们现在使用的是spring boot2.0版本（依赖Security 5.X版本），HttpBasic不再是默认的验证模式，在spring security 5.x默认的验证模式已经是表单模式。所以我们要使用Basic模式，
			需要自己调整一下。并且security.basic.enabled已经过时了，所以我们需要自己去编码实现。
			C. 代码：
				@Configuration
				public class SecurityConfig extends WebSecurityConfigurerAdapter {

					@Override
					protected void configure(HttpSecurity http) throws Exception {
						http.httpBasic() // 开启httpBasic认证
								.and()
								.authorizeRequests()
								.anyRequest()
								.authenticated(); // 所有请求都需要登录认证才能访问
					}
				}
			D. 启动项目，在项目后台有以下这样的一串日志打印，冒号后面的就是默认密码
				Using generated security password: 20716c77-3400-4a9f-985d-4804c85ad25c
			E. 我们可以通过浏览器进行登录验证，默认的用户名是user.（下面的登录框不是我们开发的，是HttpBasic模式自带的）
			F. 当然我们也可以通过application.yml指定配置用户名密码
				spring:
				  security:
					user:
					  name: admin
					  password: admin
		④ HttpBasic模式的原理说明
			A. 首先，HttpBasic模式要求传输的用户名密码使用Base64模式进行加密。如果用户名是 "admin"  ，密码是“ admin”，则将字符串"admin:admin"使用Base64编码算法加密。加密结果可能是：YWtaW46YWRtaW4=。
			B. 然后，在Http请求中使用Authorization作为一个Header，“Basic YWtaW46YWRtaW4=“作为Header的值，发送给服务端。（注意这里使用Basic+空格+加密串）
			C. 服务器在收到这样的请求时，到达BasicAuthenticationFilter过滤器，将提取“ Authorization”的Header值，并使用用于验证用户身份的相同算法Base64进行解码。
			D. 解码结果与登录验证的用户名密码匹配，匹配成功则可以继续过滤器后续的访问。
			E. 所以，HttpBasic模式真的是非常简单又简陋的验证模式，Base64的加密算法是可逆的，你知道上面的原理，分分钟就破解掉。我们完全可以使用PostMan工具，或者浏览器开发工具中，发送Http请求进行登录验证
			查看header参数即可获取用户名密码的Base64。
	4. formLogin模式登录认证
		① formLogin的应用场景
			A. 在本专栏之前的文章中，已经给大家介绍过Spring Security的HttpBasic模式，该模式比较简单，只是进行了通过携带Http的Header进行简单的登录验证，而且没有定制的登录页面，所以使用场景比较窄。
			B. 对于一个完整的应用系统，与登录验证相关的页面都是高度定制化的，非常美观而且提供多种登录方式。这就需要Spring Security支持我们自己定制登录页面，也就是本文给大家介绍的formLogin模式登录认证模式。
			C. 准备工作：
				a. 新建一个Spring Boot 的web应用，引入Spring Security Starter
				b. 准备一个login.html登录页面，页面内容非常简单，一个from表单、用户名和密码输入框，一个提交按钮
				c. 准备一个首页index.html，在登录成功之后需要进入index.html首页
				d. 首页可以看到syslog（日志管理）、sysuer（用户管理）、biz1（业务一）、biz2（业务二）四个页面超文本链接选项。通过controller控制层跳转页面，并在对应页面写一些标志性文字即可，不需写具体业务。
			D. 需求
				a. 我们希望biz1（业务一）、biz2（业务二）普通的操作用户user就可以访问
				b. 管理员可以访问包括syslog（日志管理）和sysuser(用户管理)在内的所有资源
		② 说明
			A. formLogin模式的三要素：
				a. 登录认证逻辑
				b. 资源访问控制规则，如：资源权限、角色权限
				c. 用户角色权限
			B. 一般来说，使用权限认证框架的的业务系统登录验证逻辑是固定的，而资源访问控制规则和用户信息是从数据库或其他存储介质灵活加载的。
		③ 登录认证及资源访问权限的控制
			A. 首先，我们要继承WebSecurityConfigurerAdapter ，重写configure(HttpSecurity http) 方法，该方法用来配置登录验证逻辑。请注意看下文代码中的注释信息。
				@Configuration
				public class SecurityConfig extends WebSecurityConfigurerAdapter {

					@Override
					protected void configure(HttpSecurity http) throws Exception {
						http.csrf().disable() //禁用跨站csrf攻击防御，后面的章节会专门讲解
							.formLogin()
							.loginPage("/login.html")//用户未登录时，访问任何资源都转跳到该路径，即登录页面
							.loginProcessingUrl("/login")//登录表单form中action的地址，也就是处理认证请求的路径
							.usernameParameter("username")///登录表单form中用户名输入框input的name名，不修改的话默认是username
							.passwordParameter("password")//form中密码输入框input的name名，不修改的话默认是password
							.defaultSuccessUrl("/index")//登录认证成功后默认转跳的路径
						.and()
							.authorizeRequests()
							.antMatchers("/login.html","/login").permitAll()//不需要通过登录验证就可以被访问的资源路径
							.antMatchers("/biz1","/biz2") //需要对外暴露的资源路径
								.hasAnyAuthority("ROLE_user","ROLE_admin")  //user角色和admin角色都可以访问
							.antMatchers("/syslog","/sysuser")
								.hasAnyRole("admin")  //admin角色可以访问
							//.antMatchers("/syslog").hasAuthority("sys:log")
							//.antMatchers("/sysuser").hasAuthority("sys:user")
							//.antMatchers("/syslog").hasAuthority("sys:log")
							//.antMatchers("/sysuser").hasAuthority("sys:user")
							.anyRequest().authenticated();
					}
					
				}
			B. 上面的代码分为两部分：
				a. 第一部分是formLogin配置段，用于配置登录验证逻辑相关的信息。如：登录页面、登录成功页面、登录请求处理路径等。
				b. 第二部分是authorizeRequests配置端，用于配置资源的访问权限。如：开发登录页面的permitAll开放访问，“/biz1”（业务一页面资源）需要有角色为user或admin的用户才可以访问。
				c. hasAnyAuthority("ROLE_user","ROLE_admin")等价于hasAnyRole("user","admin"),角色是一种特殊的权限。
				d. "sys:log"或"sys:log"是我们自定义的权限ID，有这个ID的用户可以访问对应的资源
				e. 这时候，我们通过浏览器访问，随便测试一个没有访问权限的资源，都会跳转到login.html页面。
		④ 用户及角色信息配置
			A. 在上文中，我们配置了登录验证及资源访问的权限规则，我们还没有具体的用户，下面我们就来配置具体的用户。重写WebSecurityConfigurerAdapter的 configure(AuthenticationManagerBuilder auth)方法
				@Override
				protected void configure(AuthenticationManagerBuilder auth) throws Exception {
					auth.inMemoryAuthentication()
							.withUser("user")
							.password(passwordEncoder().encode("2648"))
							.roles("user")
							.and()
							.withUser("admin")
							.password(passwordEncoder().encode("2648"))
							.roles("admin")
							//.authorities("sys:log","sys:user")
							.and()
							.passwordEncoder(passwordEncoder()); // 配置BCrypt加密
				}

				@Bean
				public PasswordEncoder passwordEncoder() {
					return new BCryptPasswordEncoder();
				}
			B. inMemoryAuthentication指的是在内存里面存储用户的身份认证和授权信息。
			C. withUser("user")用户名是user
			D. password(passwordEncoder().encode("2648"))密码是加密之后的2648
			E. authorities("sys:log","sys:user")指的是admin用户拥有资源ID对应的资源访问的的权限："/syslog"和"/sysuser"
			F. roles()方法用于指定用户的角色，一个用户可以有多个角色
			G. 注意：使用Spring-Security时会自动进行登录认证，不需要自己编写任何的认证代码。
		⑤ 静态资源访问 
			A. 在我们的实际开发中，登录页面login.html和控制层Controller登录验证'/login'都必须无条件的开放。除此之外，一些静态资源如css、js文件通常也都不需要验证权限，我们需要将它们的访问权限也开放出来。
			下面就是实现的方法：重写WebSecurityConfigurerAdapter类的configure(WebSecurity web) 方法
			B. 代码：
				@Override
				public void configure(WebSecurity web) throws Exception {

					web.ignoring() // 将项目中的静态资源路径开放出来
							.antMatchers("/**/css/**", "/**/fonts/**", "/**/img/**", "/**/js/**");
				}































































































































