二. 认证授权鉴权功能深入
	1. RBAC权限管理模型
		① 我们开发一个系统，必然面临权限控制的问题，即不同的用户具有不同的访问、操作、数据权限。形成理论的权限控制模型有：自主访问控制（DAC: Discretionary Access Control）、
		强制访问控制（MAC: Mandatory Access Control）、基于属性的权限验证（ABAC: Attribute-Based Access Control）等。最常被开发者使用也是相对易用、通用的就是RBAC权限模型
		（Role-Based Access Control），本文就将向大家介绍该权限模型。
		② RBAC权限模型简介
			A. RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。模型中有几个关键的术语：
				a. 用户：系统接口及访问的操作者
				b. 角色：具有一类相同操作权限的用户的总称
				c. 权限：能够访问某接口或者做某操作的授权资格
			B. RBAC权限模型核心授权逻辑如下：
				a. 某用户是什么角色？
				b. 某角色具有什么权限？
				c. 通过角色的权限推导用户的权限
		③ RBAC的演化进程
			A. 用户与权限直接关联
				a. 想到权限控制，人们最先想到的一定是用户与权限直接关联的模式，简单地说就是：某个用户具有某些权限。如图：
					(1) 张三具有创建用户和删除用户的权限，所以他可能系统维护人员
					(2) 李四具有产品记录管理和销售记录管理权限，所以他可能是一个业务销售人员
				b. 这种模型能够清晰的表达用户与权限之间的关系，足够简单。但同时也存在问题：
					(1) 现在用户是张三、李四，以后随着人员增加，每一个用户都需要重新授权
					(2) 或者张三、李四离职，需要针对每一个用户进行多种权限的回收
			B. 一个用户拥有一个角色
				a. 在实际的团体业务中，都可以将用户分类。比如对于薪水管理系统，通常按照级别分类：经理、高级工程师、中级工程师、初级工程师。也就是按照一定的角色分类，
				通常具有同一角色的用户具有相同的权限。这样改变之后，就可以将针对用户赋权转换为针对角色赋权。
				b. 一个用户有一个角色
				c. 一个角色有多个操作（菜单）权限
				d. 一个操作权限可以属于多个角色
			C. 一个用户一个或多个角色
				a. 但是在实际的应用系统中，一个用户一个角色远远满足不了需求。如果我们希望一个用户既担任销售角色、又暂时担任副总角色。该怎么做呢？为了增加系统设计的适用性，
				我们通常设计：
					(1) 一个用户有一个或多个角色
					(2) 一个角色包含多个用户
					(3) 一个角色有多种权限
					(4) 一个权限属于多个角色
				b. 描述这样的关系。
					(1) sys_user是用户信息表，用于存储用户的基本信息，如：用户名、密码
					(2) sys_role是角色信息表，用于存储系统内所有的角色
					(3) sys_menu是系统的菜单信息表，用于存储系统内所有的菜单。用id与父id的字段关系维护一个菜单树形结构。
					(4) sys_user_role是用户角色多对多关系表，一条userid与roleid的关系记录表示该用户具有该角色，该角色包含该用户。
					(5) sys_role_menu是角色菜单(权限)关系表，一条roleid与menuid的关系记录表示该角色由某菜单权限，该菜单权限可以被某角色访问。
	2. 结合真实系统讲解RBAC实现
		① 回顾RBAC权限模型
			A. 用户与角色之间是多对多的关系，一个用户有多个角色，一个角色包含多个用户
			B. 角色与权限之间是多对多关系，一个角色有多种权限，一个权限可以属于多个角色
			C. User是用户表，存储用户基本信息
			D. Role是角色表，存储角色相关信息
			E. Menu(菜单)是权限表，存储系统包含哪些菜单及其属性
			F. UserRole是用户和角色的关系表
			G. RoleMenu是角色和权限的关系表
		② 组织部门管理
			A. 需求分析
				a. 之所以先将部门管理提出来讲一下，是因为部门管理没有在我们上面的RBAC权限模型中进行体现。但是部门这样一个实体仍然是，后端管理系统的一个重要组成部分。
				通常有如下的需求
				b. 部门要能体现出上下级的结构（如上图中的红框）。在关系型数据库中。这就需要使用到部门id及上级部门id，来组合成一个树形结构。
				c. 如果组织与用户之间是一对多的关系，就在用户表中加上一个org_id标识用户所属的组织。原则是：实体关系在多的那一边维护。
				d. 如果组织与用户是多对多关系，这种情况现实需求也有可能存在。比如：某人在某单位既是生产部长，又是技术部长。所以他及归属于技术部。也归属于生产部。
				对于这种情况有两种解决方案，把该人员放到公司级别，而不是放到部门级别。另外一种就是从数据库结构上创建User与Org组织之间的多对多关系。
				e. 组织信息包含一些基本信息，如组织名称、组织状态、展现排序、创建时间
				另外，要有基本的组织的增删改查功能
			B. 组织部门表的CreateSQL
				CREATE TABLE `sys_org` (
				  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '系统组织结构表主键ID',
				  `org_pid` int(11) DEFAULT NULL COMMENT '父节点ID',
				  `org_pids` varchar(64) DEFAULT NULL COMMENT '所有父节点ID',
				  `is_leaf` tinyint(1) NOT NULL COMMENT '是否是叶节点，0：否；1：是',
				  `org_name` varchar(32) NOT NULL COMMENT '组织名',
				  `address` varchar(64) DEFAULT NULL COMMENT '地址',
				  `phone` varchar(20) DEFAULT NULL COMMENT '联系电话',
				  `email` varchar(20) DEFAULT NULL COMMENT '联系邮箱',
				  `sort` tinyint(1) NOT NULL COMMENT '相对于父节点的排序',
				  `level` tinyint(1) NOT NULL COMMENT '对应的层级',
				  `status` tinyint(1) NOT NULL COMMENT '是否可用，0：否；1：是',
				  PRIMARY KEY (`id`)
				) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4;
			C. 注意：mysql没有oracle中的start with connect by的树形数据汇总SQL。所以通常需要为了方便管理组织之间的上下级树形关系，需要加上一些特殊字段，如：org_pids：
			该组织所有上级组织id逗号分隔，即包括上级的上级；is_leaf是否是叶子结点；level组织所属的层级(1,2,3)。
		③ 菜单权限管理
			A. 需求分析
				a. 菜单仍然是树形结构，所以数据库表必须有id与menu_pid字段
				b. 必要字段：菜单跳转的url、是否启用、菜单排序、菜单的icon矢量图标等
				c. 最重要的是菜单要有一个权限标志，具有唯一性。通常可以使用菜单跳转的url路径作为权限标志。此标志作为权限管理框架识别用户是否具有某个页面查看权限的重要标志
				d. 需要具备菜单的增删改查基本功能
				e. 如果希望将菜单权限和按钮超链接相关权限放到同一个表里面，可以新增一个字段。用户标志该权限记录是菜单访问权限还是按钮访问权限。
			B. 菜单权限表的CreateSQL
				CREATE TABLE `sys_menu` (
				  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '菜单/权限表主键ID',
				  `menu_pid` int(11) DEFAULT NULL COMMENT '父节点ID',
				  `menu_pids` int(11) DEFAULT NULL COMMENT '所有父节点ID',
				  `is_leaf` tinyint(1) NOT NULL COMMENT '是否是叶节点，0：否；1：是',
				  `menu_name` varchar(32) NOT NULL COMMENT '菜单/权限名称',
				  `url` varchar(64) DEFAULT NULL COMMENT '路由地址',
				  `icon` varchar(32) DEFAULT NULL COMMENT '菜单字体图标',
				  `icon_color` varchar(16) DEFAULT NULL COMMENT '菜单字体图标颜色',
				  `sort` tinyint(1) NOT NULL COMMENT '相对于父节点的排序',
				  `level` tinyint(1) NOT NULL COMMENT '对应的层级',
				  `status` tinyint(1) NOT NULL COMMENT '是否可用，0：否；1：是',
				  PRIMARY KEY (`id`)
				) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8mb4;
		④ 角色管理
			A. 需求分析
				① 角色本身的管理需要注意的点非常少，就是简单的增删改查。重点在于角色分配该如何做。
				② 角色表包含角色id，角色名称，备注、排序顺序这些基本信息就足够了
				③ 为角色分配权限：以角色为基础勾选菜单权限或者操作权限，然后先删除sys_role_menu表内该角色的所有记录，在将新勾选的权限数据逐条插入sys_role_menu表。
				④ sys_role_menu的结构很简单，记录role_id与menu_id，一个角色拥有某一个权限就是一条记录。
				⑤ 角色要有一个全局唯一的标识，因为角色本身也是一种权限。可以通过判断角色来判断某用户的操作是否合法。
				⑥ 通常的需求：不会在角色管理界面为角色添加用户，而是在用户管理界面为用户分配角色。
			B. 角色表的CreateSQL
				CREATE TABLE `sys_role` (
				  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '系统角色表主键ID',
				  `role_name` varchar(32) NOT NULL COMMENT '角色名称(中文)',
				  `role_code` varchar(32) NOT NULL COMMENT '角色名称(英文)',
				  `role_desc` varchar(100) DEFAULT NULL COMMENT '角色描述',
				  `sort` tinyint(1) NOT NULL COMMENT '角色顺序',
				  `status` tinyint(1) NOT NULL COMMENT '是否可用，0：否；1：是',
				  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '角色的创建日期',
				  PRIMARY KEY (`id`)
				) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;
			C. 角色菜单权限关联表的CreateSQL
				CREATE TABLE `role_menu` (
				  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '角色权限表主键ID',
				  `role_id` int(11) NOT NULL COMMENT '角色ID',
				  `menu_id` int(11) NOT NULL COMMENT '权限ID',
				  PRIMARY KEY (`id`)
				) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4;
		⑤ 用户管理
			A. 需求分析
				a. 上图中点击左侧的组织菜单树结点，要能显示出该组织下的所有人员（系统用户）。在组织与用户是一对多的关系中，需要在用户表加上org_id字段，用于查询某个
				组织下的所有用户。
				b. 用户表中要保存用户的用户名、加密后的密码。页面提供密码修改或重置的功能。
				c. 角色分配:实际上为用户分配角色，与为角色分配权限的设计原则是一样的。所以可以参考。
				d. 实现用户基本信息的增删改查功能
			B. 用户信息表的CreateSQL
				CREATE TABLE `sys_user` (
				  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户信息表主键ID',
				  `username` varchar(64) NOT NULL COMMENT '用户名',
				  `password` varchar(64) NOT NULL COMMENT '密码',
				  `phone` varchar(20) DEFAULT NULL COMMENT '联系电话',
				  `email` varchar(20) DEFAULT NULL COMMENT '联系邮箱',
				  `enabled` tinyint(1) NOT NULL COMMENT '是否可用，0：否；1：是',
				  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '用户创建时间',
				  `org_id` int(11) NOT NULL COMMENT '组织id',
				  PRIMARY KEY (`id`)
				) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4;
			C. 用户角色关系表的CreateSQL
				CREATE TABLE `user_role` (
				  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户角色表主键ID',
				  `user_id` int(11) NOT NULL COMMENT '用户ID',
				  `role_id` int(11) NOT NULL COMMENT '角色ID',
				  PRIMARY KEY (`id`)
				) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;
			D.  注意
				a. 在用户的信息表中，体现了一些隐藏的需求。如：多次登录锁定与锁定到期时间的关系。账号有效期的设定规则等。
				b. 当然用户表中，根据业务的不同还可能加更多的信息，比如：用户头像等等。但是通常在比较大型的业务系统开发中，业务模块中使用的用户表和在权限管理模块使用的
				用户表通常不是一个，而是根据某些唯一字段弱关联，分开存放。这样做的好处在于：经常发生变化的业务需求，不会去影响不经常变化的权限模型。
		⑥ 查询的SQL语句
			A. 查询用户信息
				SELECT username, PASSWORD, enabled FROM sys_user 
				WHERE username = 'admin'
			B. 查询用户的角色信息
				SELECT role_code FROM sys_user u
				LEFT JOIN user_role ur ON u.id = ur.user_id
				LEFT JOIN sys_role r ON r.id = ur.role_id
				WHERE u.username = 'admin'
			C. 查询角色的权限信息
				SELECT url FROM sys_role r
				LEFT JOIN role_menu rm ON r.id = rm.role_id
				LEFT JOIN sys_menu m ON m.id = rm.menu_id
				WHERE role_code IN ('admin');
	3. 加载动态数据进行登录与授权		
		① 动态数据登录验证的基础知识	
			A. 前面介绍了Spring Security的formLogin登录认证模式，RBAC的权限控制管理模型，并且针对Spring Security的登录认证逻辑源码进行了解析等等。我们所有的用户、角色、
			权限信息都是在配置文件里面写死的，然而在实际的业务系统中，这些信息通常是存放在RBAC权限模型的数据库表中的。下面我们来回顾一下其中的核心概念：
			B. RBAC的权限模型可以从用户获取为用户分配的一个或多个角色，从用户的角色又可以获取该角色的多种权限。通过关联查询可以获取某个用户的角色信息和权限信息。
			C. 在源码解析的文章中，我们知道如果我们不希望用户、角色、权限信息写死在配置里面。我们应该实现UserDetails与UserDetailsService接口，从而从数据库或者其他的
			存储上动态的加载这些信息。
		② UserDetails与UserDetailsService接口
			A. UserDetailsService接口有一个方法叫做loadUserByUsername，我们实现动态加载用户、角色、权限信息就是通过实现该方法。函数见名知义：通过用户名加载用户。该方法的
			返回值就是UserDetails。
			B. UserDetails就是用户信息，即：用户名、密码、该用户所具有的权限。
			C. UserDetails接口有以下方法
				public interface UserDetails extends Serializable {
					Collection<? extends GrantedAuthority> getAuthorities();
					
					String getPassword();

					String getUsername();

					boolean isAccountNonExpired();

					boolean isAccountNonLocked();

					boolean isCredentialsNonExpired();

					boolean isEnabled();
				}
			D. 只要我们把这些信息提供给Spring Security，Spring Security就知道怎么做登录验证了，根本不需要我们自己写Controller实现登录验证逻辑。
		③ 实现UserDetails 接口
			A. MyUserDetails:
				public class MyUserDetails implements UserDetails {

					private Collection<? extends GrantedAuthority> authorities; // //用户的权限集合

					private String password; // 密码

					private String username; // 用户名

					private boolean enabled; // 账号是否可用

					private boolean accountNonExpired; // 是否没过期

					private boolean accountNonLocked; // 是否没被锁定

					private boolean credentialsNonExpired; // 是否没过期
					
					//省略构造方法
					//省略set方法
					//省略get方法（即接口UserDetails的方法）
				}
			B. 我们就是写了一个适应于UserDetails的java POJO类，所谓的 UserDetails接口实现就是一些get方法。get方法由Spring Security调用，我们通过set方法或构造函数为 
			Spring Security 提供UserDetails数据（从数据库查询）。
			C. 注意：目前数据库表里面没有定义accountNonExpired、accountNonLocked、credentialsNonExpired这三个字段，所以其get方法，先直接返回true即可。
		④ 实现UserDetailsService接口
			A. 通常数据库表sys_user字段要和SysUser属性一一对应，比如username、password、enabled。但是比如accountNonLocked字段用于登录多次错误锁定，但我们一般不会在表里
			存是否锁定，而是存一个锁定时间字段。通过锁定时间是否大于当前时间判断账号是否锁定，所以实现过程中可以灵活做判断并用好set方法，不必拘泥于一一对应的形式。
			B. 角色是一种特殊的权限，在Spring Security我们可以使用hasRole(角色标识)表达式判断用户是否具有某个角色，决定他是否可以做某个操作;通过hasAuthority(权限标识)
			表达式判断是否具有某个操作权限。
			C. 代码：
				@Component
				public class MyUserDetailsService implements UserDetailsService {

					@Autowired
					private MyUserDetailsMapper myUserDetailsMapper;

					@Override
					public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
						// 1. 根据用户名查询用户信息
						MyUserDetails myUserDetails = myUserDetailsMapper.findByUserName(username);

						if (myUserDetails == null) {
							throw new UsernameNotFoundException("该用户不存在");
						}

						// 2. 根据用户明显查询用户角色
						List<String> roleCodes = myUserDetailsMapper.findRoleByUserName(username);

						// 3. 根据用户角色查询用户权限
						List<String> authorities = myUserDetailsMapper.findAuthorityByRoleCodes(roleCodes);

						// 4. 角色是一种特殊的权限，并且角色是以ROLE_为前缀（Spring Security规范）
						roleCodes = roleCodes.stream()
								.map(role -> "ROLE_" + role)
								.collect(Collectors.toList());

						// 5. 将所有角色添加到权限集合中
						authorities.addAll(roleCodes);

						// 6. 转成用逗号分隔的字符串，为用户设置权限标识
						myUserDetails.setAuthorities(
								AuthorityUtils.commaSeparatedStringToAuthorityList(
										String.join(",", authorities)
								)
						);
						return myUserDetails;
					}
				}
		⑤ 注册UserDetailsService
			A. 重写WebSecurityConfigurerAdapter的 configure(AuthenticationManagerBuilder auth)方法
			B. 代码：
				@Override
				protected void configure(AuthenticationManagerBuilder auth) throws Exception {
					auth.userDetailsService(myUserDetailsService).passwordEncoder(passwordEncoder());
				}
				
				
				
				@Bean
				public PasswordEncoder passwordEncoder() {
					return new BCryptPasswordEncoder();
				}
			C. 使用BCryptPasswordEncoder，表示存储中（数据库）取出的密码必须是经过BCrypt加密算法加密的。
			D. 这里需要注意的是，因为我们使用了BCryptPasswordEncoder加密解密，所以数据库表里面存的密码应该是加密之后的密码（造数据的过程），可以使用如下代码加密
			（如密码是：123456）。将打印结果保存保存到密码字段。
			E. 代码：
				@Autowired
				private PasswordEncoder passwordEncoder;
				
				@Test
				public void contextLoads() {
					System.out.println(passwordEncoder.encode("2648"));
				}
			F. 角色ID对应UserDetails中的权限集合中的元素，因此需要将资源路径与权限url对应后才具备对资源的访问权限
				protected void configure(HttpSecurity http) throws Exception {
					http.csrf().disable()
					...
					.antMatchers("/biz1", "/biz2") // 需要对外暴露的资源路径
					.hasAnyAuthority("ROLE_user", "ROLE_admin") // user 和 admin 角色可以访问的资源
					.antMatchers("/syslog").hasAuthority("/updUser")// 有该角色ID才能访问该资源
					.antMatchers("/sysuser").hasAuthority("/delUser")
					...
				}
		⑥ 最后说明
			A. 至此，我们将系统里面的所有的用户、角色、权限信息都通过UserDetailsService和UserDetails告知了Spring Security。但是多数朋友可能仍然不知道该怎样实现登
			录的功能，其实剩下的事情很简单了：
				a. 写一个登录界面，写一个登录表单，表单使用post方法提交到默认的/login路径
				b. 表单的用户名、密码字段名称默认是username、password。
				c. 写一个登录成功之后的跳转页面，比如index.html
			B. 然后把这些信息通过配置方式告知Spring Security ，以上的配置信息名称都可以灵活修改
		⑦ Mybatis持久层数据接口
			A. MyUserDetailsMapper
				@Mapper
				public interface MyUserDetailsMapper {

					// 根据用户名查询用户信息
					MyUserDetails findByUserName(String userName);

					// 根据用户名查询用户角色
					List<String> findRoleByUserName(String userName);

					// 根据用户角色查询用户权限
					List<String> findAuthorityByRoleCodes(@Param("roleCodes") List<String> roleCodes);

				}
			B. MyUserDetailsMapper.xml
				<select id="findByUserName" resultType="com.li.security.config.auth.MyUserDetails">
					SELECT username, password, enabled FROM sys_user WHERE username = #{username}
				</select>

				<select id="findRoleByUserName" resultType="string">
					SELECT role_code FROM sys_user u
					LEFT JOIN user_role ur ON u.id = ur.user_id
					LEFT JOIN sys_role r ON r.id = ur.role_id
					WHERE u.username = #{username}
				</select>

				<select id="findAuthorityByRoleCodes" resultType="string">
					SELECT url FROM sys_role r
					LEFT JOIN role_menu rm ON r.id = rm.role_id
					LEFT JOIN sys_menu m ON m.id = rm.menu_id
					<where>
						<choose>
							<when test="roleCodes == null || roleCodes.size() == 0">
								role_code = ''
							</when>
							<otherwise>
								role_code in
								<foreach collection="roleCodes" item="roleCode" open="(" separator=", " close=")">
									#{roleCode}
								</foreach>
							</otherwise>
						</choose>
					</where>
			   </select>
	4. 动态加载资源鉴权规则
		① 已经实现了从RBAC数据库中加载用户的角色、权限信息。在我们的Spring Security配置类SecurityConfig中仍然有一部分内容是通过代码静态配置的，那就是：资源鉴权规则。
		② 简单说“资源鉴权规则”就是：你有哪些权限？这些权限能够访问哪些资源？即：权限与资源的匹配关系。
		③ 动态资源鉴权规则
			A. 代码：
				@Component("rbacService")
				public class MyRBACService {

					public boolean hasPermission(HttpServletRequest request, Authentication authentication) {
						Object principal = authentication.getPrincipal();

						if (principal instanceof UserDetails) {
							UserDetails userDetails = (UserDetails) principal;
							List<GrantedAuthority> grantedAuthorities =
									AuthorityUtils.commaSeparatedStringToAuthorityList(request.getRequestURI());
							return userDetails.getAuthorities().contains(grantedAuthorities.get(0));
						}
						return false;
					}
				}
			B. 上述代码逻辑
				a. 获取具有用户信息的UserDetails对象
				b. 将用户访问的url转换为GrantedAuthority对象
				c. 判断UserDetails对象的authoritie属性中是否包含请求的url，由于用户登陆时，UserDetails对象已经存在内存中，因此不需要再次从数据库中加载用户的权限列表
				d. 用户每一次访问系统资源的时候，都会执行这个方法，判断该用户是否具有访问该资源的权限。
		④ 权限规则表达式实现
			A. 代码：
				@Override
				protected void configure(HttpSecurity http) throws Exception {
					http.csrf().disable()
					...
					.authorizeRequests()
					.antMatchers("/login.html", "/", "/login").permitAll() // 不需要通过登录验证就可以被访问的资源路径
					.antMatchers("/index").authenticated() // 用户登录即可访问的页面，即不需要任何权限
					.anyRequest().access("@rbacService.hasPermission(request, authentication)") //判断用户是否具备访问资源的权限
					...
				}
			B. 资源鉴权规则完成之后的效果
				a. 这部分内容将静态规则替换为动态从数据库加载
				b. 登录页面“login.html”和登录认证处理路径“/login”需完全对外开发，不需任何鉴权就可以访问
				c. 首页"/index"必须authenticated，即：登陆之后才能访问。不做其他额外鉴权规则控制
				d. 最后，其他的资源的访问我们通过权限规则表达式实现，表达式规则中使用了rbacService，这个类我们自定义实现。该类服务hasPermission从内存(或数据库)动态加载
				资源匹配规则，进行资源访问鉴权。
				e. 表达式规则中hasPermission方法的参数必须是request和authentication，这是Spring Security的规范
	5. 权限表达式使用方法总结			
		① SPEL表达式权限控制：
			A. 从spring security 3.0开始已经可以使用spring Expression表达式来控制授权，允许在表达式中使用复杂的布尔逻辑来控制访问的权限。Spring Security
			可用表达式对象的基类是SecurityExpressionRoot。
			B. 表达式函数		
				a. hasRole([role])：用户拥有指定的角色时返回true （Spring security默认会带有ROLE_前缀）,去除前缀参考Remove the ROLE_
				b. hasAnyRole([role1,role2])：用户拥有任意一个指定的角色时返回true
				c. hasAuthority([authority])：拥有某资源的访问权限时返回true
				d. hasAnyAuthority([auth1,auth2])
				e. permitAll：永远返回true
				f. denyAll：永远返回false
				g. anonymous：当前用户是anonymous时返回true
				h. rememberMe：当前用户是rememberMe用户返回true
				i. authentication：当前登录用户的authentication对象
				j. fullAuthenticated：当前用户既不是anonymous也不是rememberMe用户时返回true
				k. hasIpAddress('192.168.1.0/24')：请求发送的IP匹配时返回true
			C. 可能会对Authority和Role有些混淆。Authority作为资源访问权限可大可小，可以是某按钮的访问权限（如资源ID：biz1），也可以是某类用户角色的访问权限（如资源ID：ADMIN）。
			当Authority作为角色资源权限时，hasAuthority（'ROLE_ADMIN'）与hasRole（'ADMIN'）是一样的效果。
		② SPEL在全局配置中的使用
			A. 我们可以通过继承WebSecurityConfigurerAdapter，实现相关的配置方法，进行全局的安全配置。
			B. 如何在全局配置中使用SPEL表达式
				a. URL安全表达式
					(1) 这里我们定义了应用/system/*URL的范围，只有拥有ADMIN或者USER权限的用户才能访问这些person资源。
					(2) 代码：
						config.antMatchers("/system/*").access("hasAuthority('ADMIN') or hasAuthority('USER')")
							.anyRequest().authenticated();
				b. 安全表达式中引用bean
					(1) 这种方式，比较适合有复杂权限验证逻辑的情况，当Spring Security提供的默认表达式方法无法满足我们的需求的时候。
					(2) 代码：
						@Component("rbacService")
						@Slf4j
						public class RbacService {
							//返回true表示验证通过
							public boolean hasPermission(HttpServletRequest request, Authentication authentication) {
								//验证逻辑代码
								return true;
							}
							public boolean checkUserId(Authentication authentication, int id) {
								//验证逻辑代码
								return true;
							}
						}
					(3) 对于"/person/{id}"对应的资源的访问，调用rbacService的bean的方法checkUserId进行权限验证，传递参数为authentication对象和person的id。该id为PathVariable，
					以#开头表示。
					(4) 代码：
						config.antMatchers("/person/{id}").access("@rbacService.checkUserId(authentication,#id)")
							.anyRequest().access("@rbacService.hasPermission(request,authentication)");
		③ Method表达式安全控制
			A. 如果我们想实现方法级别的安全配置，Spring Security提供了四种注解，分别是@PreAuthorize , @PreFilter , @PostAuthorize 和 @PostFilter
			B. 开启方法级别注解的配置
				a. 在Spring安全配置代码中，加上EnableGlobalMethodSecurity注解，开启方法级别安全配置功能。
				b. 代码：
					@Configuration
					@EnableGlobalMethodSecurity(prePostEnabled = true)
					public class MySecurityConfig extends WebSecurityConfigurerAdapter {
			C. 使用PreAuthorize注解
				a. @PreAuthorize 注解适合进入方法前的权限验证。只有拥有ADMIN角色才能访问findAll方法。
				b. 如果当前登录用户没有PreAuthorize需要的权限，将抛出org.springframework.security.access.AccessDeniedException异常！
				c. 代码：
					@PreAuthorize("hasRole('admin')")
					public List<PersonDemo> findAll(){
						return null;
					}
			D. 使用PostAuthorize注解	
				a. @PostAuthorize 在方法执行后再进行权限验证,适合根据返回值结果进行权限验证。Spring EL 提供返回对象能够在表达式语言中获取返回的对象returnObject。下文代码只有返回
				值的name等于authentication对象的name（当前登录用户名）才能正确返回，否则抛出异常。
				b. 代码：
					@PostAuthorize("returnObject.name == authentication.name")
					public PersonDemo findOne(){
						String authName =
								SecurityContextHolder.getContext().getAuthentication().getName();
						System.out.println(authName);
						return new PersonDemo("admin");
					}
			E. 使用PreFilter注解
				a. PreFilter 针对参数进行过滤,下文代码表示针对ids参数进行过滤，只有id为偶数的元素才被作为参数传入函数。
				b. 代码：
					//当有多个对象是使用filterTarget进行标注
					@PreFilter(filterTarget="ids", value="filterObject%2==0")
					public void delete(List<Integer> ids, List<String> usernames) {

					}
			F. 使用PostFilter 注解
				a. ostFilter 针对返回结果进行过滤，特别适用于集合类返回值，过滤集合中不符合表达式的对象。
				b. 代码：
					@PostFilter("filterObject.name == authentication.name")
					public List<PersonDemo> findAllPD(){

						List<PersonDemo> list = new ArrayList<>();
						list.add(new PersonDemo("kobe"));
						list.add(new PersonDemo("admin"));

						return list;
					}
	6. RememberMe记住我功能
		① 登录过程中经常使用的“记住我”功能，也就是我们经常会在各种网站登陆时见到的"两周内免登录"，“三天内免登录”的功能。该功能的作用就是：当我们登录成功之后，一定的周期内当我们再
		次访问该网站，不需要重新登录。
		② 最简实践
			A. 其实实现这个功能非常简单，只需要我们在重写WebSecurityConfigurerAdapter 方法配置HttpSecurity 的时候增加rememberMe()方法。
			B. 后端代码：
				@Override
				protected void configure(HttpSecurity http) throws Exception {
					http.rememberMe()
							.and().csrf().disable() //禁用跨站csrf攻击防御，后面的章节会专门讲解
				}
			C. 然后在登录表单中加入一个checkbox勾选框，name属性的值目前必须是“remember-me”（可定制）
			D. 前端代码：
				<div class="checkbox">
					<label>
						<input type="checkbox" id="rememberMe" name="remember-me"> 记住密码
					</label>
				</div>
			E. 就是这么简单，我们就实现了记住我功能，默认效果是：2周内免登录。
		③ 实现原理
			A. RememberMe记住我功能的流程
				a. 当我们登陆的时候，除了用户名、密码，我们还可以勾选remember-me。
				b. 如果我们勾选了remember-me，当我们登录成功之后服务端会生成一个Cookie返回给浏览器，这个Cookie的名字默认是remember-me；值是一个token令牌。
				c. 当我们在有效期内再次访问应用时，经过RememberMeAuthenticationFilter,读取Cookie中的token进行验证。验正通过不需要再次登录就可以进行应用访问。
			B. RememberMeToken 的组成
				a. RememberMeToken = username, expiryTime, signatureValue的Base64加密
				b. signatureValue = username、expirationTime和passwod和一个预定义的key，并将他们经过MD5进行签名。
				c. TokenBasedRememberMeServices中的源码
					protected String makeTokenSignature(long tokenExpiryTime, String username, String password) {
						String data = username + ":" + tokenExpiryTime + ":" + password + ":" + this.getKey();

						MessageDigest digest;
						try {
							digest = MessageDigest.getInstance("MD5");
						} catch (NoSuchAlgorithmException var8) {
							throw new IllegalStateException("No MD5 algorithm available!");
						}

						return new String(Hex.encode(digest.digest(data.getBytes())));
					}
				d. 明显这样安全么，如果cookie被劫持，一定是不安全的，别人拿到了这个字符串在有效期内就可以访问你的应用。这就和你的钥匙token被盗了，你家肯定不安全是一个道理。 但是不存
				在密码被破解为明文的可能性，MD5 hash是不可逆的。
			C. RememberMeAuthenticationFilter在Spring Security过滤器链中处于整体偏后的位置，所以只有当各种传统的登录方式都无法完成验证的情况下，才走RememberMeAuthenticationFilter，
			这也是符合实际需求的。
		④ 个性化配置
			A. 在实际的开发过程中，我们还可以根据需求做一些个性化的设置，如下：
				http.rememberMe()
					.rememberMeParameter("rememberMe")
					.rememberMeCookieName("remember-me-cookie")
					.tokenValiditySeconds(1 * 60)
			B. 参数介绍
				a. kenValiditySeconds用于设置token的有效期，即多长时间内可以免除重复登录，单位是秒。不修改配置情况下默认是2周。
				b. 通过rememberMeParameter设置from表单“自动登录”勾选框的参数名称。如果这里改了，from表单中checkbox的name属性要对应的更改。如果不设置默认是remember-me。
				c. rememberMeCookieName设置了保存在浏览器端的cookie的名称，如果不设置默认也是remember-me。如下图中查看浏览器的cookie。
		⑤ token数据库存储方式
			A. 上面我们讲的方式，就是最简单的实现“记住我-自动登录”功能的方式。这种方式的缺点在于：token与用户的对应关系是在内存中存储的，当我们重启应用之后所有的token都将消失，即：所
			有的用户必须重新登陆。为此，Spring Security还给我们提供了一种将token存储到数据库中的方式，重启应用也不受影响。
			B. 虽然数据库存储的token的确不再是用户名、密码MD5加密字符串了，而是一个随机序列号。但是一旦你的随机序列号cookie被劫持，效果是一样的。好比你家有把密码锁：你把钥匙丢了和你把
			密码丢了，危害性是一样的。
			C. token数据库存储方式的实现原理和验证过程
				a. 首先，我们需要键一张数据库表persistent_logins:
					CREATE TABLE `persistent_logins` (
					  `username` varchar(64) NOT NULL COMMENT '用户名',
					  `series` varchar(64) NOT NULL COMMENT '序列号',
					  `token` varchar(64) NOT NULL COMMENT 'Token随机值',
					  `last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '过期时间',
					  PRIMARY KEY (`series`)
					) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
				b. 初始化一个PersistentTokenRepository类型的Spring bean，并将系统使用的DataSource注入到该bean中。（当然前提一定是你已经在Spring Boot的application.yml中配置好DataSource
				相关的连接属性
					@Autowired
					private DataSource dataSource;
					
					@Bean
					public PersistentTokenRepository persistentTokenRepository() {
						JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();
						tokenRepository.setDataSource(dataSource);
						return tokenRepository;
					}
				c. 最后在Spring Security配置方法configure(HttpSecurity http)加上如下的个性化配置：
					protected void configure(HttpSecurity http) throws Exception {
						http.rememberMe()
							.rememberMeParameter("rememberMe")
							.rememberMeCookieName("remember-me-cookie")
							.tokenValiditySeconds(7 * 24 * 60 * 60)
							.tokenRepository(persistentTokenRepository())
							...
					}
	7. 退出登录功能的实现
		① logout最简及最佳实践
			A. 其实使用Spring Security进行logout非常简单，只需要在spring Security配置类配置项上加上这样一行代码:http.logout()。
			B. 后端代码：
				@Override
				protected void configure(HttpSecurity http) throws Exception {
					http.logout()
					...
				}	
			C. 加上logout配置之后，在你的“退出”按钮上使用/logtou作为请求登出的路径，默认的退出按钮的请求路径是/logout。
			D. 后端代码：
				<a href="/logout" >退出</a>
		② 默认的logout做了什么？
			A. 当前session失效，即：logout的核心需求，session失效就是访问权限的回收。
			B. 删除当前用户的 remember-me“记住我”功能信息
			C. clear清除当前的 SecurityContext
			D. 重定向到登录页面，loginPage配置项指定的页面
		③ 个性化配置
			A. 虽然Spring Security默认使用了/logout作为退出处理请求路径，登录页面作为退出之后的跳转页面。这符合绝大多数的应用的开发逻辑，但有的时候我们需要一些个性化设置，如下：
				@Override
				protected void configure(HttpSecurity http) throws Exception {
					http.logout() // 默认退出url为/logout
						.logoutUrl("/logout")
						.logoutSuccessUrl("/login.html")
						.deleteCookies("JSESSIONID")
				}	
			B. 以上代码实现的功能：
				a. 通过指定logoutUrl配置改变退出请求的默认路径，当然html退出按钮的请求url也要修改
				b. 通过指定logoutSuccessUrl配置，来显式指定退出之后的跳转页面
				c. 还可以使用deleteCookies删除指定的cookie，参数为cookie的名称
		④ LogoutSuccessHandler
			A. 如果上面的个性化配置，仍然满足不了您的应用需求。可能您的应用需要在logout的时候，做一些特殊动作，比如登录时长计算，清理业务相关的数据等等。你可以通过实现
			LogoutSuccessHandler 接口来实现你的业务逻辑。
			B. MyLogoutSuccessHandler
				@Component
				public class MyLogoutSuccessHandler implements LogoutSuccessHandler {

					@Override
					public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response,
												Authentication authentication) throws IOException, ServletException {
						response.sendRedirect("/login.html");
					}
				}
			C. 然后进行配置使其生效，核心代码就是一行logoutSuccessHandler。注意logoutSuccessUrl不要与logoutSuccessHandler一起使用，否则logoutSuccessHandler将失效。
				@Override
				protected void configure(HttpSecurity http) throws Exception {
					http.logout() // 默认退出url为/logout
							.logoutUrl("/logout") // 指定退出的url，前端退出按钮需保持一致
							//.logoutSuccessUrl("/login.html") // 退出后返回的页面
							.logoutSuccessHandler(myLogoutSuccessHandler)
							.deleteCookies("JSESSIONID") // 删除cookie
							...
				}
	8. 多种图片验证码实现方案
		① 验证码的组成部分：
			A. 验证码实际上和谜语有点像，分为谜面和谜底。谜面通常是图片，谜底通常为文字。谜面用于展现，谜底用于校验。
				a. 对于字符型验证码。比如：谜面是显示字符串"ABGH"的图片，谜底是字符串"ABGH"
				b. 对于计算类验证码。比如：谜面是“1+1=”的图片，谜底是“2”
				c. 对于拖拽类的验证码。比如：谜面是一个拖拽式的拼图，谜底是拼图位置的坐标
			B. 总之，不管什么形式的谜面，最后用户的输入内容要和谜底进行验证。
		② session存储验证码
			A. 这是一种最典型的验证码实现方式，实现方式也比较简单。
				a. 应用服务端随机的生成验证码文字
				b. 将验证码文字存到session里面
				c. 根据验证码文字生成验证码图片，响应给客户端
				d. 检查用户输入的内容与验证码谜底是否一致
			B. 这种实现方式的优点就是比较简单，缺点就是：因为一套应用部署一个session，当我们把应用部署多套如：A、B、C，他们各自有一个session并且不共享。导致的结果就是验证码
			和图片由A生成，但是验证请求发送到了B，这样就不可能验证通过。
			C. session存储验证码，不适用于集群应用
		③ 共享session存储验证码
			A. 在第二小节讲到的问题，实际上不是验证码的问题，而是如何保证session唯一性或共享性的问题。主要的解决方案有两种：
				a.     通常我们实现负载均衡应用的前端都是使用nginx或者haproxy，二者都可以配置负载均衡策略。其中一种策略就是：你的客户端ip上一次请求的是A应用，你的下一次请求
				还转发给A应用。这样就保证了session的唯一性。但是这种方式有可能会导致A、B、C应用其中一个或两个分配了大量的请求，而另外一个处理很少的请求，导致负载并不均衡。
				b. 另外一种非常通用的方式就是将分布式应用的session统一管理，也就是说原来A、B、C各自的session都存在自己的内存中，现在更改为统一存储到一个地方，大家一起用。这样
				就实现了session的唯一和共享，是实现分布式应用session管理的有效途径。在Spring框架内，最成熟的解决方案就是spring session + redis 。可自行参考实现。
			B. 共享session存储验证码，适用于集群应用
		④ 基于对称算法的验证码
			A. 可能出于主机资源的考虑，可能出于系统架构的考量，有些应用是无状态的。
				a. 什么是无状态应用：就是不保存用户状态的应用。
				b. 什么是用户状态：比如当你登陆之后，在session中保存的用户的名称、组织等等信息。
				c. 所以可以简单的理解，无状态应用就是无session应用。当然这并不完全准确。
			B. 那么对于这些无状态的应用，我们就无法使用session，或者换个说法从团队开发规范上就不让使用session。那么我们的验证码该怎么做？
				a. 同样，首先要生成随机的验证码（谜底），但是不做任何存储操作
				b. 将谜底（验证码文字）加上时间串、应用信息等组成一个字符串进行加密。必须是对称加密，也就是说可以解密的加密算法。
				c. 生成验证码图片，并与加密后的密文，通过cookies一并返回给客户端。
				d. 当用户输入验证码提交登录之后，服务端解密cookies中的密文（主要是验证码文字），与用户的输入进行验证比对。
			C. 这种做法的缺陷是显而易见的：实际上就是将验证码文字在客户端服务端之间走了一遍。虽然是加密后的验证码文字，但是有加密就必须有解密，否则无法验证。所以更为稳妥的做法
			是为每一个用户生成密钥，并将密钥保存到数据库里面，在对应的阶段内调用密钥进行加密或者解密。
			D. 从密码学的角度讲，没有一种对称的加密算法是绝对安全的。所以更重要的是保护好你的密钥。正如没有一把锁头是绝对安全的，更重要的是保护好你的钥匙。
	9. 基于session的图片验证码实现
		① 图片验证码实现是基于google开源的验证码实现类库kaptcha，作为验证码工具实现验证码功能开发。验证码工具类通常要具有以下三种功能方法：
			A. 生成验证码文字或其他用于校验的数据形式（即谜底）
			B. 生成验证码前端显示图片或拼图等（即谜面）
			C. 用于校验用户输入与谜底的校验方法（如果是纯文字，就自己比对以下就可以。如果是基于物理图形拖拽、旋转等方式，需要专用的校验方法）
		② 这种验证码类库有很多，但是都是基于以上逻辑，我们只需要把kaptcha当做工具类，也可以使用其他的验证码工具类，基于session的验证码实现原理是一致的。
		③ 验证码生成之配置使用kaptcha
			A. 通过maven坐标引入kaptcha
				<dependency>
				   <groupId>com.github.penggle</groupId>
				   <artifactId>kaptcha</artifactId>
				   <version>2.3.2</version>
				   <exclusions>
					  <exclusion>
						 <artifactId>javax.servlet-api</artifactId>
						 <groupId>javax.servlet</groupId>
					  </exclusion>
				   </exclusions>
				</dependency>
			B. 假设我们的配置文件是application.yml，新建一个单独的文件叫做kaptcha.properties。因为kaptcha的配置不符合yaml的规范格式,所以只能采用properties。需配合注解
			PropertySourc使用。
			C. 假设我们的配置文件是application.properties，将下面这段代码加入进去即可，不用单独建立文件。
			D. 下面的验证码配置，从英文单词的角度很容易理解，当我们需要调整验证码的边框、颜色、大小、字体等属性的时候，可以修改这些配置。
				kaptcha.border=no
				kaptcha.border.color=105,179,90
				kaptcha.image.width=100
				kaptcha.image.height=45
				kaptcha.textproducer.font.color=blue
				kaptcha.textproducer.font.size=35
				kaptcha.textproducer.char.length=4
				kaptcha.textproducer.font.names=宋体,楷体,微软雅黑
			E. 下面的代码加载了配置文件中的kaptcha配置（参考Spring Boot的配置加载），如果是独立的properties文件，需加上PropertySource注解说明。
			F. 另外，我们通过加载完成的配置，初始化captchaProducer的Spring Bean，用于生成验证码。
				@Configuration
				@PropertySource(value = { "classpath:kaptcha.properties" })
				public class CaptchaConfig {

					@Value("${kaptcha.border}")
					private String border;
					@Value("${kaptcha.border.color}")
					private String borderColor;
					@Value("${kaptcha.textproducer.font.color}")
					private String fontColor;
					@Value("${kaptcha.image.width}")
					private String imageWidth;
					@Value("${kaptcha.image.height}")
					private String imageHeight;
					@Value("${kaptcha.session.key}")
					private String sessionKey;
					@Value("${kaptcha.textproducer.char.length}")
					private String charLength;
					@Value("${kaptcha.textproducer.font.names}")
					private String fontNames;
					@Value("${kaptcha.textproducer.font.size}")
					private String fontSize;

					@Bean("captchaProducer")
					public DefaultKaptcha getKaptchaBean() {
						DefaultKaptcha defaultKaptcha = new DefaultKaptcha();

						Properties properties = new Properties();
						properties.setProperty("kaptcha.border", border);
						properties.setProperty("kaptcha.border.color", borderColor);
						properties.setProperty("kaptcha.textproducer.font.color", fontColor);
						properties.setProperty("kaptcha.image.width", imageWidth);
						properties.setProperty("kaptcha.image.height", imageHeight);
						properties.setProperty("kaptcha.session.key", sessionKey);
						properties.setProperty("kaptcha.textproducer.char.length", charLength);
						properties.setProperty("kaptcha.textproducer.font.names", fontNames);
						properties.setProperty("kaptcha.textproducer.font.size",fontSize);

						defaultKaptcha.setConfig(new Config(properties));
						return defaultKaptcha;
					}
				}
			G. 至此，Kaptcha开源验证码软件的配置我们就完成了，如果发现IDEA环境下配置文件读取中文乱码，修改如下配置。
		④ 验证码生成之session保存
			A. 生成验证码的Controller。同时需要开放路径"/kaptcha"的访问权限，配置成不需登录也无需任何权限即可访问的路径。
				
				a. 通过captchaProducer.createText()生成验证码文字，并和失效时间一起保存到CaptchaImageVO中。
				b. 将CaptchaImageVO验证码信息类对象，保存到session中。（这个类的代码后文有介绍）
				c. 通过captchaProducer.createImage(capText)生成验证码图片，并通过ServletOutputStream返回给前端
				d. 我们要把CaptchaImageVO保存到session里面。所以该类中不要加图片，只保存验证码文字和失效时间，用于后续验证即可。把验证码图片保存起来既没有用处，又浪费内存。
			B. 代码：
				@RestController
				public class CaptchaController {

					@Autowired
					private DefaultKaptcha captchaProducer;

					@GetMapping("/kaptcha")
					public void kaptcha(HttpSession session, HttpServletResponse response) throws IOException {

						// 设置浏览器不要缓存等
						response.setDateHeader("Expires", 0);
						response.setHeader("Cache-Control", "no-store, no-cache, must-revalidate");
						response.addHeader("Cache-Control", "post-check=0, pre-check=0");
						response.setHeader("Pragma", "no-cache");
						response.setContentType("image/jpeg");

						// 将验证码保存到session中，并设置过期时间为两分钟
						String captchaText = captchaProducer.createText();
						session.setAttribute("captchaText", new CaptchaImageVO(captchaText, 2 * 60));

						// 将验证码图片返回到前端
						try(ServletOutputStream out = response.getOutputStream();) {
							BufferedImage image = captchaProducer.createImage(captchaText);
							ImageIO.write(image, "jpg", out);
							out.flush();
						} //使用try-with-resources不用手动关闭流
					}
				}
				
				public class CaptchaImageVO {

					private String code;

					private LocalDateTime expireTime;

					public CaptchaImageVO(String code,  int expireAfterSeconds) {
						this.code = code;
						this.expireTime = LocalDateTime.now().plusSeconds(expireAfterSeconds);
					}

					public boolean isExpire() {
						return LocalDateTime.now().isAfter(this.expireTime);
					}

					public String getCode() {
						return code;
					}
				}
				
				@Override
				protected void configure(HttpSecurity http) throws Exception {
					.http
					...
					.authorizeRequests()
					.antMatchers("/login.html", "/", "/login", "/kaptcha").permitAll() // 不需要通过登录验证就可以被访问的资源路径
					...
				}
		⑤ 验证码用户访问
			A. 实现的效果是，页面初始化即加载验证码。以后每一次点击，都会更新验证码。
			B. 注意：一定设置width和height，否则图片无法显示。
			C. 需要为“/kaptcha”配置permitAll公开访问权限，否则无法访问到
			D. 代码
				<div class="form-group">
					<label for="password">验证码</label>
					<input type="text" class="form-control" name="captcha" id="captcha" placeholder="请输入验证码">
					<img th:src="@{/kaptcha}" id="kaptcha" width="100px" height="38px">
				</div>
			
				$(function () {
					$('#kaptcha').click(function () {
						var timeMilli = new Date().getTime();
						var src = $(this).attr('src');
						$(this).attr('src', src + "?" + timeMilli);
					})
				});






















