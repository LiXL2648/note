一、SpringMVC的概述
	1. Spring 为展现层提供的基于 MVC 设计理念的优秀的Web 框架，是目前最主流的 MVC 框架之一
	2. Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架
	3. Spring MVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，而无须实现任何接口。
	4. 支持 REST 风格的 URL 请求
	5 采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性
二、HelloWorld
	1. 加入 jar  包
		commons-lang3-3.8.1.jar
		commons-logging-1.2.jar
		spring-aop-4.3.22.RELEASE.jar
		spring-beans-4.3.22.RELEASE.jar
		spring-context-4.3.22.RELEASE.jar
		spring-core-4.3.22.RELEASE.jar
		spring-expression-4.3.22.RELEASE.jar
		spring-web-4.3.22.RELEASE.jar
		spring-webmvc-4.3.22.RELEASE.jar
	2. 在 web.xml 中配置 DispatcherServlet
		配置 DispatcherServlet ：DispatcherServlet 默认加载 /WEB-INF/<servletName-servlet>.xml 的 Spring 配置文件, 启动 WEB 层
		的 Spring 容器。可以通过 contextConfigLocation 初始化参数自定义配置文件的位置和名称
		<!-- 配置DispatcherServlet -->
		<servlet>
			<servlet-name>springDispatcherServlet</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<!-- 配置 DispatcherServlet 的初始化参数：配置SpringMVC配置文件的位置和名称-->
			<init-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>classpath:applicationContext-mvc.xml</param-value>
			</init-param>
			<load-on-startup>1</load-on-startup>
		</servlet>

		<servlet-mapping>
			<servlet-name>springDispatcherServlet</servlet-name>
			<url-pattern>/</url-pattern>
		</servlet-mapping>
	3. 加入 Spring MVC 的配置文件 
		① 在类路径下创建一个Spring Bean Configur file 配置文件，命名为web.xml文件中的初始化参数中配置文件的名称
		② 配置SpringMVC配置文件
			A. 配置需要自动扫描的包
			<context:component-scan base-package="com.li.springmvc"></context:component-scan>
			B. 配置视图解析器， 视图名称解析器：将视图逻辑名解析为: /WEB-INF/pages/<viewName>.jsp
			<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
				<property name="prefix" value="/WEB-INF/views/"></property>
				<property name="suffix" value=".jsp"></property>
			</bean>
	4. 编写处理请求的处理器，并标识为处理器
		@Controller
		@RequestMapping("/hello")//请求地址的根路径
		public class HelloWorld {

			private final String SUCCESS = "success";
			
			@RequestMapping("/world")//请求地址
			public String hello() {
				System.out.println("hello world");
				return SUCCESS;//返回视图
			}
		}
	5. 编写视图
三、使用 @RequestMapping 映射请求
	1. 概述
		① Spring MVC 使用 @RequestMapping 注解为控制器指定可以处理哪些 URL 请求
		② 在控制器的类定义及方法定义处都可标注@RequestMapping
			A. 类定义处：提供初步的请求映射信息。相对于 WEB 应用的根目录
			B. 方法处：提供进一步的细分映射信息。相对于类定义处的 URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于WEB 应用的根目录
		③ DispatcherServlet 截获请求后，就通过控制器上@RequestMapping 提供的映射信息确定请求所对应的处理方法。
	2. 使用 @RequestMapping 映射请求示例
		① 类定义处标记的@RequestMapping 限定了处理器类可以处理所有 URI 为 /hello 的请求，它相对于 WEB 容器部署的根路径
		② 处理器类可以定义多个处理方法，处理来自/hello 下的请求
		@Controller
		@RequestMapping("/hello")//①
		public class HelloWorld {

			private final String SUCCESS = "success";
			
			@RequestMapping("/world")//②
			public String hello() {
				System.out.println("hello world");
				return SUCCESS;//返回视图
			}
		}
	3. 映射请求参数、请求方法或请求头
		① @RequestMapping 除了可以使用请求 URL 映射请求外，还可以使用请求方法、请求参数及请求头映射请求
		② @RequestMapping 的 value、method、params 及 heads 分别表示请求 URL、请求方法、请求参数及请求头的映射条件，他们之间是与的关系，联合使用多个条件可让请求映射更加精确化。
		③ params 和 headers支持简单的表达式：
			A. param1: 表示请求必须包含名为 param1 的请求参数
			B. !param1: 表示请求不能包含名为 param1 的请求参数
			C. param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1
			D. {“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2的两个请求参数，且 param1 参数的值必须为 value1
	4. 使用 @RequestMapping 映射请求
		① Ant 风格资源地址支持 3 种匹配符：
			A. ?：匹配文件名中的一个字符 
			B. *：匹配文件名中的任意字符 
			C. **：** 匹配多层路径 
		② @RequestMapping 还支持 Ant 风格的 URL
			A. /user/*/createUser: 匹配 /user/aaa/createUser、/user/bbb/createUser 等 URL
			B. /user/**/createUser: 匹配 /user/createUser、/user/aaa/bbb/createUser 等 URL
			C. /user/createUser??: 匹配 /user/createUseraa、/user/createUserbb 等 URL
	5. @PathVariable 映射 URL 绑定的占位符
		① 带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义
		② 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable("xxx") 绑定到操作方法的入参中。
		③ 举例：
		@RequestMapping("testPathVariable/{id}")
		public String testPathVariable(@PathVariable("id")Integer id) {
			System.out.println("testPathVariable id: " + id);
			return SUCCESS;
		}
		<a href="springmvc/testPathVariable/2648">test pathVariable</a>
	6. REST
		① REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，
		所以正得到越来越多网站的采用
		② 资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。
		可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的识别符。
		③ 表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格
		式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。
		④ 状态转化（State Transfer）：每• 发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器
		端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“
		⑤ 状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化”。具体说，就是 HTTP 协议里面，四个表示操作方式的动
		词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。
		⑥ 示例：
			A. /order/1 HTTP GET ：得到 id = 1 的 order 
			B. /order/1 HTTP DELETE：删除 id = 1的 order 
			C. /order/1 HTTP PUT：更新id = 1的 order 
			D. /order HTTP POST：新增 order 
		⑦ HiddenHttpMethodFilter：浏览器 form 表单只支持 GET 与 POST 请求，而DELETE、PUT 等 method 并不支
		持，Spring3.0 添加了一个过滤器，可以将这些请求转换为标准的 http 方法，使得支持 GET、POST、PUT 与DELETE 请求。
		⑧ 如何发送PUT请求和DELETE请求呢？
			A. 需要配置HiddenHttpMethodFilter拦截器
			B. 使用FORM表单发送POST请求
			C. 在FORM表单中携带一个name为_method，value为DELETE或者PUT的隐藏域
			D. 举例：	
				<!-- 配置org.springframework.web.filter.HiddenHttpMethodFilter，作用：将POST转化为DELETE或者PUT -->
				<filter>
					<filter-name>HiddenHttpMethodFilter</filter-name>
					<filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
				</filter>
				<filter-mapping>
					<filter-name>HiddenHttpMethodFilter</filter-name>
					<url-pattern>/*</url-pattern>
				</filter-mapping>
				<form action="springmvc/testRest/1" method="post">
					<input type="hidden" name="_method" value="PUT"/>
					<input type="submit" value="testRest PUT"/>
				</form>
			  
				<form action="springmvc/testRest/1" method="post">
					<input type="hidden" name="_method" value="DELETE"/>
					<input type="submit" value="testRest DELETE"/>
				</form>
四、映射请求参数 & 请求参数
	1. 请求处理方法签名
		① Spring MVC 通过分析处理方法的签名，将 HTTP 请求信 息绑定到处理方法的相应人参中。
		② Spring MVC 对控制器处理方法签名的限制是很宽松的， 几乎可以按喜欢的任何方式对方法进行签名。
		③ 必要时可以对方法及方法入参标注相应的注解（@PathVariable、@RequestParam、@RequestHeader 等）、
		Spring MVC 框架会将 HTTP 请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理。
	2. 使用 @RequestParam 绑定请求参数值
		① 在处理方法入参处使用 @RequestParam 可以把请求参数传递给请求方法
			A. value：参数名 
			B. required：是否必须。默认为 true, 表示请求参数中必须包含对应的参数，若不存在，将抛出异常
			C. defaultValue：默认值，如果浏览器发送的请求中没有@RequestParam 绑定请求参数，则指定为默认值
		② 举例
		@RequestMapping(value="/testRequestParam", method=RequestMethod.GET)
		public String testRequestParam(@RequestParam(value="username", required=false)
			String username, @RequestParam("password") String password) {
			System.out.println("testRequestParam, useranme: " + username + ", password: " + password);
			return SUCCESS;
		}
	3. 使用 @RequestHeader 绑定请求报头的属性值
		① 请求头包含了若干个属性，服务器可据此获知客户端的信息，通过 @RequestHeader 即可将请求头中的属性值绑定到处理方法的入参中
		② 使用方法同@RequestParam
		③ 举例
		@RequestMapping("/testRequestHeader")
		public String testRequestHeader(@RequestHeader("Accept-Language") String acceptLanguage) {
			System.out.println("testRequestHeader, acceptLanguage: " + acceptLanguage);
			return SUCCESS;
		}
	4. 使用 @CookieValue 绑定请求中的 Cookie 值
		① @CookieValue 可让处理方法入参绑定某个 Cookie 值
		② 举例：
		@RequestMapping("/testCookieValue")
		public String testCookieValue(@CookieValue("JSESSIONID") String jSessionId) {
			System.out.println("testCookieValue, JSESSIONID=" + jSessionId);
			return SUCCESS;
		}
	5. 使用 POJO 对象绑定请求参数值
		① Spring MVC 会按• 请求参数名和 POJO 属性名进行自动匹配，自动为该对象填充属性值。支持级联属性
		② 举例：
		<form action="springmvc/testPOJO" method="post">
			empId: <input type="text" name="empId"/><br>
			empName: <input type="text" name="empName"/><br>
			email: <input type="text" name="email"/><br>
			salary: <input type="text" name="salary"/><br>
			
			depId: <input type="text" name="department.depId"/><br>
			depName: <input type="text" name="department.depName"/><br>
			city: <input type="text" name="department.city"/><br>
			
			<input type="submit" value="test POJO"/>
		</form>
		@RequestMapping(value = "/testPOJO", method=RequestMethod.POST)
		public String testPOJO(Employees employee) {
			System.out.println(ReflectionToStringBuilder.toString(employee, ToStringStyle.MULTI_LINE_STYLE));
			System.out.println(ReflectionToStringBuilder.toString(employee.getDepartment(), ToStringStyle.MULTI_LINE_STYLE));
			return SUCCESS;
		}
	6. 使用 Servlet API 作为入参
		① MVC 的 Handler 方法可以接受 ServletAPI 类型的参数有
			A. HttpServletRequest 
			B. HttpServletResponse 
			C. HttpSession 
			D. java.security.Principal 
			E. Locale 
			F. InputStream 
			G. OutputStream 
			H. Reader 
			I. Writer
		② 举例：
			@RequestMapping("/testServletAPI")
			public String testServletAPI(HttpServletRequest request, HttpServletResponse response) {
				System.out.println(request);
				System.out.println(response);
				return SUCCESS;
五、处理模型数据
	1. Spring MVC 提供了以下几种途径输出模型数据：
		① ModelAndView: 处理方法返回值类型为 ModelAndView 时, 方法体即可通过该对象添加模型数据
		② Map 及 Model: 入参为org.springframework.ui.Model、org.springframework.ui.ModelMap
		或 java.uti.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中。
		③ @SessionAttributes: 将模型中的某个属性暂存到 HttpSession 中，以便多个请求之间可以共享这个属性
		④ @ModelAttribute: 方法入参标注该注解后, 入参的对象就会放到数据模型中
	2. ModelAndView
		① 控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息。
		② 添加模型数据:
			MoelAndView addObject(String attributeName, Object attributeValue)
			ModelAndView addAllObject(Map<String, ?> modelMap– )
		③ 设置视图:
			void setView(View view)
			void setViewName(String viewName)
		④ 示例：
			@RequestMapping("/testModelAndView")
			public ModelAndView testModelAndView() {
				ModelAndView mv = new ModelAndView(SUCCESS);
				mv.addObject("time", new Date());
				Map<String, Employees> modelMap = new HashMap<String, Employees>();
				modelMap.put("employee", new Employees("LiXL", "LiXL@qq.com", 20000.0));
				mv.addAllObjects(modelMap);
				return mv;
			}
	3. Map 及 Model
		① Spring MVC 在内部使用了一个org.springframework.ui.Model 接口存储模型数据
		② 具体步骤
			A. Spring MVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。
			B. 如果方法的入参为 Map 或 Model类型，Spring MVC 会将隐含模型的引用传
			递给这些入参。在方法体内，开发者可以通过这个入参对象访问到模型中的所有数
			据，也可以向模型中添加新的属性数据
		③ 举例：
			@RequestMapping("/testMap")
			public String testMap(Map<String, Object> map) {
				map.put("department", new Departments("IT", "GuangZhou"));
				return SUCCESS;
			}
	4. @SessionAttributes
		① 若希望在多个请求之间共用某个模型属性数据，则可以在控制器类上标注一个 @SessionAttributes, Spring MVC 将在模型中对应的属性暂存到 HttpSession 中。
		② @SessionAttributes 除了可以通过属性名（使用的是value属性值）指定需要放到会话中的属性外，
		还可以通过模型属性的对象类型（使用的是type属性值）指定哪些模型属性需要放到会话中，
		注意：该注解只能放在类的上边，但是不能放在方法的上边。
			A. @SessionAttributes(types=User.class) 会将隐含模型中所有类型为 User.class 的属性添加到会话中。
			B. @SessionAttributes(value={“user1”, “user2”})
			C. @SessionAttributes(types={User.class, Dept.class})
			D. @SessionAttributes(value={“user1”, “user2”}, types={Dept.class})
		③ 举例：
		@SessionAttributes(value={"employee", "args"}, types={Departments.class})
		@RequestMapping("/testSionAttributes")
		public String testSessionAttributes(Map<String, Object> map) {
			map.put("employee", new Employees("YuCX", "YuCX@qq.com", 5000.0));
			map.put("department", new Departments("IT", "GuangZhou"));
			map.put("args", Arrays.asList("LiXL", "YUCX", "LiLX"));
			return SUCCESS;
		}
	5. @ModelAttribute
		① 在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的方法。
		② 在方法的入参前使用 @ModelAttribute 注解：
			A. 可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数绑定到对象中，再传入入参
			B. 将方法入参对象添加到模型中
		③ @ModelAttribute的运行流程
			A. 执行@ModelAttribute注解修饰的方法：从数据库中获取对象，把对象放入大Map中
			B. SpringMVC从map中取出对象，并把表单中的请求参数赋给map中对象对应的属性
			C. Spring在将该对象传入目标方法中的采数
			D. 注意：在@ModelAttribute修饰的方法中，放入到map中的键需要和目标方法入参类型的第一个字母小写的字符串一致
		④ 源码分析流程
			A. 调用@ModelAttribute注解修饰的方法，实际上把@ModelAttribute方法中Map中的数据放在了implicitModel中，
			B. 解析请求处理器的目标参数，实际上该目标参数来自于WebDataBinder对象的target属性
				a. 创建WebDataBinder对象
					(1) 确定objectName属性：若传入的attrName属性为"", 则objectName为类名的第一个字母小写
					(2) 注意：attrName，若目标方法的POJO属性使用了@ModelAttribute来修饰，则attrName值为@ModelAttributevalue属性值
					(3) 确定target属性：
						(a) 在implicitModel中查找attrName对应的属性值，若存在，OK
						(b) 若不存在：则验证当亲Handler是否使用了@SessionAttributes进行修饰，若使用了，则尝试从session中获取attrName所对应的属性值，
						若session中没有对应的属性值，则会抛出异常
						(c) 若Handler没有使用@SessionAttributes进行修饰，或@SessionAttributes中没有使用value值指定的key和attrName相匹配，则通过反射创建POJO对象
				b. SpringMVC把表单的请求参数赋给WebDataBinder的target对应的属性
				c. SpringMVC会把WebDataBinder的attrName和target给到implicitModel，进而传到request域对象中。
				d. 把WebDataBinderBinder的target作为参数传递给目标方法的入参
		⑤ SpringMVC确定目标方法POJO类型入参的过程
			A. 确定一个key：
				a. 若目标方法中的POJO类型参数没有使用@ModelAttribute作为修饰，则key为POJO类名第一个字母小写
				b. 若使用了@ModelAttribute作为修饰，则key为@ModelAttribute注解的value属性值。
			B. 在implicitModel中查找key对应的对象，若存在，则作为入参传入
				a. 若在@ModelAttribute标记的方法中的Model保存过，且key和1确定的key一致，则会获取
			C. 若implicitModel中不存在key对应的对象，则检查当前的Handler是否使用了@SessionAttributes注解修饰，若使用了该注解，且@SessionAttributes
			注解的value属性值包含了key，则会从HTTPSession中获取key所对应的value值，若存在存在value值则直接传入目标方法的入参中，若不存在则将抛出异常
			D. 若Handler没有标识@SessionAttributes注解或@SessionAttributes注解的value值中不包含key，则会通过反射来创建POJO类型的参数，传入目标方法的参数
			E. SpringMVC会把key和POJO类型对象保存到implicitModel中，进而会保存到request中
		⑥ @ModelAttribute注解修饰POJO类型的入参
			A. 有@ModelAttribute标记的方法，会在每个目标方法执行之前被SpringMVC调用
			B. @ModelAttribute注解也可以修饰目标方法POJO类型的入参，其value属性值有以下作用
				a. SpringMVC会使用value属性值在implicitModel中查找对应的对象，若存在则会直接传入到目标方法的入参中。
				b. SpringMVC会以@ModelAttribute的value为key，POJO类型的对象为value，存入到request中。
六、视图和视图解析器
	1. 视图和视图解析器
		① 请求处理方法执行完成后，最终返回一个 ModelAndView对象。对于那些返回 String，View 或 ModeMap 等类型的
		处理方法，Spring MVC 也会在内部将它们装配成一个ModelAndView 对象，它包含了逻辑名和模型对象的视图
		② Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象（View），最终的视图可以是 JSP ，也可能是
		Excel、JFreeChart 等各种表现形式的视图
		③ 对于最终究竟采取何种视图对象对模型数据进行渲染，处理器并不关心，处理器工作重点聚焦在生产模型数据的工
		作上，从而实现 MVC 的充分解耦
	2. 视图
		① 视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户。
		② 为了实现视图模型和具体实现技术的解耦，Spring 在org.springframework.web.servlet 包中定义了一个高度抽象的 View接口：
		③ 视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题
	3. 常用的视图实现类
		① InternalResourceView：将JSP或其他资源封装成一个视图，是InternalResourceViewResolver默认使用的视图实现类
		② JstlView: 如果JSP文件中使用了JSTL国际化标签的功能，则需要使用该视图类
		③ AbstractExcelView：Excel文档视图抽象类，该视图类基于POI构造Excel文档
			A. 若希望使用Excel 展示数据列表，仅需要扩展SpringMVC 提供的 AbstractExcelView 或
			AbstractJExcel View 即可。实现 buildExcelDocument() 方法，在方法中使用模型数据对象构建 Excel 文档就可以了。
			B. AbstractExcelView 基于 POI API，而AbstractJExcelView 是基于 JExcelAPI 的。
			C. 视图对象需要配置 IOC 容器中的一个 Bean，使用BeanNameViewResolver 作为视图解析器即可
			D. 若希望直接在浏览器中直接下载 Excel 文档，则可以设置响应头 Content-Disposition 的值为attachment;filename=xxx.xls
		④ AbstractPdfView: PDF文档视图抽象类，该视图类基于iText构造PDF文档
	4. 视图解析器
		① SpringMVC为逻辑视图名的解析提供了不同的策略，可以在Spring WEB上下文中配置一种一种或多种解析策略，并指定他们之间的先后顺序。
		每一种映射策略对应一个具体的视图解析器实现类。
		② 视图解析器的作用比较单一：将逻辑视图解析为一个具体的视图对象
		③ 所有的视图解析器都必须事先ViewResoler接口
		④ 常用的视图解析器实现类
			A. BeanNameViewResolver：将逻辑视图解析为一个Bean，Bean的id等于逻辑视图名
				<!-- 配置自定义视图解析器，可以指定优先级 -->
				<bean 
					class="org.springframework.web.servlet.view.BeanNameViewResolver">
					<property name="order" value="100"></property>
				</bean>
				// 将逻辑视图转化为该Bean，逻辑视图名即为该Bean的id
				@Component
				public class TestBeanView implements View {
					@Override
					public String getContentType() {
						return "text/html";
					}
					@Override
					public void render(Map<String, ?> arg0, HttpServletRequest request,
							HttpServletResponse response) throws Exception {
						response.getWriter().print("test beanView, time + " + new Date());
					}
				}
			B. InternalResourceViewResolver: 将视图名解析为一个URL文件，一般使用该解析器将视图名映射为一个保存在WEB-INF目录下的程序文件（如JSP）
				a. JSP 是最常见的视图技术，可以使用InternalResourceViewResolver 作为视图解析器
				<!-- 配置视图解析器 -->
				<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
					<property name="prefix" value="/WEB-INF/views/"></property>
					<property name="suffix" value=".jsp"></property>
				</bean>
				b. 项目中使用了 JSTL，则 SpringMVC 会自动把视图由InternalResourceView 转为 JstlView
				c. 若使用 JSTL 的 fmt 标签则需要在 SpringMVC 的配置文件中配置国际化资源文件
				<!-- 配置国际化资源文件 -->
				<bean id="messageSource"
				class="org.springframework.context.support.ResourceBundleMessageSource">
					<property name="basename" value="i18n"></property>
				</bean>
				d. 若希望直接响应通过 SpringMVC 渲染的页面，可以使用 mvc:view-controller 标签实现
				<!-- 配置直接转发的页面 -->
				<!-- 可以直接相应地转发的页面，而无须在经过Handler的方法 ，但是该配置会导致其他请求无法通过-->
				<mvc:view-controller path="springmvc/testJstlView" view-name="success"/>
				<!-- 在实际开发中通常都需要配置mvc:annotation-driven -->
				<mvc:annotation-driven></mvc:annotation-driven>
			
		⑤ 程序员可以选择一种视图解析器或混用多种视图解析器
		⑥ 每个视图解析器都实现了 Ordered 接口并开放出一个 order 属性，可以通过 order 属性指定解析器的优先顺序，order 越小优先级越高。
		⑦ SpringMVC 会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出 ServletException 异常
	5. 关于重定向
		① 如果返回的字符串中带 forward: 或 redirect: 前缀时，SpringMVC 会对他们进行特殊处理：将 forward: 和
		② redirect: 当成指示符，其后的字符串作为 URL 来处理
			A. redirect:success.jsp：会完成一个到 success.jsp 的重定向的操作
			B. forward:success.jsp：会完成一个到 success.jsp 的转发操作
			C. 举例：
				@RequestMapping("/testRedirect1")
				public String testRedirect1() {
					System.out.println("testRedirect1");
					// 重定向到某个URL请求，可通过该方法获取位于/WEB-INF的视图
					return "redirect:/springmvc/testBeanView";
					}
七、RESTful SpringMVC CRUD
	1. 显示所有员工信息
		① URI：emps
		② 请求方式：GET
		② 显示效果：转发到list页面
	2. 添加所有员工信息
		① 显示添加页面
			A. URI：emp
			B. 请求方式：GET
			C. 注意
				a. 由于添加页面中需要获取所有部门信息，因此请求首先需要经过controller
				b. 使用SpringMVC的表单标签，可以更方便的进行表单的回显。
					(1) 使用SpringMVC的表单标签需要先导入SpringMVC表单标签的taglib指令
					<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
					(2) 创建<form:radiobuttons>单选按钮组标签时， items可以是一个Map，并且不需要指定itemLabel和itemVale
					<jsp:useBean id="genders" class="java.util.HashMap" scope="request"></jsp:useBean>
					<c:set target="${genders }" property="1" value="男"></c:set>
					<c:set target="${genders }" property="0" value="女"></c:set>
					Gender: <form:radiobuttons path="gender" items="${genders }"/>
					(3) 由于SpringMVC需要对表单进行回显，并且SpringMVC的form标签默认ModelAttribute属性为command，即会在
					request中查找是否有command对象，如果没有则会抛出异常，解决方法是：在模型对象中加入标签中标签属性对应的POJO，
					并且指定SpringMVCForm表单form的ModelAttribute属性模型中的对象所对应的key
					 <form:form action="${pageContext.request.contextPath }/emps/addNewEmployee" method="POST" modelAttribute="employee">
					map.put("employee", new Employees());
		② 添加员工信息： 
			A. URI：emp 
			B. 请求方式：POST 
			C. 显示效果：完成添加，重定向到 list 页
	3. 删除操作
			A. URL：emp/{id}
			B. 请求方式：DELETE
			C.删除后效果：重定向到list页面，对应记录从数据表中删除
			D. 注意：
				a. 超链接发送的是GET请求，而REST风格的UEL删除则是需要接收DELETE请求，但是org.springframework.web.filter.HiddenHttpMethodFilter
				拦截器只支持将POST请求转化为DELETE或者PUT请求，因此需要将GET请求转换POST请求再转换为DELETE请求
					（1）需要使用js将超链接发送的URL请求通过传给FORM标签的action
					（2）在FORM表单中需要添加一个隐藏域用于转换请求方式
					（3）$(function() {
						$('.delete').click(function() {
							var href = $(this).attr("href");
								$('form').attr("action", href).submit();
								return false;
							});
						});	
						<form action="" method="post">
							<input type="hidden" name="_method" value="DELETE">
						</form>
				b. 在页面中引入jQuery等文件时，默认也是发送一个请求，此时会被SpringMVC的org.springframework.web.servlet.DispatcherServlet
				拦截，并提示当前请求没有被映射过，并会出现404页面找不到的异常。因此需要对静态资源进行处理
					(1) 在SpringMVC配置文件中配置静态资源处理器<mvc:default-servlet-handler/>，此时SpringMVC会判断当前请求是否是被映射过，
					如果没有被映射过，则会被视为静态资源处理，并寻找该目标资源，如果被映射过，则是交给DispatcherServlet处理并会返回结果。具体是交给了Tomcat中默认的Servlet，
					Tomcat中有一个处理静态资源的defaultServlet。
					(2) 配置了<mvc:default-servlet-handle/>之后，任何请求则会被视为请求静态资源，因此需要在SpringMVC配置文件中配置
					<mvc:annotation-driven></mvc:annotation-driven>
	4. 修改操作：lastName 不可修改！
		① 显示修改页面：
			A. URI：emp/{id}
			B. 请求方式：GET
			C. 显示效果：回显表单。
		② 修改员工信息：
			A. URI：emp
			B. 请求方式：PUT
			C. 显示效果：完成修改，重定向到 list 页面。
		③ 注意：
			A. 通过SpringMVC表单的属性绑定到目标方法的入参属性过程可知，对于在SpringMVC表单不显示的属性，如果在目标方法中的request中，没有与目标入参方法中POJO同名的对象时，
			对于该不可修改的属性对应POJO中的属性值则会null，这是由于如果不存在同名的POJO对象时，会通过反射创建该POJO的空白对象，并传给目标方法的入参POJO对象，最终在执行修改操作时，
			该属性会被修改为null，解决方法是，在目标方法被执行前，首先执行@ModelAttribute修饰的方法，通过传递SpringMVC表单中name为ID的值获取该目标方法的入参的POJO对象，并将该对象
			绑定在模型对象中。该方法是避免不可修该字段设置隐藏域的方式将该属性绑定到POJO对象属性中。
			B. 在SpringMVC的表单标签中设置disabled的属性值为true会导致该标签的value值绑定不盗目标方法中的POJO对象属性中。
八、SpringMVC 表单标签 和 处理静态资源
	1. 使用 Spring 的表单标签
		① 通过 SpringMVC 的表单标签可以实现将模型数据中的属性和 HTML 表单元素相绑定，以实现表单
		数据更便捷编辑和表单值的回显
		② form 标签
			A. 一般情况下，通过 GET 请求获取表单页面，而通过POST 请求提交表单页面，因此获取表单页面和提交表单
			页面的 URL 是相同的。只要满足该最佳条件的契约，<form:form> 标签就无需通过 action 属性指定表单提交的 URL
			B. 可以通过 modelAttribute 属性指定绑定的模型属性，若 没有指定该属性，则默认从 request 域对象中读取
			command 的表单 bean，如果该属性值也不存在，则会发生错误。
			C. 默认情况下，SpringMVC表单标签是要求表单进行回显的，因此需要在模型中存入与表单相同属性的模型数据，并且modelAttribute
			应与存入模型对象中的模型数据的key相同
			<form:form action="${pageContext.request.contextPath }/emps/addNewEmployee" method="POST" modelAttribute="employee">
		③ 表单标签：SpringMVC 提供了多个表单组件标签，如
				A. <form:input/>、<form:select/> 等，用以绑定表单字段的属性值，它们的共有属性如下
					a. path：表单字段，对应 html 元素的 name 属性，支持级联属性
					b htmlEscape：是否对表单值的 HTML 特殊字符进行转换，默认值 为 true
					c cssClass：表单组件对应的 CSS – 样式类名
					d cssErrorClass：表单组件的数据存在错误时，采取的 CSS样式
				B. form:input、form:password、form:hidden、form:textarea 对应 HTML 表单的 text、password、hidden、textarea标签
					a. form:input
					<form:input path="empName"/>
					b. form:hidden
					 <form:hidden path="empId"/>
				C. form:radiobutton：单选框组件标签，当表单 bean 对应的属性值和 value 值相等时，单选框被选中
				D. form:radiobuttons：单选框组标签，用于构造多个单选 框
					a. items：可以是一个 List、String[] 或 Map 
					b. itemValue：指定 radio 的 value 值。可以是集合中 bean 的一个属性值
					c. itemLabel：指定 radio 的 label值
					d. delimiter：多个单选框可以通过 delimiter 指定分隔符
					e. <jsp:useBean id="genders" class="java.util.HashMap" scope="request"></jsp:useBean>
					<c:set target="${genders }" property="1" value="男"></c:set>
					<c:set target="${genders }" property="0" value="女"></c:set>
					Gender: <form:radiobuttons path="gender" items="${genders }"/>
				E. form:checkbox：复选框组件。用于构造单个复选框
				F. form:checkboxs：用于构造多个复选框。使用方式同form:radiobuttons 标签
				G. form:select：用于构造下拉框组件。使用方式同form:radiobuttons 标签
					a. Department: <form:select items="${requestScope.departments }" path="depId" 
					itemLabel="depName" itemValue="depId"/>
				H. form:option：下拉框选项组件标签。使用方式同 form:radiobuttons 标签
				I. form:errors：显示表单组件或数据校验所对应的错误
					a. <form:errors path= “ *” /> ：显示表单所有的错误 –
					b. <form:errors path= “ user*” /> ：显示所有以 user 为前缀的属性对应 –的错误
					c. <form:errors path= “ username” /> ：显示特定表单对象属性的错误
	2. 处理静态资源
		(1) 优雅的 REST 风格的资源URL 不希望带 .html 或 .do 等后缀
		(2) 若将 DispatcherServlet 请求映射配置为 /，则 Spring MVC 将捕获WEB 容器的所有请求，包括静态资源的请求， SpringMVC 会将他
			们当成一个普通请求处理，因找不到对应处理器将导致错误。
		(3) 可以在 SpringMVC 的配置文件中配置 <mvc:default-servlet-handler/> 的方式解决静态资源的问题：
			A. <mvc:default-servlet-handler/> 将在 SpringMVC 上下文中定义一个DefaultServletHttpRequestHandler，它会对进入 DispatcherServlet
			的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由 WEB 应用服务器默认的 Servlet 处理，如果不是静态资源的请求(该请求被映射过)，
			才由DispatcherServlet 继续处理
			B. 一般 WEB 应用服务器默认的 Servlet 的名称都是 default。若所使用的 WEB 服务器的默认 Servlet 名称不是 default，则需要通过 default-
			servlet-name 属性显式指定
			C. <!-- 处理静态资源 --><mvc:default-servlet-handler/>
九、数据转换、数据格式化、数据校验
	1. 数据绑定流程
		① Spring MVC 主框架将 ServletRequest 对象及目标方法的入参实例传递给 WebDataBinderFactory 实例，以创建 DataBinder 实例对象
		② DataBinder 调用装配在 Spring MVC 上下文中的 ConversionService 组件进行数据类型转换、数据格式
		化工作。将 Servlet 中的请求信息填充到入参对象中
		③ 调用 Validator 组件对已经绑定了请求消息的入参对象行数据合法性校验，并最终生成数据绑定结果
		BindingData 对象
		④ Spring MVC 抽取 BindingResult 中的入参对象和校验错误对象，将它们赋给处理方法的响应入参
		⑤ Spring MVC 通• 过反射机制对目标处理方法进行解析，将请求消息绑定到处理方法的入参中。数据绑定的核心部件是
		DataBinder，运行机制如下：
	2. 数据转换
		① Spring MVC 上下文中内建了很多转换器，可完成大多数 Java 类型的转换工作。
		② ConversionService converters =
			java.lang.Boolean -> java.lang.String : –
			org.springframework.core.convert.support.ObjectToStringConverter@f874ca
			java.lang.Character -> java.lang.Number : CharacterToNumberFactory@f004c9 
			java.lang.Character -> java.lang.String : ObjectToStringConverter@68a961 
			java.lang.Enum -> java.lang.String : EnumToStringConverter@12f060a 
			java.lang.Number -> java.lang.Character : NumberToCharacterConverter@1482ac5 
			java.lang.Number -> java.lang.Number : NumberToNumberConverterFactory@126c6f 
			java.lang.Number -> java.lang.String : ObjectToStringConverter@14888e8 
			java.lang.String -> java.lang.Boolean : StringToBooleanConverter@1ca6626 
			java.lang.String -> java.lang.Character : StringToCharacterConverter@1143800 
			java.lang.String -> java.lang.Enum : StringToEnumConverterFactory@1bba86e 
			java.lang.String -> java.lang.Number : StringToNumberConverterFactory@18d2c12 
			java.lang.String -> java.util.Locale : StringToLocaleConverter@3598e1 
			java.lang.String -> java.util.Properties : StringToPropertiesConverter@c90828 
			java.lang.String -> java.util.UUID : StringToUUIDConverter@a42f23 
			java.util.Locale -> java.lang.String : ObjectToStringConverter@c7e20a 
			java.util.Properties -> java.lang.String : PropertiesToStringConverter@367a7f 
			java.util.UUID -> java.lang.String : ObjectToStringConverter@112b07f ……
		③ 自定义类型转换器
			A. ConversionService 是 Spring 类型转换体系的核心接口。
			B. 可以利用 ConversionServiceFactoryBean 在 Spring 的 IOC容器中定义一个 ConversionService. Spring 将自动识别出
			IOC 容器中的 ConversionService，并在 Bean 属性配置及Spring MVC 处理方法入参绑定等场合使用它进行数据的转换
			C. 可通过 ConversionServiceFactoryBean 的 converters 属性注册自定义的类型转换器
			D. Spring 支持的转换器：Spring 定义了 3 种类型的转换器接口，实现任意一个转换器接口都可以作为自定义转换器注册到
			ConversionServiceFactroyBean 中：
				a. Converter<S,T>：将 S 类型对象转为 T 类型对象
				b. ConverterFactory：将相同系列多个 “同质” Converter 封装在一起。如果希望将一种类型的对象转换为另一种类型及其子类的对
				象（例如将 String 转换为 Number 及 Number 子类（Integer、Long、Double 等）对象）可使用该转换器工厂类
				c. GenericConverter：会根据源类对象及目标类对象所在的宿主– 类中的上下文信息进行类型转换
			E. 自定义转换器示例
				a. 自定义类型转换器类，实现Converter<S, T>接口，将S类型转换为T类型
				public class EmployeesConvertor implements Converter<String, Employees> {
					@Override
					public Employees convert(String source) {
						if (source != null) {
							String[] strs = source.split("-");
							if(strs != null && strs.length == 4) {
								String empName = strs[0];
								String email = strs[1];
								Integer gender = Integer.parseInt(strs[2]);
								Integer depId = Integer.parseInt(strs[3]);
								
								Employees employee = new Employees(null, empName, email, gender, depId);
								System.out.println("source: " + source);
								System.out.println(ReflectionToStringBuilder.toString(employee, ToStringStyle.MULTI_LINE_STYLE));
								return employee;
							} 
						}
						return null;
					}

				}
				b. 在SpringMVC配置文件中配置类型转换器的ConversionServiceFactoryBean，并将类型转换器类的bean注册到conversionService的
				converters属性中，该属性可以是一个set，也可以是一个list。
				<bean id="conversionService"
					class="org.springframework.context.support.ConversionServiceFactoryBean">
					<property name="converters">
						<list>
							<bean class="com.li.springmvc.convertor.EmployeesConvertor"></bean>
						</list>
					</property>	
				</bean>
				c. 将类型转换器的conversionService绑定到<mvc:annotation-driven conversion-service=“conversionService”/>中，
				并将自定义的 ConversionService 注册到
				<mvc:annotation-driven conversion-service="conversionService"></mvc:annotation-driven>
				Spring MVC 的上下文中
				d. 使用自定义类型转换器：
				@RequestMapping(value = "testConversion", method = RequestMethod.POST)
				public String testConversion(@RequestParam("employee") Employees employee) {
					employeesService.addNewEmployee(employee);
					return "redirect:/emps/queryEmployees";
				}
	3. 关于 mvc:annotation-driven
		① 以下的场景需要在SpringMVC配置文件中使用mvc:annotation-driven标签
			A. 配置直接转发的页面，可以直接相应地转发的页面，而无须在经过Handler的方法 ，但是该配置会导致其他请求无法通过
			<mvc:view-controller path="springmvc/testJstlView" view-name="success"/>
			B. 处理静态资源，
			<mvc:default-servlet-handler/>
			C. 配置自定义类型转换器，需要将ConversionServiceFactoryBean的Bean绑定在mvc:annotation-driven标签中的
			conversion-service属性中
			<bean id="conversionService"
				class="org.springframework.context.support.ConversionServiceFactoryBean">
				<property name="converters">
					<list>
						<bean class="com.li.springmvc.convertor.EmployeesConvertor"></bean>
					</list>
				</property>	
			</bean>
			D. 开启数据转换、数据校验格式化、数据校验功能
		② 作用：
			A. <mvc:annotation-driven /> 会自动注册RequestMappingHandlerMapping(支持RequestMapping注解)、
			RequestMappingHandlerAdapter 与 ExceptionHandlerExceptionResolver 三个bean。
			B. 还将提供以下支持：
				a. 支持使用 ConversionService 实例对表单参数进行类型转换 
				b. 支持使用 @NumberFormat annotation、@DateTimeFormat 注解完成数据类型的格式化
				c. 支持使用 @Valid 注解对 JavaBean 实例进行 JSR 303 验证 
				d. 支持使用 @RequestBody 和 @ResponseBody 注解
		③ 在开发中一般需要在SpringMVC的配置文件中使用该标签
	4. @InitBinder
			A. 由 @InitBinder 标识的方法• ，可以对 WebDataBinder 对象进行初始化。WebDataBinder 是 DataBinder 的子类，用
			于完成由表单字段到 JavaBean 属性的绑定
			B. @InitBinder方法不能有返回值，它必须声明为void。
			C. @InitBinder方法的参数通常是是 WebDataBinder
			D. 不自动绑定对象中的***属性，另行处理
				@InitBinder
				public void initBinder(WebDataBinder dataBinder) {
					dataBinder.setDisallowedFields("empName");
				}
	5. 数据的格式化
		① 数据的格式化
			A. 对属性对象的输入/输出进行格式化，从其本质上讲依然 属于 “类型转换” 的范畴。
			B. Spring 在格式化模块中定义了一个实现 ConversionService 接口的FormattingConversionService 实现类，该实现类扩展
			了 GenericConversionService，因此它既具有类型转换的功能，又具有格式化的功能
			C. FormattingConversionService 拥有一个 FormattingConversionServiceFactroyBean 工厂类，后者用于在 Spring 上下文中构造前者
			D. FormattingConversionServiceFactroyBean 内部已经注册了
				a. NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性 使用 @NumberFormat 注解
				b. JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期– 类型的属性使用 @DateTimeFormat 注解
			E. 装配了 FormattingConversionServiceFactroyBean 后，就可 以在 Spring MVC 入参绑定及模型数据输出时使用注解驱动
			了。<mvc:annotation-driven/> 默认创建的ConversionService 实例即为FormattingConversionServiceFactroyBean
		② 日期格式化
			A. @DateTimeFormat 注解可对java.util.Date、java.util.Calendar、java.long.Long 时间
			类型进行标注：
			B. pattern 属性：类型为字符串。指定解析/格式化字段数据的模式，如：”yyyy-MM-dd hh:mm:ss”
			iso 属性：类型为 DateTimeFormat.ISO。指定解析/格式化字段数据的ISO模式，包括四种：ISO.NONE（不使用） -- 默
			认、ISO.DATE(yyyy-MM-dd) 、ISO.TIME(hh:mm:ss.SSSZ)、ISO.DATE_TIME(yyyy-MM-dd hh:mm:ss.SSSZ)
			C. style 属性：字符串类型。通过样式指定日期时间的格式，由两位字符组成，第一位表示日期的格式，第二位表示时间的格式：S：短日
			期/时间格式、M：中日期/时间格式、L：长日期/时间格式、F：完整日期/时间格式、-：忽略日期或时间格式
		③ 数值格式化
			A. @NumberFormat 可对类似数字类型的属性进行标注，它拥有两个互斥的属性：
				a. style：类型为 NumberFormat.Style。用于指定– 样式类型，包括三种：Style.NUMBER（正常数字类型）、
				Style.CURRENCY（货币类型）、 Style.PERCENT（百分数类型）
				b. pattern：类型为 String，自定义样式，如patter="#,###"；
		④ 数据格式化流程
			A. 流程
				a. 配置<mvc:annotation-driven></mvc:annotation-driven>
				b. 在POJO类的属性上添加 @DateTimeFormat 或者@NumberFormat注解，即可进行数据格式化
			B. 格式化示例：
				@DateTimeFormat(pattern = "yyyy-MM-dd")
				private Date birthday;
			C. 数据格式化与数据转换是同时进行的，如果有自定义类型转换器需要注册在ConversionServiceFactroyBean时，
			如果使用ConversionServiceFactoryBean时，会导致数据格式化失效，建议使用FormattingConversionServiceFactroyBean，
			该标签既支持自定义类型转换器，又支持数据格式化，并且该ConversionService默认是<mvc:annotation-driven>默认创建的
			<mvc:annotation-driven conversion-service="conversionService"></mvc:annotation-driven>
			<bean id="conversionService"
				class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
				<property name="converters">
					<list>
						<bean class="com.li.springmvc.convertor.EmployeesConvertor"></bean>
					</list>
				</property>	
			</bean>
	6. 数据校验
		① JSR 303
			A. JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 中 .
			B. JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证
			C. 注解：
				a. Null: 被注释的元素必须是Null
				b. NotNull: 被注释的元素必须不为Null
				c. @AssertTrue: 被注释的元素必须为true
				d. @AssertFalse: 被注释的元素必须为false
				e. @Min(value): 被注释的元素必须是一个数字，其值必须大于等于执行的最小值
				f. @Max(value): 被注释的元素必须是一个数字，其值必须小于等于指定的最大值
				g. @DecimalMin(value): 被注释的元素必须是一个数字，其值必须大于等于指定的最小值
				h. @DecimalMax(value): 被注释的元素必须是一个数字，其值必须小于等于指定的最大值
				i. @Size(max, min): 被注释的元素的大小必须在指定的范围内
				j. @Digits(integer, fraction): 被注释的元素必须是一个数字，其值必须在可接受的范围内
				k. @Past: 被注释的元素必须是一个过去的日期
				l. @Future: 被注释的元素必须是一个将来的日期
				m. @Pattern(value): 被注释的元素必须符合指定的正则表达式
		② Hibernate Validator 扩展注解
			A. Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解
			B. 注解：
				a. @Email: 被注释的元素必须是电子邮箱地址
				b. @Length: 被注释的字符串的大小必须在指定的范围内
				c. @NotEmpty: 被注释的字符串必须非空
				d. @Range: 被注释的元素必须在合适的范围内
		③ Spring MVC 数据校验
			A. 数据校验Spring 4.0 拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。
			B. Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在 Spring MVC 中，可直接通过注解驱动的方式进行数据校验
			C. Spring 的 LocalValidatorFactroyBean 既实现了 Spring 的Validator 接口，也实现了 JSR 303 的 Validator 接口。只要
			在 Spring 容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean 中。
			D. Spring 本身并没有提供 JSR303 的实现，所以必须将SR303 的实现者的 jar 包放到类路径下，需要导入以下包。
				a. classmate-0.8.0.jar
				b. hibernate-validator-5.0.0.CR2.jar
				c. hibernate-validator-annotation-processor-5.0.0.CR2.jar
				d. jboss-logging-3.1.1.GA.jar
				e. validation-api-1.1.0.CR1.jar
			E. <mvc:annotation-driven/> 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标
			注 @valid 注解即可让 Spring MVC 在完成数据绑定后执行数据校验的工作，因此需要在SpringMVC配置文件上配置
			<mvc:annotation-driven/>
			F. 在已经标注了 JSR303 注解的表单/命令对象前标注一个 @Valid，Spring MVC 框架在将请求参数绑定到该入参对象
			后，就会调用校验框架根据注解声明的校验规则实施校验
			public String addNewEmployee(@Valid Employees employee, BindingResult result, 
				Map<String, Object> map)
			G. Spring MVC 是通过对处理方法签名的规约来保存校验结果的：前一个表单/命令对象的校验结果保存到随后的入参
			中，这个保存校验结果的入参必须是 BindingResult 或Errors 类型，这两个类都位于org.springframework.validation 包中	
			需校验的 Bean 对象和其绑定结果对象或错误对象是成对出现的，它们之间不允许声明其他的入参
			H. Errors 接口提供了获取错误信息的方法，如 getErrorCount()或getFieldErrors(String field) 
			J. BindingResult 扩展了 Errors 接口
		④ 在目标方法中获取校验结果
			A. 在表单/命令对象类的属性中标注校验注解，在处理方法对应的入参前添加 @Valid，Spring MVC 就会实施校验并将校
			验结果保存在被校验入参对象之后的 BindingResult 或Errors 入参中。
			B. 常用方法：
				a. FieldError getFieldError(String field)：获取错误信息的属性
				b. List<FieldError> getFieldErrors()：获取所有错误信息的对象
				c. Object getFieldValue(String field)：获取错误信息的内容
				d. Int getErrorCount()：获取错误信息个数
			C. 举例：
			if(result.getErrorCount() > 0) {
				System.out.println("出错了");
				for (FieldError error : result.getFieldErrors()) {
					System.out.println(error.getField() + ": " + error.getDefaultMessage());
				}
			}
		⑤ 在页面上显示错误	
			A. Spring MVC 除了会将表单/命令对象的校验结果保存到对 应的 BindingResult 或 Errors 对象中外，还会将所有校验
			结果保存到 “隐含模型”
			B. 即使处理方法的签名中没有对应于表单/命令对象的结果入参，校验结果也会保存在 “隐含对象” 中。
			C. 隐含模型中的所有数据最终将通过 HttpServletRequest 的属性列表暴露给 JSP 视图对象，因此在 JSP 中可以获取
			错误信息
			D. 在 JSP 页面上可通过 <form:errors path=“*”> 显示所有错误消息，使用<form:errors path=“属性名”>可以显示该属性的错误消息
			E. 举例：
				<form:errors path="*"></form:errors>
				<form:errors path="empName"></form:errors>
		⑥ 提示消息的国际化
			A. 每个属性在数据绑定和数据校验发生错误时，都会生成一个对应的 FieldError 对象。
			B. 当一个属性校验失败后，校验框架会为该属性生成 4 个消息代码，这些代码以校验注解类名为前缀，结合
			modleAttribute、属性名及属性类型名生成多个对应的消息代码：例如 User 类中的 password 属性标准了一个 @Pattern 注
			解，当该属性值不满足 @Pattern 所定义的规则时, 就会产生以下 4个错误代码
				a. Pattern.user.password
				b. Pattern.password 
				c. Pattern.java.lang.String 
				d. Pattern
			C. 当使用 Spring MVC 标签显示错误• 消息时， Spring MVC 会查看WEB 上下文是否装配了对应的国际化消息，如果没有，则显示默认
			的错误消息，否则使用国际化消息。
			D. 若数据类型转换或数据格式转换时发生错误，或该有的参数不存在，或调用处理方法时发生错误，都会在隐含模型
			中创建错误消息。其错误代码前缀说明如下：
				a. required：必要的参数不存在。如 @RequiredParam(“param1”) 标注了一个入参，但是该参数不存在
				b. typeMismatch：在数据绑定时，发生数据类型不匹配的问题
					typeMismatch.employees.birthday=^^Birthday \u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u7684\u65E5\u671F
				c. methodInvocation：Spring MVC 在调用处理方法时发生了错误 
			E.  注册国际化资源文件
				a. 新建一个国际化资源文件i18n.properties
				b. 以属性标注的注解名为前缀，ModelAttribute中的对象以及对象的属性名生成消息代码
					NotEmpty.employees.empName=^^EmpName \u4E0D\u80FD\u4E3A\u7A7A
					Email.employees.email=^^Email \u5730\u5740\u4E0D\u5408\u6CD5
					Past.employees.birthday=^^Birthday \u4E0D\u80FD\u662F\u4E00\u4E2A\u5C06\u6765\u7684\u65F6\u95F4
					
				<bean id="messageSource"
				class="org.springframework.context.support.ResourceBundleMessageSource">
					<property name="basename" value="i18n"></property>
				</bean>
十、处理 JSON：使用 HttpMessageConverter
	1. 处理 JSON
		① 目标方法返回的是一个实体类对象或者集合
			A. 加入 jar 包：
				jackson-annotations-2.9.8.jar
				jackson-core-2.9.8.jar
				jackson-databind-2.9.8.jar
			B. 编写目标方法，使其返回 JSON 对应的对象或集合
			C. 在方法上添加 @ResponseBody 注解
			D. 举例：
				@ResponseBody
				@RequestMapping("/testJson")
				public List<Employees> testJson() {
					List<Employees> employees = employeeSerice.queryEmployees();
					return employees;
				}
		② 目标方法返回的是一个json对象
			A. 加入 jar 包
				commons-beanutils.jar
				commons-collections.jar
				commons-lang.jar
				commons-logging-1.2.jar
				ezmorph-1.0.4.jar
				json-lib-2.3-jdk15.jar	
			B. 编写目标方法，使其返回 JSON 对象	
			C. 在方法上添加 @ResponseBody 注解
			D. 举例：
				@ResponseBody
				@RequestMapping("/testJson")
				public JSONObject testJson() {
					List<Employees> employees = employeeSerice.queryEmployees();
					JSONObject json = new JSONObject();
					json.accumulate("employees", employees);
					return json;
				}
	2. 	HttpMessageConverter<T>
		① HttpMessageConverter<T> 是 Spring3.0 新添加的一个接口，负责将请求信息转换为一个对象（类型为 T），将对象（
		类型为 T）输出为响应信息
		② HttpMessageConverter<T>接口定义的方法：
			A. Boolean canRead(Class<?> clazz,MediaType mediaType): 指定转换器可以读取的对象类型，即转换器是否可将请求信息转换为 clazz 类型的对
			象，同时指定支持 MIME 类型(text/html,applaiction/json等)
			B. Boolean canWrite(Class<?> clazz,MediaType mediaType):指定转换器是否可将 clazz 类型的对象写到响应流中，响应流支持的媒体类型
			在MediaType 中定义。
			C. LIst<MediaType> getSupportMediaTypes()：该转换器支持的媒体类型。
			D. T read(Class<? extends T> clazz,HttpInputMessage inputMessage)：将请求信息流转换为 T 类型的对象。
			E. void write(T t,MediaType contnetType,HttpOutputMessgae outputMessage):将T类型的对象写到响应流中，同时指定相应的媒体类
			型为 contentType。
	3. 使用 HttpMessageConverter<T>
		A. 使用 HttpMessageConverter<T> 将请求信息转化并绑定到处理方法的入参中或将响应结果转为对应类型的响应信息，Spring 提供了两种途径：
			a. 使用 @RequestBody / @ResponseBody  对处理方法进行标注
			b. 使用 HttpEntity<T> / ResponseEntity<T> 作为处理方法的入参或返回值当控制器处理方法使用到 @RequestBody/@ResponseBody 
			或HttpEntity<T>/ResponseEntity<T> 时, Spring 首先根据请求头或响应头的Accept 属性选择匹配的 HttpMessageConverter, 
			进而根据参数类型或泛型类型的过滤得到匹配的 HttpMessageConverter, 若找不到可用的HttpMessageConverter 将报错
			c. @RequestBody 和 @ResponseBody 不需要成对出现
		B. 使用	@RequestBody / @ResponseBody， 其对应的是StringHttpMessageConverter（文件上传）
			@ResponseBody
			@RequestMapping("/testHttpMessageconverter")
			public String testHttpMessageconverter(@RequestBody String body) {
				System.out.println(body);
				return "helloworld" + new Date();
			}
			<form action="springmvc/testHttpMessageconverter" method="post" enctype="multipart/form-data">
				file:<input type="file" name="file"/>
				desc:<input type="text" name="desc"/>
				<input type="submit" value="submit"/>
			</form>
		C. 使用HttpEntity<T> / ResponseEntity<T>， 其对应ByteArrayMessageConverter（文件下载）
			@RequestMapping("/testResponseEntity")
			public ResponseEntity<byte[]> testResponseEntity(HttpServletRequest request) throws IOException {
				InputStream in = request.getServletContext().getResourceAsStream("/pdf/pdf.pdf");
				BufferedInputStream bis = new BufferedInputStream(in);
				byte[] body = null;
				body = new byte[bis.available()];
				bis.read(body);
				
				HttpHeaders headers = new HttpHeaders();
				headers.add("Content-Disposition", "attachment;filename=hello.pdf");
				
				HttpStatus status = HttpStatus.OK;
				ResponseEntity<byte[]> responseEntity = new ResponseEntity<byte[]>(body, headers, status);
				return responseEntity;
			}
十一、国际化			
	1. 概述
		① 关于国际化
			A. 在页面上能够根据浏览器语言设置的情况对文本（不是内容）、时间、数值进行本地化
			B. 可以在bean中获取国际化资源文件locale对应的信息
			C. 可以通过超链接切换Local，而不再依赖与浏览器的语言设置
		② 解决：
			A. 使用JSTL的fmt标签
			B. 在bean中注入ResourceBundleMessageSourcede 的实例。使其对应的getMessage方法即可
			C. 配置LocalResolver和LocaleChangeIntercept
	2. SessionLocaleResolver & LocaleChangeInterceptor 工作原理
		A. 默认情况下，SpringMVC 根据 Accept-Language 参数 判断客户端的本地化类型。
		B. 当接受到请求时，SpringMVC 会在上下文中查找一个本地化解析器（LocalResolver），找到后使用它获取请求
		所对应的本地化类型信息。
		C. SpringMVC还允许装配一个动态更改本地化类型的拦截器，这样通过指定一个请求参数就可以控制单个请求的本地化类型。
		D. 具体工作流程	
			a. LocaleChangeInterceptor
				(1) 获取name=locale的请求参数
				(2) 第一步的local请求参数解析为Locale对象
				(3) 获取LocaleResolver对象
			b. SessionLocaleResolver
				(1) 把Locale对象设置为Session属性
				(2) 从session中获取Locale对象
			c. 应用程序
				(1) 使用该Locale对象
	3. 本地化解析器和本地化拦截器
		① AcceptHeaderLocaleResolver：根据 HTTP 请求头的Accept-Language 参数确定本地化类型，如果没有显式定义
		本地化解析器， SpringMVC 使用该解析器。
		② CookieLocaleResolver：根据指定的 Cookie 值确定本地化类型
		③ SessionLocaleResolver：根据 Session 中特定的属性确定本地化类型
		④ LocaleChangeInterceptor：从请求参数中获取本次请求对应的本地化类型。	
	4. 使用国际化
		① 在SpringMVC配置文件中配置国际化
			<!-- 配置国际化资源文件 -->
			<bean id="messageSource"
			class="org.springframework.context.support.ResourceBundleMessageSource">
				<property name="basename" value="i18n"></property>
			</bean>
		② 配置国际化资源文件
			A. i18n_en_US.properties
			B. i18n_zh_CN.properties
			C. i18n.properties
		③ 使用JSTL标签
			<fmt:message key="i18n.username"></fmt:message>
		④ 在bean中注入ResourceBundleMessageSourcede 的实例。使其对应的getMessage方法
			@Autowired
			private ResourceBundleMessageSource messageSource;
			
			@RequestMapping("i18n")
			public String TestI18n(Locale locale) {
				String message = messageSource.getMessage("i18n.username", null, locale);
				System.out.println(message);
				return "i18n";
			}
		④ 使用超链接切换Local
			A. 配置SessionLocaleResolver
			B. 配置LocaleChangeInterceptor拦截器
			C. 请求地址中需要加上代表语言的请求参数locale
			<bean id="localeResolver" 
			class="org.springframework.web.servlet.i18n.SessionLocaleResolver"></bean>
			<mvc:interceptors>
				<bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"></bean>
			</mvc:interceptors>
			<a href="${pageContext.request.contextPath }/springmvc/i18n?locale=zh_CH">中文</a><br/><br/>
			<a href="${pageContext.request.contextPath }/springmvc/i18n?locale=en_US">英文</a><br/><br/>
十二、文件上传
	1. 文件上传概述
		A. Spring MVC 为文件上传提供了直接的支持，这种支持是通过即插即用的 MultipartResolver 实现的。Spring 用
		Jakarta Commons FileUpload 技术实现了一个MultipartResolver 实现类：CommonsMultipartResovler
		B. Spring MVC 上下文中默认没有装配 MultipartResovler，因此默认情况下不能处理文件的上传工作，
		如果想使用 Spring 的文件上传功能，需现在上下文中配置 MultipartResolver
	2. 配置 MultipartResolver
		A. defaultEncoding: 必须和用户 JSP 的 pageEncoding 属性 一致，以便正确解析表单的内容
			<!-- 文件上传，配置 MultipartResolver -->
			<bean id="multipartResolver"
				class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
				<property name="defaultEncoding" value="UTF-8"></property>
				<property name="maxUploadSize" value="5242880"></property>
			</bean>
		B. 为了让 CommonsMultipartResovler正确工作，必须先将 Jakarta Commons FileUpload 及 Jakarta Commons io
		的类包添加到类路径下。
			a. commons-fileupload-1.4.jar
			b. commons-io-2.6.jar
	3. 文件实例：
		<form action="springmvc/testMultipartResolver" method="post" enctype="multipart/form-data">
			file:<input type="file" name="file"/>
			desc:<input type="text" name="desc"/>
			<input type="submit" value="submit"/>
		</form>
		@RequestMapping(value = "testMultipartResolver", method=RequestMethod.POST)
		public String testMultipartResolver(@RequestParam("desc") String desc, 
				@RequestParam("file") MultipartFile file) throws IllegalStateException, IOException {
			if (!file.isEmpty()) {
				System.out.println(desc);
				file.transferTo(new File("E:\\files\\" + file.getOriginalFilename()));
			}
			return SUCCESS;
		}
十三、自定义拦截器
	1. Spring MVC 也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必
	须实现HandlerInterceptor接口
		① preHandle()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求 request 进行处理。如果程序员决定该拦截器对
		请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true；如果程序员决定不需要再调用其他的组件
		去处理请求，则返回false。
		② postHandle()：这个方法在业务处理器处理完请求后，但 是DispatcherServlet 向客户端返回响应前被调用，在该方法中对
		用户请求request进行处理。
		③ afterCompletion()：这个方法在 DispatcherServlet 完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作
	2. 拦截器方法执行顺序
		① 执行拦截器HandlerInterceptor的preHandle()方法
		② 执行目标方HandleAdapter的handle
		③ 执行拦截器HandlerInterceptor的postHandle()方法，该方法可以对目标方法返回的视图进行处理
		④ 执行DispatcherServlet的render()方法，即请求被完成
		⑤ 执行拦截器HandlerInterceptor的fterCompletion()方法
	3. 自定义拦截器
		① 拦截器可以拦截所有资源也可以对指定资源进行拦截，其中包括静态资源，但是不包括jsp页面， 
		所以需要使用默认的Servlet处理静态资源而不被拦截。
		② 配合SpringMVC 的拦截器，并注册自定义拦截器和拦截指定的资源
		<mvc:interceptors>
			<!-- 指定拦截的资源，注意拦截器不能拦截jsp文件，需要通过filter -->
			<mvc:interceptor>
				<mvc:mapping path="/index.jsp"/>
				<bean class="com.li.springmvc.interceptor.TestHandlerInterceptor"></bean>
			</mvc:interceptor>
			<bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"></bean>
		</mvc:interceptors>
		③ 定义自定义拦截器，要求必须实现HandlerInterceptor接口
		public class TestHandlerInterceptor implements HandlerInterceptor {

			@Override
			public void afterCompletion(HttpServletRequest arg0,
					HttpServletResponse arg1, Object arg2, Exception arg3)
					throws Exception {
				System.out.println("TestHandlerInterceptor's afterCompletion...");
				
			}

			@Override
			public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1,
					Object arg2, ModelAndView arg3) throws Exception {
				System.out.println("TestHandlerInterceptor's postHandle...");
			}

			@Override
			public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1,
					Object arg2) throws Exception {
				System.out.println("TestHandlerInterceptor's preHandle...");
				return true;
			}

		}
	4. 多个拦截器之间的执行顺序
		① 执行第一个拦截器的preHandle()方法
		② 执行第二个拦截器的preHandle()方法
		③ 如果第二个拦截器的preHandle()方法返回的是false，则直接跳到第八步，如果返回的是true，则继续往下执行
		④ 执行目标方法的handle方法
		⑤ 执行第二个拦截器的postHandle()方法
		⑥ 执行第一个拦截器的postHandle()方法
		⑦ 执行完DispatcherServlet的render()方法
		⑧ 执行第二个拦截器的afterCompletion()方法
十四、异常处理
	1. 异常处理概述
		① Spring MVC 通过 HandlerExceptionResolver 处理程序的异常，包括 Handler 映射、数据绑定以及目标方法执行时发生的异常。
		② SpringMVC 提供的 HandlerExceptionResolver 的实现类
			A. ExceptionHandlerExceptionResolver
			B. DefaultHandlerExceptionResolver
			C. ResponseStatusExceptionResolver
			D. SimpleMeppingExceptionResolver			
	2. HandlerExceptionResolver
		① DispatcherServlet 默认装配的 HandlerExceptionResolver
			A. 没有使用 <mvc:annotation-driven/> 配置，则使用HandlerExceptionResolver 的实现类：
				a. AnnotationMethodHandlerExceptionResolver
				b. ResponseStatusExceptionResolver
				c. DefaultHandlerExceptionResolver
			B. 使用了<mvc:annotation-driven/> 配置， 则使用
				a. ExceptionHandlerExceptionResolver
				b. ResponseStatuseExceptionResolver
				c. DefaultHandlerExceptionResolver
	3. ExceptionHandlerExceptionResolver		
		① 主要处理 Handler 中用 @ExceptionHandler 注解定义的方法，并且该方法只作用在当前的controller中
		② @ExceptionHandler 注解定义的方法优先级问题：例如发生的是NullPointerException，但是声明的异常有
		RuntimeException 和 Exception，此候会根据异常的最近继承关系找到继承深度最浅的那个 @ExceptionHandler
		注解方法，即标记了 RuntimeException 的方法
		③ ExceptionHandlerMethodResolver 内部若找不 到@ExceptionHandler 注解的话，会找@ControllerAdvice 
		中的@ExceptionHandler 注解方法
		④ 在@ExceptionHandler方法的入参中可以加入Exception类型的参数，该参数对应发生的异常对象
		⑤ @ExceptionHandler方法的入参中不可以传入Map，若希望吧异常信息传递到页面上，需要使用ModelAndView作为返回值
		⑥ 示例：
			@ControllerAdvice
			public class TestHandlerException {
				private static final String ERROR = "error";
				@ExceptionHandler({ArithmeticException.class})
				public ModelAndView handlerException(Exception ex) {
					ModelAndView mv = new ModelAndView(ERROR);
					mv.addObject("ex", ex);
					System.out.println("出异常了： " + ex);
					return mv;
				}
			}
			@ExceptionHandler({ArithmeticException.class})
			public ModelAndView handlerException(Exception ex) {
				ModelAndView mv = new ModelAndView(ERROR);
				mv.addObject("ex", ex); 
				System.out.println("出异常了： " + ex);
				return mv;
			}
			@RequestMapping("/testHandlerException/{num}")
			public String testHandlerException(@PathVariable("num") Integer num) {
				int result = 10 / num;
				System.out.println("result: " + result);
				return SUCCESS;
			}
	4. 	ResponseStatusExceptionResolver
		① 在异常及异常父类中找到 @ResponseStatus 注解，然后使用这个注解的属性进行处理。
		② 定义一个 @ResponseStatus 注解修饰的异常类
			@ResponseStatus(value=HttpStatus.NOT_FOUND, reason = "页面不存在")
			public class TestRuntimeException extends RuntimeException
		③ 若在处理器方法中抛出了上述异常：
			若ExceptionHandlerExceptionResolver 不解析述异常。由于触发的异常 TestRuntimeException 带有@ResponseStatus
			注解最后响应HttpStatus.NOT_FOUND 代码给客户端。HttpStatus.NOT_FOUND 代表响应码404，页面不存在。
			关于其他的响应码请参考 HttpStatus 枚举类型源码。
		④ 若在目标方法上方使用@ResponseStatus修饰，则目标方法就算没有抛出异常，该方法最后也会将@ResponseStatus标注的
		状态码返回给客户端。
	5. DefaultHandlerExceptionResolver
		对一些特殊的异常进行处理，比 如NoSuchRequestHandlingMethodException、HttpRequestMethodNotSupportedException、
		HttpMediaTypeNotSupportedException、HttpMediaTypeNotAcceptableException等。
	6. SimpleMappingExceptionResolver
		① 如果希望对所有异常进行统一处理，可以使用SimpleMappingExceptionResolver，它将异常类名映射为
		视图名，即发生异常时使用对应的视图报告异常
		② 返回异常页面时还携带了异常对象，默认的key为exception，可以在配置中修改默认的异常对象key
		③ 在springmvc上下文配置异常映射页面
		<bean id="simpleMappingExceptionResolver"
			 class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
			<property name="exceptionAttribute" value="ex"></property>
			<property name="exceptionMappings">
				<props>
					<prop key="java.lang.ArrayIndexOutOfBoundsException">error</prop>
				</props>
			</property>	 
		</bean>		
十五、SpringMVC的运行流程
	1. 运行流程图解
		① 浏览器发送的请求会被SpringDispatcherServlet的url-pattern捕获
		② SpringMVC会判断是否存在请求相应的映射
		③ 如果不存在相应的映射，根据SpringMVC是否配置了<mvc:default-servlet-handler/>，如果配置了，则会发送目标资源，
		如果没有配置，则控制台会打印No mapping found for HTTP request with URI [/xx/xx] in DispatcherServlet
		并且返回404页面，如果配置而不存在目标资源，会出现404页面，但控制台不会打印请求没有映射的信息
		④ 如果存在相应的映射HandlerMapping获取HandlerExecutionChain对象
		⑤ 获取HandlerAdapter对象
		⑥ 调用拦截器的preHandle方法
		⑦ 调用目标Handler的目标方法得到ModeAndView对象
		⑧ 调用拦截器的postHandle方法
		⑨ 如果存在异常，则由HandlerExceptionResolver组件处理异常，得到新的ModeAndView对象
		⑩ 如果不存在异常，返回的视图或者由HandlerExceptionResolver处理得到新的视图由ViewResolver组件根据
		ModeAndView对象得到实际的视图View对象
		①① 渲染视图
		①② 调用拦截器的afterCompletion方法
十六、Spring整合SpringMVC		
	1. 环境搭建：
		① 创建web动态工程
		② 导入Spring、SpringMVC和数据源依赖的jar包
			A. Spring：
				(1) commons-logging-1.2.jar
				(2) spring-aop-4.3.22.RELEASE.jar
				(3) spring-beans-4.3.22.RELEASE.jar
				(4) spring-context-4.3.22.RELEASE.jar
				(5) spring-core-4.3.22.RELEASE.jar
				(6) spring-expression-4.3.22.RELEASE.jar
			B. Spring事务
				(1) spring-jdbc-4.3.22.RELEASE.jar
				(2) spring-tx-4.3.22.RELEASE.jar
			C. SpringMVC
				(1) spring-web-4.3.22.RELEASE.jar
				(2) spring-webmvc-4.3.22.RELEASE.jar
			D. 数据源
				(1) c3p0-0.9.1.2.jar
				(2) mysql-connector-java-5.1.47.jar
			E. 单元测试类
				(1) hamcrest-core-1.3.jar
				(2) junit-4.12.jar
				(3) spring-test-3.2.0.RELEASE.jar
			F. jstl
				(1) jstl-1.2.jar
				(2) standard.jar
		③ 配置web.xml文件
			A. 配置SpringMVC 的 DispatcherServlet （IOC容器）
				<servlet>
					<servlet-name>springDispatcherServlet</servlet-name>
					<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
					<!-- 配置 DispatcherServlet 的初始化参数：配置SpringMVC配置文件的位置和名称-->
					<init-param>
						<param-name>contextConfigLocation</param-name>
						<param-value>classpath:applicationContext-mvc.xml</param-value>
					</init-param>
					<load-on-startup>1</load-on-startup>
				</servlet>

				<servlet-mapping>
					<servlet-name>springDispatcherServlet</servlet-name>
					<url-pattern>/</url-pattern>
				</servlet-mapping>
			B. 配置Spring的 IOC容器
				<context-param>
					<param-name>contextConfigLocation</param-name>
					<param-value>classpath:applicationContext.xml</param-value>
				</context-param>

				<listener>
					<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
				</listener>
			C.  配置org.springframework.web.filter.HiddenHttpMethodFilter，作用：由于超链接发送的是GET请求，
			而form表单标签只支持GET和POST请求，org.springframework.web.context.ContextLoaderListener支持将
			POST转化为DELETE或者PUT
				<filter>
					<filter-name>HiddenHttpMethodFilter</filter-name>
					<filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
				</filter>
				<filter-mapping>
					<filter-name>HiddenHttpMethodFilter</filter-name>
					<url-pattern>/*</url-pattern>
				</filter-mapping>
		④ 配置Spring和SpringMVC的配置文件
			A. 配置Spring配置文件
				(1) 导入bean和context命名空间
				(2) 开启注解扫描，因为Spring配置文件只需要注册Spring的Bean，
				因此只扫描除除Controller注解和ControllerAdvice 之外的Bean
				<!-- 开启注解扫描，除Controller注解和ControllerAdvice 之外-->
				<context:component-scan base-package="com.li.springmvc">
					<context:exclude-filter type="annotation" 
						expression="org.springframework.stereotype.Controller"/>
					<context:exclude-filter type="annotation" 
						expression="org.springframework.web.bind.annotation.ControllerAdvice"/>
				</context:component-scan>					
	2. 在 Spring MVC 配置文件中引用业务层的 Bean
		① 多个 Spring IOC 容器之间可以设置为父子关系，以实现良好的解耦。
		② Spring MVC WEB 层容器可作为 “业务层” Spring容器的子容器：即 WEB 层容器可以引用业务层
		容器的 Bean，而业务层容器却访问不到 WEB 层容器的 Bean
十七、SpringMVC 对比 Struts2
1. Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter 
2. Spring MVC 会稍微比 Struts2 快些. Spring MVC 是基 于方法设计, 而 Sturts2 是基于类, 每次发一次请求都会实例一个 Action.
3. Spring MVC 使用更加简洁, 开发效率Spring MVC确实 比 struts2 高: 支持 JSR303, 处理 ajax 的请求更方便
4. Struts2 的 • OGNL 表达式使页面的开发效率相比Spring MVC 更高些.			