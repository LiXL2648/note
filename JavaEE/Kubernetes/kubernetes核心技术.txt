六、kubernetes 核心技术-Pod
	1. Pod 概述
		① Pod 是 k8s 系统中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最小资源对象模型，也是在 k8s 上运行容器化应用的资源对象，
		其他的资源对象都是用来支撑或者扩展 Pod 对象功能的，比如控制器对象是用来管控 Pod 对象的，Service 或者 Ingress 资源对象是用来暴露 Pod 引用
		对象的，PersistentVolume 资源对象用来为 Pod 提供存储等等，k8s 不会直接处理容器，而是 Pod，Pod 是由一个或者多个 Container 组成的。
		② Pod 是 Kubernetes 的最重要概念，每一个 Pod 都有一个特殊的被称为“根容器”的 pause 容器。 Pause 容器对应的镜像属于 Kubernetes 平台的一部
		分，除了 Pause 容器，每个 Pod 还包含一个或多个紧密相关的用户业务容器
		③ Pod VS 应用：每个 Pod 都是应用的一个实例，有专用的 IP
		④ Pod VS 容器：一个 Pod 可以有多个容器，彼此间共享网络和存储资源，每个 Pod 中有一个 Pause 容器保存所有容器状态，通过管理 pause 容器，达
		到管理 Pod 中所有容器的效果
		⑤ Pod VS 节点：同一个 Pod 中的容器总会被调度到相同 Node 节点，不同节点间 Pod 的通信基于虚拟二层网络技术实现。
		⑥ Pod VS Pod：普通 Pod 和 静态 Pod
	2. Pod 特性
		① 资源共享
			A. 一个 Pod 里的多个容器可以共享存储和网络，可以看作一个逻辑的主机。共享的如 namespace，cgroups 或者其他的隔离资源。
			B. 多个容器共享同一个 network namespace，由此在一个 Pod 里的多个容器共享 Pod 的 IP 和 端口 namespace，所以一个 Pod 内的多个容器之间
			可以通过 localhost 来进行通信，所需要注意的是不同容器不要有端口冲突即可。不同的 Pod 有不同的 IP，不同 Pod 内的多个容器之间通信，不可
			使用 IPC（没有特殊指定）通信，通常情况下使用 Pod 的 IP 进行通信。
			C. 一个 Pod 里的多个容器可以共享存储卷，这个存储卷会被定义为 Pod 的一部分，并且可以挂载到该 Pod 里的所有容器的文件系统上。
		② 生命周期短暂：Pod 属于生命周期比较短暂的组件，比如：当 Pod 所在节点发生故障，那么该节点上的 Pod 会被调度到其他节点上，但需要注意的是，
		被重新调度的 Pod 是一个全新的 Pod，跟之前的 Pod 没有一点关系。
		③ 平坦的网络：k8s 集群中的所有 Pod 都在一个共享的网络地址空间上，也就是说每个 Pod 都可以通过其它 Pod 的 IP 地址来实现访问。
	3. Pod 定义，下面是 yaml 文件定义的 Pod 的完整内容
		apiVersion: v1
		kind: Pod
		metadata: //元数据
		  name: string
		  namespace: string
		labels:
		  -	name: string
		annotations:
		  - name: string
		spec:
		  containers: //pod 中的容器列表，可以有多个容器
			- name: string //容器的名称
			  image: string //容器中的镜像
			  imagesPullPolicy: [Always|Never|IfNotPresent]//获取镜像的策略，默认值为Always，每次都尝试重新下载镜像
			  command: [string] //容器的启动命令列表（不配置的话使用镜像内部的命令） 
			  args: [string] //启动参数列表
			  workingDir: string //容器的工作目录 volumeMounts: //挂载到到容器内部的存储卷设置
			- name: string
			  mountPath: string //存储卷在容器内部 Mount 的绝对路径 readOnly: boolean //默认值为读写
			  ports: //容器需要暴露的端口号列表
				- name: string
				  containerPort: int //容器要暴露的端口
				  hostPort: int //容器所在主机监听的端口（容器暴露端口映射到宿主机的端口，设置hostPort 时同一 台宿主机将不能再启动该容器的第 2 份副本）
				  protocol: string //TCP 和 UDP，默认值为 TCP env: //容器运行前要设置的环境列表
				-name: string value: string
			  resources:
				limits: //资源限制，容器的最大可用资源数量 cpu: Srting
				  memory: string
				requeste: //资源限制，容器启动的初始可用资源数量 cpu: string
				  memory: string
		livenessProbe: //pod 内容器健康检查的设置 exec:
		command: [string] //exec 方式需要指定的命令或脚本 httpGet: //通过 httpget 检
		查健康
		path: string port: number host: string scheme: Srtring httpHeaders:
		- name: Stirng value: string
		tcpSocket: //通过 tcpSocket 检查健康
		port: number initialDelaySeconds: 0//首次检查时间 timeoutSeconds: 0 //检查超时
		时间
		periodSeconds: 0 //检查间隔时间
		successThreshold: 0
		failureThreshold: 0 securityContext: //安全配置
		privileged: falae
		restartPolicy: [Always|Never|OnFailure]//重启策略，默认值为 Always
		nodeSelector: object //节点选择，表示将该 Pod 调度到包含这些 label 的 Node 上，以
		key:value 格式指定
		imagePullSecrets:
		-name: string
		hostNetwork: false //是否使用主机网络模式，弃用 Docker 网桥，默认否
		volumes: //在该 pod 上定义共享存储卷列表
		-name: string emptyDir: {} hostPath:
		path: string secret:
		secretName: string item:
		-key: string path: string
		configMap: name: string items:
		-key: string
		path: string
	4. Pod 的基本使用方法
		① 在 Kubernetest 中对运行容器的要求为：容器的主程序需要一直在前台运行，而不是后台运行。应用需要改造成前台运行的方式。如果我们创建的 Docker 镜像
		的启动命令是后台执行程序，则在 kubelet 创建包含这个容器的 Pod 之后运行该命令，即认为 Pod 已经结束，将立刻销毁该 Pod。如果为该 Pod 定义了 RC，则
		创建、销毁会陷入一个无限循环的过程中。Pod 可以由一个或者多个容器组合而成。
		② Pod 示例：
			A. 一个容器组成的 Pod 的 yaml 示例：
				# 一个容器组成的 Pod
				apiVersion: v1
				kind: Pod
				metadata:
				  name: mytomcat
				labels:
				  name: mytomcat
				spec:
				  containers:
					- name: mytomcat
					  image: tomcat
					  ports:
						- containerPort: 8000
			B. 多个容器组成的 Pod 的 yaml 示例
				#两个紧密耦合的容器
				apiVersion: v1
				kind: Pod
				metadata:
				  name: myweb
				labels:
				  name: tomcat-redis
				spec:
				  containers:
					- name: tomcat
					  image: tomcat
					  ports:
						-containerPort: 8080
					- name: redis
					  image: redis
					  ports:
						-containerPort: 6379
			C. 镜像拉取策略
				apiVersion: v1
					kind: Pod
					metadata:
					  name: myPod
					spec:
					  containers:
						- name: nginx
						  image: nginx:1.14
						  imagesPullPolicy: Always
						  # Always：每次尝试重新拉取镜像
						  # Never：仅使用本地镜像
						  # IfNotPresent：如果本地有镜像就使用本地的，没有就拉取在线镜像
			D. Pod 资源限制的 yaml 实例
				apiVersion: v1
				kind: Pod
				metadata:
				  name: frontend
				labels:
				  name: tomcat-redis
				spec:
				  containers:
					- name: db
					  image: mysql
					  env:
						- name: MYSQL_ROOT_PASSWORD
						  value: "password"
					  resources:
						requests:# 调度
						  memory: "64Mi"
						  cpu: "250m"
						limits:# 限定
						  memory: "128Mi"
						  cpu: "500m"
			E. 共享存储示例：
				apiVersion: v1
				kind: Pod
				metadata:
				  name: my-pod
				spec:
				  containers:
					- name: write
					  image: centos
					  command: ["bash", "-c", "for i in (1..100);do echo $i >> /data/hello;sleep 1;done"]
					  volumeMounts:
						- name: data
						  mountPath: /data
					- name: read
					  image: centos
					  command: ["bash", "-c", "tail -f /data/hello"]
					  volumeMounts:
						- name: data
						  mountPath: /data
				  volumes:
					- name: data
					  emptyDir: {}
			F. Pod 重启策略
				apiVersion: v1
				kind: Pod
				metadata:
				  name: dns-test
				spec:
				  containers:
					- name: busybox
					  image: busybox:1.28.4
					  args:
					    - /bin/sh
						- -c
						-sleep 36000
					  restartPolicy: Never
			G. Pod 健康检查
				apiVersion: v1
				kind: Pod
				metadata:
				  labels:
				    test: liveness
				  name: liveness-exec
				spec:
				  containers:
					- name: liveness
					  image: busybox
					  args:
					    - /bin/sh
						- -c
						- touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy
					  livenessProbe:
					    exec:
						  command:
						    - cat
							- /tmp/healthy
						initialDelaySeconds: 5
						periodSeconds: 5
				# livenessProbe（存活检查）：如果检查失败，将杀死容器，根据 Pod 的 restartPolicy 来操作
				# readinessProbe（就绪检查）：如果检查失败，Kubernetes 会把 Pod 从 Service endpoint 中剔除
				# Probe 支持以下三种检查方式：
				# httpGet：发生 HTTP 请求，返回 200-400 范围状态码为成功。
				# exec：执行 shell 命令返回状态码是 0 为成功
				# tcpSocket：发起 TCP Socket 建立成功。
		④ 创建：kubectl create -f xxx.yaml
		⑤ 查看
			kubectl get pod/po <Pod_name>：查看 Pod
			kubectl get pod/po <Pod_name> -o wide：查看 Pod 详细信息
			kubectl describe pod/po <Pod_name>
		⑥ 删除
			kubectl delete -f pod pod_name.yaml
			kubectl delete pod --all/[pod_name]
	5. Pod 分类
		① 普通 Pod：普通 Pod 一旦被创建，就会被放入到 etcd 中存储，随后会被 Kubernetes Master 调度到某个具体的 Node 上并进行绑定，随后该 Pod 对应的 Node 上
		的 kubelet 进程实例化成一组相关的 Docker 容器并启动起来。在默认情况下，当 Pod 里某个容器停止时，Kubernets 会自动检测到这个问题并重新启动这个 Pod 里面
		的所有容器，如果 Pod 所在的 Node 宕机，则会将这个 Node 上的所有 Pod 重新调度到其他节点上。
		② 静态 Pod：静态 Pod 是由 kubelet 进行管理的仅存在于特定 Node 上的 Pod，它们不能通过 API Server进行管理，无法与 ReplicationController、Deployment 或
		DaemonSet 进行关联，并且 kubelet 也无法对它们进行健康检查。
	6. Pod 生命周期和重启策略
		① Pod 状态值
			A. Pending：API Server 已经创建了该 Pod，但 Pod 中的一个或者多个容器的镜像还没有创建，包括镜像下载过程
			B. Running：Pod 内所有容器已创建，且至少一个容器处于运行状态、正在启动状态或者正在重启状态
			C. Complated：Pod 内所有容器均成功执行退出，且不会再重启
			D. Failed：Pod 内所有容器均已退出，但至少一个容器退出失败
			E. Unknown：由于某种原因无法获取 Pod 状态，例如网络通信不畅
		② Pod 的重启策略：Pod 的重启策略包括 Always、OnFailure 和 Never，默认值是 Always
			A. Always：当容器失效时，由 kubelet 自动重启该容器
			B. OnFailure：当容器终止运行且退出码不为 0 时，由 kubelet 自动重启该容器
			C. Never：不论容器运行状态如何，kubelet 都不会重启该容器
		③ 常见状态转换
			| Pod 包含的容器数 | 
			+
			|
			+
			| 
	7. 调度策略
		① 创建 Pod 流程
			
			o			+------------+	+------+	+-----------+	+---------+ 	+--------+
			-			| API Server |	| etcd |	| Scheduler |	| Kubelet |		| Docker |
			|			+------------+	+------+	+-----------+	+---------+		+--------+
		   / \				  |			   |			  |				 |				|
			|	create Pod	 +-+		   |			  |				 |				|
			| -------------> | |  write   +-+			  |				 |				|
			|				 | | -------> | |			  |				 |				|
			|				 | | <....... | |			  |				 |				|
			| <............. | |		  +-+  			  |				 |				|
			|				 +-+		   |			  |				 |				|
			|				  |		  watch(new Pod)	  |				 |				|
			|				  |	 ----------+-----------> +-+			 |				|
			|				  |			bind Pod	 	 | |			 |				|
			|				 +-+ <---------+------------ | |			 |				|
			|				 | |  write	   |			 | |			 |				|
			|    			 | | -------> +-+			 | |			 |				|
			|				 | |		  | |			 | |			 |				|
			|				 | | <....... +-+			 | |			 |				|
			|				 +-+ ..........+...........> +-+			 |				|
			|				  |			   |			  |				 |				|
			|				  |			   |  watch(bound |	Pod)		 |				|
			|				  |  ----------+--------------+-----------> +-+	Docker run	|
			|				  |			   |			  |				| | ---------> +-+
			|				  |			   |			  |				| |			   | |
			|				  |			   |  update pod  |	status		| |	<--------- +-+
			|				 +-+ <---------+--------------+------------ | |				|
			|				 | |   write   |			  |				| |				|
			|				 | | -------> +-+			  |				| |				|
			|				 | |		  | |			  |				| |				|
			|				 | | <....... +-+			  |				| |				|
			|				 +-+ ..........+..............+...........> +-+				|
			|				  |			   |			  |				| |				|
			A. 在 Master 节点中，当使用 kubectl apply -f xxx.yaml 创建 Pod 时，首先进入 API Server 中进行 Pod 的创建操作，并且在 etcd 中进行存储，接着 Scheduler 会实时监控
			API Server 是否有新的 Pod 创建，如果有，会通过 API Server 读取 etcd 新建的 Pod，并通过调度算法将 Pod 分配到某个节点中。
			B. 在 node 节点中，通过组件 kubelet 访问 API Server 读取 etcd 获取分配到当前节点的 Pod，通过 Docker 创建容器，并将创建的结果返回到 API Server，并且在 etcd 中进
			行存储。
		② 影响 Pod 调度的属性
			A. 资源限制：根据 request 找到资源足够的节点
			B. 节点选择器标签：nodeSelector
				a. 创建节点标签
					kubectl label node k8s_n1 env_role=dev
				b. 声明调度的节点
					spec:
					  nodeSelector:
					    env_role: dev
					  containers:
					    - name: liveness
					      image: busybox
				c. 查看节点
					kubectl get nodes k8s-n1 --show-labels
			C. 节点亲和性：affinity
				a. 和 nodeSelector 基本一样，根据节点上标签约束来决定 Pod 调度哪些节点上，但是功能比 nodeSelector 更强大
				b. 硬亲和性：约束条件必须满足
				c. 软亲和性：尝试满足，不保证
				d. 常用操作符：operator
					(1) In：
					(2) NotIn
					(3) Exists
					(4) Gt
					(5) Lt
					(6) DoesNotExists
 				e. 节点亲和性示例：
					apiVersion: v1
					kind: Pod
					metadata:
					  name: with-node-affinity
					spec:
					  affinity:
					    nodeAffinity:
						  requiredDuringSchedulingIgnoreDuringExecution:# 硬亲和性
						    nodeSelectorTerms:
							  - matchExpressons:
							    - key: env_role
								  operator: In
								  values:
								    - dev
									- test
						  preferredDuringSchedulingIgnoredDuringExecution:# 软亲和性
						    - weight: 1
							  preference:
							    matchExpressons:
								  - key: env_role
								    operator: In
									values:
									  - otherprod
					  containers:
					    - name: webdemo
						  image: nginx
			D. 污点和污点容忍
				a. 基本介绍：Taint 污点，节点不做普通分配调度，是节点属性
				b. 场景
					(1) 专用节点
					(2) 配置（硬件）特点
					(3) 基于 Taint 驱逐
				c. 具体演示
					(1) 查看节点污点情况
						kubectl describe node k8s-m1 | grep Taint
						# 污点值有三个：
						# NoSchedule：一定不被调度
						# PreferNoSchedule：尽量不被调度
						# NoExecute：不会调度，并且会驱逐 Node 已有 Pod
					(2) 为节点添加污点
						kubectl taint node k8s-m1 env_role=yes:NoSchedule
					(3) 删除污点
						kubectl taint node k8s-m1 env_role=yes:NoSchedule-
				d. 污点容忍：设置污点容忍后，即时是污点为NoSchedule，也有可能被调度，示例：
					apiVersion: v1
					kind: Pod
					metadata:
					  name: with-node-affinity
					spec:
					  tolerations:
					    - key: "key" # 污点的key相当于：env_role
						  operator: "Equal"
						  value: "value" # 污点的value相当于：NoSchedule
						  effect: "NoSchedule"
					  containers:
					    - name: webdemo
						  image: nginx
