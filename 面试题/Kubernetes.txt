一、Docker
	1. Docker 是什么：
		① 概念
			A. 解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。
			B. 将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子就可以一键部署好，
			大大简化了操作
		② Docker 和传统虚拟化方式的比较
			A. 传统虚拟机技术是虚拟出一套硬件，在其上运行一个完整操作系统，在该系统上运行所需要应用进程
			B. 而容器内的应用进程直接运行于宿主机的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比虚拟机更为轻便。
			C. 每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进行不会相互影响，能区分计算资源。
		③ Docker 的基本组成
			A. 镜像（Images）：
				a. Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多个容器
				b. 容器与镜像的关系类似于面向对象编程中的对象与类
			B. 容器（Container）:
				a. Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例
				b. 它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台
				c. 可以把容器看作是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间）和运行在其中的应用程序
				d. 容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一的区别在于容器的最上层是可读可写的
			C. 仓库（Repository）:
				a. 仓库（Repository）是集中存放镜像文件的场所
				b. 仓库（Repository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）
				c. 仓库分为公开仓库（Public）和私有仓库（Private）两种形式
				d. 最大的公开仓库是 Docker Hub（https://hub.docker.com/），存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云、网易云等。
		④ 小总结：需要正确地理解仓储/镜像/容器这几个概念：
			A. Docker 本身是一个容器运行载体或者称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image 镜像文件。只
			有通过这个文件才能生成 Docker 容器。image 文件可以看作是容器恶模板。Docker 根据 image 文件生成容器实例。同一个image 文件，可以生成多个同时运行的容器实例
			B. iamge 文件生成的容器实例，本身也是一个文件，称为镜像文件
			C. 一个容器运行一种服务，当我们需要的时候，就可以通过 Docker 客户端创建一个对应的运行实例，也就是我们的容器
			D. 至于仓储，就是存放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。
	2. Docker 原理
		① run 的工作流程
												----------------------------------
												| 以该镜像为模板生成容器实例运行 |
												----------------------------------
															  ↑
															 是
							-----------------				  |
			--------		|  Docker在本机 |		  --------------------		   --------------------		  ----------------------------------
			| 开始 | -----> |				| ------> | 本机是否有该镜像 |		   | 下载该镜像到本地 | ----> | 以该镜像为模板生成容器实例运行 |
			--------		|  寻找该镜像   |		  --------------------		   --------------------		  ----------------------------------
							-----------------				  |								↑
															 否							   是
															  ↓							    |
												------------------------------		 ----------------		  --------------------------------
												| 去 Docker Hub 上查找该镜像 | ----> | Hub 能否找到 | --否--> | 返回失败错误，查找不到该镜像 |
												------------------------------		 ----------------		  --------------------------------
		② Docker 是怎么工作的：Docker 是一个 Client-Server 结构的系统，Docker 守护进程运行在主机上，然后通过 Socket 连接从客户端访问，守护进程从客户端接受命令并管理运行
		在主机上的容器。
		② 为什么 Docker 比 VM 快
			A. Docker 有着比虚拟机更少的抽象层。由于 Docker 不需要 Hypervisor（连接虚拟机与宿主机的接口） 实现硬件资源虚拟化运行在 Docker 容器上的程序直
			接使用的都是实际物理机的硬件资源。因此在 CPU、内存利用率上 Docker 将会在效率上有明显优势
			B. Docker 利用的是宿主机的内核，而不需要 Guest OS（客户端操作系统），因此，当新建一个容器时，Docker 不需要和虚拟机一样重新加载一个操作系统内
			核。仍而避免引寻、加载操作系统内核返而比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载 Guest OS，返个新建过程是分钟级别的。而 
			Docker 由于直接利用宿主机的操作系统，则省略了返个过程
			C. Docker 容器与虚拟机 VM 比较
				------------------------------------------------------------------------
				|			 | Docker 容器				| 虚拟机 VM					   |
				|----------------------------------------------------------------------|
				| 操作系统 	 | 与宿主机共享 OS 			| 宿主机 OS 上运行虚拟机 OS    |
				|----------------------------------------------------------------------|
				| 存储大小	 | 镜像小，便于存储与传输	| 镜像庞大（vmdk、vdi等）	   |
				|----------------------------------------------------------------------|
				| 运行性能	 | 几乎无额外性能损失		| 操作系统额外的 CPU、内存消耗 |
				|----------------------------------------------------------------------|
				| 移植性	 | 轻便、灵活、适应于 Linux | 笨重，与虚拟化技术耦合度高   |
				|----------------------------------------------------------------------|
				| 硬件亲和性 | 面向软件开发者			| 面向硬件运维者			   |
				|----------------------------------------------------------------------|
				| 部署速度	 | 快速、秒级				| 较慢，10s 以上			   |
				------------------------------------------------------------------------
	3. Docker 常用命令
		① 帮助命令
			A. docker version：docker 的版本信息
			B. docker info：docker 的安装信息，比docker version更全面
			C. docker --help：docker 的所有的操作选项、命令和可选参数
		②  镜像命令
			A. docker images：列出本地上的镜像
			B. docker search 某个镜像的名字：从仓库上寻找某个镜像
			C. docker pull 某个镜像名字：下载镜像
			D. docker rmi 某个镜像名字或者ID：删除镜像
		③ 容器命令
			A. docker run [options] IMAGE [COMMAND][ARG...]：新建并启动容器
				a. --name="容器的名字"：为容器指定一个名称，如果没有指定，docker 会随机生成一个容器名字
				b. -d：后台运行容器，并返回容器 ID，也即启动守护式容器
				c. -i：以交互式运行容器，通常与 -t 同时使用
				d. -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用
				e. -P：随机端口映射
				f. -p：指定端口映射
			B. docker ps [options]：出当前所有正在运行的容器
				a. -a：列出当前所有正在运行的容器 + 历史上运行过的容器
				b. -l：显示最近创建的容器
			C. 使用 /bin/bash 进入容器后退出容器，两种退出方式
				a. exit：容器停止推出
				b. ctrl+P+Q：容器不停止退出
			D. 启动容器：docker start 容器 ID 或者容器名
			E. 重启容器：docker restart 容器 ID 或者容器名
			F. 停止容器：docker stop 容器 ID 或者容器名
			G. 强制停止容器：docker kill 容器 ID 或者容器名
			H. 删除已停止的容器：docker rm 容器 ID 或者容器名
				a. -f：强制删除，docker rm -f centos1219
				b. 一次性删除多个容器：
					a. docker rm -f $(docker ps -a -q)
					b. docker ps -a -q | xargs docker rm
			I. 重点：
				a. 启动守护式容器：docker run -d --name centos1219 centos
				b. 查看容器日志：docker logs -f -t --tail 容器 ID 或者容器名
				c. 查看容器内部运行的进程：docker top 容器 ID 或者容器名
				d. 查看容器内容细节：docker inspect 容器 ID 或者容器名
				e. E. 进入正在运行的容器并以命令行交互
				f. docker exec -it 容器 ID 或者容器名 bashShell，bashShell 有以下选项
					(1) /bin/bash：进入容器
					(2) ls -l /：在宿主机查看容器内部根路径的文件目录
					(3) ……
				g. 重新进入 docker attach 容器 ID 或者容器名
				h. 上述两种方式的区别
					(1) attach：直接进入容器启动命令，不会启动新的进程
					(2) exec：是在容器中打开新的终端，并且可以启动新的进程
					(3) exec 功能比 attach 强大，exec 可以进入容器内部，也可以在宿主机直接得到容器的结果，而 attach 需要先进入容器内部
				i. 从容器中拷贝文件到主机：docker cp 容器 ID 或者容器名:容器内部路径 宿主机目的路径
	4. Docker 镜像是什么：
		① 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的所有内容，包括代码、
		运行时、库、环境变量和配置文件。
		③ UnionFS（联合文件系统）
			A. UnionFS（联合文件系统）：是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将
			不同目录挂载到同一个虚拟文件系统下（unite serveral directories into a single virtual filesystem）。Union 文件系统是 Docker 镜像的
			基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。
			B. 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包括
			所有底层的文件和目录
		② Docker 镜像加载原理
			A. docekr 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统 UnionFS
			B. bootfs（boot file system）主要包含 bootloader 和 kernel（内核），bootloader 主要是引导加载 kernel，Linux 刚启动时会加载 bootfs 文
			件系统，在 Docker 镜像的最底层是 bootfs，这一层与我们典型的 Linux 和 Unix系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整
			个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，而系统也会卸载 bootfs
			C. rootfs（root file system），在 bootfs 之上。包含的就是典型 Linux 系统中的 /dev，/proc，/bin，/etc 等标准目录和文件。rootfs 就是各种
			不同操作系统发行版，比如 Ubuntu，Centos等等
			D. 平时我们安装的虚拟机的 CentOS 都是好几个G，为什么 docker 这里才 200m？对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、
			工具和程序库就可以了，因为最底层直接用 HOST 的 kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的 linux 发行版，bootfs 基本是一样
			的，rootfs 会有差别，因此不同的发行版可以用公共的 bootfs。
		④ 分层的镜像：以 pull 为例，在下载过程中可以看到 docker 的镜像好像是一层一层地在下载
		⑤ 为什么 Docker 镜像要采用这种分层结构
			A. 最大的一个好处就是共享资源
			B. 比如：有好多个系统都从相同的 base 镜像构建而来，那么宿主机只需要在磁盘上保存一份 base 镜像，同时内存中也只需要加载一份 base 镜像，就
			可以为所有容器服务了。而且镜像的每一层都可以被共享
		⑥ docker commit -m="提交的描述信息" -a="作者" 容器 ID 或者容器名 要创建的目标镜像名:[标签名]
	5. Docker容器数据卷
		① 是什么：为了能保存数据在 docker 中我们使用卷
		② 能干什么
			A. 容器的持久化
			B. 容器间继承 + 数据共享
			C. 卷就是目录或文件，存在于一个或者多个容器，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System 提供
			一些用于持续存储或共享数据的特性
			D. 卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此 Docker 不会在容器删除时删除其挂载的数据卷
			E. 特点：
				a. 数据卷可在容器之间共享或者重用数据
				b. 卷中的更改可以直接生效
				c. 数据卷中的更改不会包含在镜像的更新中
				d. 数据卷的生命周期一直持续到没有容器使用它为止
		③ 直接命令添加：docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名或者镜像 ID
		④ DockerFile添加：可在 Dockerfile 中使用 VOLUME 指令来给镜像容器添加一个或多个数据卷
		⑤ 数据卷容器：
			A. 命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器
			B. 容器间传递共享（--volumes-from）
	6. DockerFile解析
		① 是什么：Dockerfile 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。
		② 构建三步骤
			A. 编写 Dockerfile 文件
			B. docker build 命令构建镜像
			C. docker run 依镜像运行容器
		③ Docker执行Dockerfile的大致流程
			A. docker从基础镜像运行一个容器
			B. 执行一条指令并对容器作出修改
			C. 执行类似docker commit的操作提交一个新的镜像层
			D. docker再基于刚提交的镜像运行一个新容器
			E. 执行dockerfile中的下一条指令直到所有指令都执行完成
		④ DockerFile 常用保留字指令
			A. 参考tomcat8的dockerfile入门：https://github.com/docker-library/tomcat
			B. FROM：基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from
			C. MAINTAINER：镜像维护者的姓名和邮箱地址
			D. RUN
				A. 容器构建时需要运行的命令
				B. 两种格式
					a. shell格式
						(1) RUN <命令行命令> 等同于在终端操作 shell 命令。
						(2) 举例：RUN yum -y install vim
					b. exec格式
						(1) RUN ["可执行文件", "参数1", "参数2"]
						(2) 举例：RUN ["./test.php", "dev", "offline"] 等价于 ./test.php dev offline
				C. RUN 是在 Docker build 时运行的
			E. EXPOSE：当前容器对外暴露出的端口
			F. WORKDIR：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点
			G. USER：指定该镜像以什么样的用户去执行，如果都不指定，默认是root
			H. ENV：
				A. 用来在构建镜像过程中设置环境变量
				B. 举例：ENV MY_PATH /usr/mydata
				C. 说明：这个环境变量可以在后续的任何 RUN 指令中使用，这就如同在命令前面指定了环境变量前缀一样，也可以在其他指令中直接使用这些环境变量
				D. 比如：WORKDIR $MY_PATH
			I. ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包
			J. COPY：
				A. 类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路径> 位置
				B. COPY src dest
				C. COPY ["src", "dest"]
					a. <src源路径>：源文件或者源目录
					b. <dest目标路径>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。
			K. VOLUME：容器数据卷，用于数据保存和持久化工作，相当于 -v
			L. CMD：
				A. 指定容器启动后的要干的事情
					a. CMD 容器启动命令
					b. CMD 指令的格式和 RUN 相似，也是两种格式
						(1) shll 格式：CMD <命令>
						(2) exec 格式：CMD ["可执行文件", "参数1", "参数2"]
						(3) 参数列表格式：CMD ["参数1", "参数2"]，在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数
				B. 注意：
					a. Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换，如果运行容器：docker run -it -p 8080:8080 tomcat，
					则会执行 tomcat dockerfile 的 CMD ["catalina.sh", "run"] 指令，
					如果运行容器：docker run -it -p 8080:8080 tomcat /bin/bash，则不会执行 tomcat dockerfile 的 CMD ["catalina.sh", "run"] 指令
				C. 它和前面RUN命令的区别
					a. CMD是在docker run 时运行。
					b. RUN是在 docker build时运行。
			M. ENTRYPOINT：
				A. 也是用来指定一个容器启动时要运行的命令
				B. 类似于 CMD 指令，但是 ENTRYPOINT 不会被 docker run 后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序
				C. 命令格式和案例说明
					a. 命令格式：ENTRYPOINT ["<executeable>", "<param1>", "<param2>", ...]
					b. ENTRYPOINT 可以和 CMD 一起使用，一般是变参才会使用 CMD，这里的 CMD 等于是在给 ENTRYPOINT 传参。当指定了 ENTRYPOINT 后，CMD 的含义就发生了变化，
					不再是直接运行其命令而是将 CMD 的内容作为参数传递给ENTRYPOINT 
					指令，他两个组合会变成 <ENTRYPOINT> "<CMD>"
					c. 案例如下：假设已通过 DockerFile 构建了 nginx:test 镜像
						FROM nginx
						ENTRYPOINT ["nginx", "-c"] # 定参
						CMD ["/etc/nginx/nginx.conf"] # 变参
						+------------------+--------------------------------+-------------------------------------------+
						| 是否传参		   | 按照 Dockerfile 编写执行		| 传参运行 									|
						+------------------+--------------------------------+-------------------------------------------+
						| Docker 命令 	   | docker run nginx:test			| docker run nginx:test	/etc/nginx/new.conf |
						+------------------+--------------------------------+-------------------------------------------+
						| 衍生出的实际命令 | nginx -c /etc/nginx/nginx.conf | nginx -c /etc/nginx/new.conf				|
						+------------------+--------------------------------+-------------------------------------------+
	7. 网络模式
		① 总体介绍
			A. bridge模式：为每一个容器分配、设置 IP 等，并将容器连接到一个 docker0，虚拟网桥，默认为该模式。使用 --network bridge 指定，默认使用 docker0
			B. host模式：容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。使用 --network host 指定
			C. none模式：容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，IP 等。使用 --network none 指定
			D. container模式：新创建的容器不会创建自己的网卡和配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。使用 --network container:NAME或者容器 ID 指定
		② 自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通）
	8. Docker-compose容器编排
		① 是什么
			A. Docker-Compose 负责实现对Docker容器的快速编排。
			B. Compose 可以管理多个 Docker 容器组成一个应用。需要定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，
			就能同时启动/关闭这些容器
		② 能干嘛
			A. Compose 允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。
			B. 可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成构建。Docker-Compose 解决了容器与容器之间如何管理编排的问题。
		③ Compose核心概念
			A. 一文件：docker-compose.yml
			B. 两要素
				a. 服务（service）：一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器
				b. 工程（project）：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。
		④  Compose使用的三个步骤
			A. 编写Dockerfile定义各个微服务应用并构建出对应的镜像文件
			B. 使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。
			C. 最后，执行docker-compose up命令 来启动并运行整个应用程序，完成一键部署上线
	














