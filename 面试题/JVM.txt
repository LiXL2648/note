一、内存与垃圾回收	
	内存结构概述
											  +-------------------------------------------------------------------------------------+
											  |								   类加载子系统											|
											  |								Class Loader SubSystem									|
											  | +-------------------------------+		+-------------+								|
											  |	|			加载阶段			|		|	链接阶段  |								|
											  |	|			Loading				|		|	Linking	  |								|
											  | |	+-------------------------+	|		| +---------+ |								|
											  |	|	|	   引导类加载器	  	  |	|		| |  验证   | |								|
											  |	|	|   BootStrap ClassLoad   |	|		| | Verify  | |				初始化			|
						+-------------+		  |	|	+-------------------------+	|		| +---------+ |			Initialization		|
						| Class Files | ----> |	|	+-------------------------+	|		| +---------+ |		  +----------------+	|
						+-------------+		  | |	| 	   扩展类加载器	      |	| ----> | |  准备   | | ----> | 	初始化	   |	|
											  |	|	|  Extension ClassLoader  |	|		| | Prepare | |		  | Initialization |	|
											  |	|	+-------------------------+	|		| +---------+ |		  +----------------+	|
											  |	|	+-------------------------+	|		| +---------+ |								|
											  | |	|	   系统类加载器 	  |	|		| |  解析   | |								|
											  |	|	| Application ClassLoader |	|		| | Resolve | |								|
											  |	|	+-------------------------+	|		| +---------+ |								|
											  |	+-------------------------------+		+-------------+								|
											  +-------------------------------------------------------------------------------------+
																				|	↑
																				↓	|
		+-----------------------------------------------------------------------------------------------------------------------------------------------+
		|													 虚拟机栈								 PC 寄存器
		|													Stack Area								PC Registers										|
		|	+-----------+	+-----------+	+-------------+-------------+-------------+		+--------------------------+	+---------------------+		|
		|	|			|	|			|	|    线程 1	  |    线程 2	|    线程 3	  |		|   线程 1 的 PC 寄存器	   |	|					  |		|
		|	|     		|	|     	    |	|   Thread 1  |   Thread 2  |   Thread 3  |		| PC Register for Thread 1 |	|					  |		|
		|	|   	    |	|    	    |	+-------------+-------------+-------------+		+--------------------------+	|					  |		|
		|	|    	    |	|    	    |	|			  |			    |			  |		|   线程 2 的 PC 寄存器	   |	|					  |		|
		|	|	 	    |	|		    |	+-------------+-------------+-------------+		| PC Register for Thread 2 |	|					  |		|
		|	|		    |	|			|	|			  |			    |			  |		+--------------------------+	|					  |		|
		|	|	方法区	|	|	 堆		|	+-------------+-------------+-------------+		|   					   |	| 	  本地方法栈	  |		|
		|	|	Method	|	|	Heap	|	|	  栈帧	  |	    栈帧	|	  栈帧	  |		| 			……			   |	| Native Method Stack |		|
		|	|	 AREA	|	|	Area	|	| Stack Frame | Stack Frame | Stack Frame |		+--------------------------+	|					  |		|
		|	|			|	|			|	+-------------+-------------+-------------+		|   					   |	|					  |		|
		|	|			|	|			|	|	  栈帧	  |	    栈帧	|	  栈帧	  |		| 			……			   |	|					  |		|
		|	|			|	|			|	| Stack Frame | Stack Frame | Stack Frame |		+--------------------------+	|					  |		|
		|	|			|	|			|	+-------------+-------------+-------------+		|   线程 n 的 PC 寄存器	   |	|					  |		|
		|	|			|	|			|	| LV OS DL RA | LV OS DL RA | LV OS DL RA |		| PC Register for Thread n |	|					  |		|
		|	+-----------+	+-----------+	+-------------+-------------+-------------+		+--------------------------+	+---------------------+		|
		|																	  运行时数据区
		|																	Runtime Data Areas															|
		+-----------------------------------------------------------------------------------------------------------------------------------------------+
							  执行引擎		|	↑																|	↑
						  Execution Engine	↓	|																↓	|
		+-----------------------------------------------------------------------------------+			  +---------------+				+---------------+
		|				|			 即时编译器								|				|			  |				  |				|				|
		|				|			JIT Compiler							|				|			  |				  |				|				|
		|				|	+---------------------------+					|				|			  |				  |				|				|
		|				|	|	+-------------------+	|					|				|			  |				  |				|				|
		| 	  			|	|	|  中间代码生产器	|	|					|				|			  |				  |				|				|
		|				|	|	| Intermediate Code |	|					|				|			  |				  |				|				|
		|				|	|	|	  Generator 	|	|					|				|			  |				  |				|				|
		|				|	|	+-------------------+	|					|				|			  |				  |				|				|
		|				|	|			 ↓				|					|				|			  |				  |				|				|
		|				|	|	+-------------------+	|	+----------+	|	垃圾回收器	|			  |  本地方法接口 |			    |  本地方法库	|
		|	  解释器	|	|	| 	  代码优化器 	|	|	|  分析器  |	|	 Garbage	| ----------> | Native Method | ----------> | Native Method |
		|	Interpreter	|	|	|   Code Optimizer  |	|	| Profiler |	|	Collection	| <---------- |   Interface   | <---------- | 	 Library	|
		|				|	|	+-------------------+	|	+----------+	|				|			  |	   （JNI）	  |				|				|
		|				|	|			 ↓				|					|				|			  |				  |				|				|
		|				|	|	+-------------------+	|					|				|			  |				  |				|				|
		|				|	|	|  目标代码生成器 	|	|					|				|			  |				  |				|				|
		|				|	|	| 	 Target Code 	|	|					|				|			  |				  |				|				|
		|				|	|	|	  Generator  	|	|					|				|			  |				  |				|				|
		|				|	|	+-------------------+	|					|				|			  |				  |				|				|
		|				|	+---------------------------+					|				|			  |				  |				|				|
		+-----------------------------------------------------------------------------------+			  +---------------+				+---------------+
	PC 寄存器两个常见问题（面试）
		① 使用 PC 寄存器存储字节码指令地址有什么用？（为什么使用 PC 寄存器记录当前线程的执行地址？）
			A. 因为 CPU 需要不停地切换各个线程，这时候切换回来以后，就得知道接着从哪里开始继续执行。
			B. JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令
		② PC 寄存器为什么会被设定为线程私有
			A. 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差？为了能够准确地记录
			各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况
			B. 由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令
			C. 这样必然导致经常中断或恢复，如何保证分毫无差？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。
	Java 虚拟机栈
		开发中遇到的异常有哪些（面试），栈中可能出现的异常：
			a. Java 虚拟机规范允许 Java 栈的大小是动态的或者是固定不变的
			b. 如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java
			 虚拟机将会抛出一个 StackOverflowError 异常。
			c. 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个
			OutOfMemoryError 异常。
		① 举例栈溢出（StackOverFLowError）的情况
				可以通过 -Xss 设置栈地大小，当栈空间一味地加栈帧时，导致栈空间不足时，会出现栈溢出异常。
		② 调整栈大小，就能保证不出现栈溢出吗？
			不能，如果出现死循环或者递归无法终止时，无论栈大小如何调整，都无法避免栈溢出，只能让栈溢出出现地时机更晚一些
		③ 分配的栈内存越大越好吗？
			不是，因为一个线程对应一个栈，在有限的内存资源里，栈内存越大，线程数越少
		④ 垃圾回收是否会涉及到虚拟机栈？
			不会，虚拟机栈本质是一个栈，只有入栈和出栈两个操作，当方法执行结束时，栈帧就会出栈，当重新调用一个方法时，会将该方法的栈帧入栈。
		⑤ 方法中定义的局部变量是否线程安全
			A. 具体问题具体分析
			B. 线程安全
				a. 如果只有一个线程才可以操作此数据，则必须是线程安全的
				b. 如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制，会存在线程安全问题 
			C. 如果变量是在方法中产生和消亡，则是线程线程安全的；如果变量不是在方法中产生或者消亡，则是线程线程不安全的
	对象的内存布局
		① 对象头（Header）
			A. 包含两部分
				a. 运行时元数据（Mark World）
					(1) 哈希值（HashCode）
					(2) GC分代年龄
					(3) 锁状态标志
					(4) 线性持有的锁
					(5) 偏向线程 ID
					(6) 偏向时间戳  
				b. 类型指针：指向类元数据 InstanceKlass，确定该对象所属的类型
			B. 说明：如果是数组，还需记录数组的长度
		② 实例数据（Instance Data）
			A. 说明：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）
			B. 规则
				a. 相同宽度的字段总是被分配在一起
				b. 父类中定义的变量会出现在子类之前
				c. 如果 CompactFields 参数为 true（默认为 true），子类的窄变量可能插入到父类变量的空隙
		③ 对齐填充（Padding）：不是必须的，也没有特别含义，仅仅起到占位符的作用
	Minor GC、Major GC、Full GC
		① JVM 在进行 GC 时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代
		② 针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Pertial GC），一种是整堆收集（Full GC）
			A. 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：
				a. 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集
				b. 老年代收集（Major GC / Old GC）：只是老年代的垃圾收集
					(1) 目前，只有 GMS GC 会有单独收集老年代的行为
					(2) 注意，很对时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收
				c. 混合收集（Mixed GC）：收集整个新生代以及部分部分老年代的垃圾收集，目前只有 G1 GC 会有这种行为
			B. 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集
		③ 最简单的分代式 GC 策略的触发条件
			A. 年轻代 GC（Minor GC）触发机制：
				a. 当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。（每次 Minor GC 会清理年轻代的内存）
				b. 因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解
				c. Minor GC 会引发 STW，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行。
			B. 老年代 GC（Major GC/Full GC）触发机制：
				a. 指发生在老年代的 GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了
				b. 出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。
				也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还是不足，则触发 Major GC
				c. Major GC 的速度一般会比 Minor GC 慢十倍以上，STW 的时间更长
				d. 如果 Major GC 后，内存还不足，就报 OOM 了。
			C. Full GC 触发机制（触发 Full GC 执行的情况有如下五种）：
				a. 调用 System.gc() 时，系统建议执行 Full GC，但是不必然执行
				b. 老年代空间不足
				c. 方法区空间不足
				d. 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存
				e. 由 Eden区、Survivor space0（From Space）区向 Survivor space1（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，
				且老年代的可用内存小于该对象大小
				f. 说明：Full GC 是开发或者中尽量要避免的。这样暂时时间会短一些
	堆空间分代思想
		① 经研究，不同对象的生命周期不同。70%-99% 的对象是临时对象
			A. 新生代：有 Eden、两块大小相同的 Survivor（又称为 from/to，S0/S1）构成，To 总为空
			B. 老年代：存放新生代中经历多次 GC 仍然存活的对象
		② 其实不分代完全可以，分代的唯一理由就是优化 GC 性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC 的时候要找到哪些对象
		没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一个地方，当 GC 的时候先把这块存储“朝生夕死”对象的区
		域进行回收，这样就会腾出很大的空间出来
	7. 内存分配策略
		① 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且将对象年龄设为 1。对象在 Survivor
		区中每熬过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁，其实每个 JVM、每个 GC 都有所不同）时，就会被晋升到老年代中。
		② 对象晋升老年代的年龄阈值，可以通过选项 -XX:MaxTenuringThreshold 来设置
		③ 针对不同年龄段的对象分配原则如下所示：
			A. 优先分配到 Eden
			B. 大对象直接分配到老年代，尽量避免程序中出现过多的大对象
			C. 长期存活的对象分配到老年代
			D. 动态对象年龄判断，如果 Survivor 区中相同年龄的所有对象大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到
			MaxTenuringThreshold 中要求的年龄
			E. 空间分配担保：-XX:HandlePromotionFailure
	8. 为对象分配内存：TLAB
		① 为什么有 TLAB（Thread Local Allocation Buffer）
			A. 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
			B. 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
			C. 为避免多个线程操作同一地址，需要使用加锁机制，进而影响分配速度
		② 什么是 TLAB
			A. 从内存模型而不是垃圾收集的角度，对 Eden 区域继续划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内
			B. 多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此可以将这种内存分配方式称之为快速分配策略
			C. 所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计
		③ TLAB 的再说明：
			A. 尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，担 JVM 确实是将 TLAB 作为内存分配的首选
			B. 在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启 TLAB 空间
			C. 默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，当然可以通过选项“-XX:TLABWasteTargetPercent”设置 TLAB 空间所占用 Eden 空间的百分比
			大小。
			S. 一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。
	垃圾回收相关算法
		GC Roots：在 Java 语言中，GC Roots 包括以下几类元素
			A. 虚拟机栈中引用的对象。比如：各个线程被调用的方法中使用到的参数、局部变量等
			B. 本地方法栈内 JNI（通常说本地方法）引用的对象
			C. 方法区中类静态属性引用的对象。比如：Java 类的引用类型静态变量
			D. 方法区中常量引用的对象。比如：字符串常量池（String Table）里的引用
			E. 所有被同步锁 synchronizde 持有的对象
		标记阶段
			引用技术算法
			可达性分析算法
		清除阶段
			标记-清除算法
			复制算法
			清除阶段：标记-压缩算法
	垃圾回收相关概念
		再谈引用
			a. 强引用（Strong Reference）：最传统的“引用”的定义，是指在程序代码中普遍存在的引用赋值，即类似“Object obj = new Object()”这种引用关系。无论任
				何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象
				b. 软引用（Soft Reference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛
				出内存溢出异常
				c. 弱引用（Weak Reference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联
				的对象
				d. 虚引用（Phantom Reference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置
				虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知
		内存泄露（Memory Leak）
			A. 也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是 GC 又不能回收它们的情况下，才叫内存泄露
			B. 但实际情况很多时候一些不太友好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 OOM，也可以叫做宽泛意义上的“内存泄露”
			C. 尽管内存泄露并不会立刻引起程序奔溃，但是一旦发生内存泄露，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OOM，导致程序奔溃
			D. 注意，这里的存储空间并不是指物理内存，而是指虚拟机内存大小，这个虚拟机内存大小取决于磁盘交换区设定的大小
	垃圾回收器
		垃圾收集器的组合关系
			+-----------------------------------------------------------------------------------------------+
			|				+-----------+		+-----------+		+----------------------+				|
			| Young Gen		| Serial GC |		| ParNew GC |		| Parallel Scavenge GC |	+------+	|
			|				+-----------+		+-----------+		+----------------------+	|  G1  |	|
			|					| |					| |						|					|	   |	|
			|		JDK8 中取消 | |					| |	JDK8 中取消			|					|	   |	|
			|					| +---------------+ | |						|					|	   |	|
			+-------------------+-----------------+-+-+---------------------+-------------------+------+----+
			|					| +---------------+-+ | +-------------------+					|	   |	|
			|					| |				  |   |	|					|					|	   |	|
			|				+--------+		+---------------+		+-----------------+			|  GC  |	|
			| Old Gen		| CMS GC | ---- | Serial Old GC |		| Parallel Old GC |			+------+	|
			|				+--------+		+---------------+		+-----------------+						|
			|						后备方案																|
			+-----------------------------------------------------------------------------------------------+
			A. 两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、
			Parallel Scavenge/Parallel Old、G1
			B. 其中 Serial Old 作为 CMS 出现“Concurrent Mode Failure”失败的后备预案
			C. 由于维护和兼容性测试的成本，在 JDK8 时将 Serial/CMS、ParNew/Serial Old 这两个组合声明为废弃（JEP 173），并在 JDK9 中完全取消了这些组合的支持
			（JEP214），即：移除
			D. JDK14 中：弃用 Parallel Scavenge/Serial Old 组合（JEP 366）
			E. JDK14 中：删除 CMS 垃圾回收器（JEP 363）
	Serial 回收器：串行回收
		① 概述
			A. Serial 收集器是最基本、历史最悠久的垃圾收集器。JDK1.3 之前回收新生代唯一的选择
			B. Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾收集器
			C. Serial 收集器采用复制算法、串行回收和“Stop-the-World”机制的方式执行内存回收
			D. 除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。Serial Old 收集器同样也采用了串行回收和“Stop-the-World”机制，
			只不过内存回收算法使用的是标记-压缩算法
				a. Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器
				b. Serial Old 在 Server 模式下主要有两个用途
					(1) 与新生代的 Parallel Scavenge 配合使用
					(2) 作为老年代 CMS 收集器的后备垃圾收集方案
			+-------------------------------------------------------------------------------------------------------------------+
			|			用户线程 1	   |				  	|	 用户线程 1	    |				  	  |		用户线程 1	  |		|
			|	CPU0 ----------------> |				  	| ----------------> |				 	  |	----------------> |		|
			|			用户线程 2	   |	 GC 线程	  	|	 用户线程 2	    |		GC 线程  	  |		用户线程 2	  |		|
			|	CPU1 ----------------> | -----------------> | ----------------> | ------------------> |	----------------> |		|
			|			用户线程 3	   | 新生代采取复制算法 |	 用户线程 3	    | 老年代采取标记-压缩 |		用户线程 3	  |		|
			|	CPU2 ----------------> | 暂停所有用户线程  	| ----------------> | 算法 				  |	----------------> |		|
			|			用户线程 4	   |				  	|	 用户线程 4	    | 暂停所有用户线程	  |		用户线程 4	  |		|
			|	CPU3 ----------------> |				  	| ----------------> |				  	  |	----------------> |		|
			|					  Safepoint									  Safepoint											|
			|										Serial/Serial Old 垃圾收集器												|
			+-------------------------------------------------------------------------------------------------------------------+
			E. 这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或者一条收集线程去完成垃圾收集工作，更重要的是在它进行
			垃圾收集时，必须暂停其他所有的工作，直到它收集结束（Stop-the-World）
			F. 优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得
			最高的单线程效率。运行在 Client 模式下的虚拟机是个不错的选择
			G. 在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至 一百多 ms），主要不频繁发生，使
			用串行回收器是可以接受的
			H. 在 HotSpot 虚拟机中，使用 -XX:+UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用 Serial GC，且老年代用 Serial Old GC
		② 总结
			A. 这种垃圾收集器现在已经不用了，而且在限定单核 CPU 才可以使用。但是现在都已经不是单核的了
			B. 对于交互强的应用而言，这种垃圾收集器是不能接受的。一般在 Java Web 应用程序中是不会采用串行垃圾收集器的
	ParNew 回收器：并行回收
		① 如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。Par 是 Parallel 的缩写，New：只能处理新生代
		② ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用复制算法、“Spot-the-
		World”机制
		③ ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器
			+-------------------------------------------------------------------------------------------------------------------+
			|			用户线程 1	   |	 GC 线程	  	|	 用户线程 1	    |				  	  |		用户线程 1	  |		|
			|	CPU0 ----------------> | -----------------> | ----------------> |				 	  |	----------------> |		|
			|			用户线程 2	   |	 GC 线程	  	|	 用户线程 2	    |		GC 线程  	  |		用户线程 2	  |		|
			|	CPU1 ----------------> | -----------------> | ----------------> | ------------------> |	----------------> |		|
			|			用户线程 3	   |  	 GC 线程		|	 用户线程 3	    | 老年代采取标记-压缩 |		用户线程 3	  |		|
			|	CPU2 ----------------> | ----------------->	| ----------------> | 算法 				  |	----------------> |		|
			|			用户线程 4	   | 新生代采取复制算法	|	 用户线程 4	    | 暂停所有用户线程	  |		用户线程 4	  |		|
			|	CPU3 ----------------> | 暂停所有用户线程	| ----------------> |				  	  |	----------------> |		|
			|					  Safepoint									  Safepoint											|
			|										ParNew/Serial Old 垃圾收集器												|
			+-------------------------------------------------------------------------------------------------------------------+
		④ 对于新生代，回收次数频繁，使用并行方式高效
		⑤ 对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）
		⑥ 由于 ParNew 收集器是基于并行回收的，那么是否可以判定 ParNew 收集器的回收效率在任何场景下都会比 Serial 收集器更高效？
			A. ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量
			B. 但是在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因
			此可以有效避免多线程交互过程中产生的一些额外开销。
		⑦ 因为除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作
	Parallel 回收器：吞吐量优先
		① 概述
			A. HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样采用了复制算法、并行回收和“Stop-the-world”机制
			B. 那么 Parallel 收集器的出现是否多此一举
				a. 和 ParNew 收集器不同，Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的额垃圾收集器
				b. 自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别
			C. 高吞吐量则可以高效地利用 CPU 时间，尽快完成程序地运算任务，主要适合在后台运算而不需要太多交互任务。因此，常见在服务器环境在中使用。例如：
			那些执行批量处理、订单处理、工资支付、科学计算的应用程序
			D. Parallel 收集在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器
			E. Parallel Old 收集器采用了标记-压缩算法，但同样也是基于并行回收和“Stop-the-World”机制
			+-------------------------------------------------------------------------------------------------------------------+
			|			用户线程 1	   |	 GC 线程	  	|	 用户线程 1	    |		GC 线程  	  |		用户线程 1	  |		|
			|	CPU0 ----------------> | -----------------> | ----------------> | ------------------> |	----------------> |		|
			|			用户线程 2	   |	 GC 线程	  	|	 用户线程 2	    |		GC 线程  	  |		用户线程 2	  |		|
			|	CPU1 ----------------> | -----------------> | ----------------> | ------------------> |	----------------> |		|
			|			用户线程 3	   |  	 GC 线程		|	 用户线程 3	    | 老年代采取标记-压缩 |		用户线程 3	  |		|
			|	CPU2 ----------------> | ----------------->	| ----------------> | 算法 				  |	----------------> |		|
			|			用户线程 4	   | 新生代采取复制算法	|	 用户线程 4	    | 暂停所有用户线程	  |		用户线程 4	  |		|
			|	CPU3 ----------------> | 暂停所有用户线程	| ----------------> |				  	  |	----------------> |		|
			|					  Safepoint									  Safepoint											|
			|										Parallel Scavenge/Parallel Old 垃圾收集器									|
			+-------------------------------------------------------------------------------------------------------------------+
			F. 在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错
			G. 在 Java8 中，默认是此垃圾收集器
	CMS 回收器：低延迟
		① 概述
			A. 在 JDK1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是 HotSpot
			虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作
			B. CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。目
			前很大一部分的 Java 应用集中在互联网或者 B/S 系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。
			CMS 收集器就非常符合这类应用的需求
			C. CMS 的垃圾收集算法采用“标记-清除算法”，并且也会“Stop-the-World”
			D. 不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年
			代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个
			E. 在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC
		② CMS 的工作原理
			+---------------------------------------------------------------------------------------------------------------------------------------+
			|			用户线程1		|					| 	  用户线程1		 |		重新标记	  | 	用户线程1	   | 	 用户线程1	    |	|
			|	CPU0 -----------------> |					| -----------------> | -----------------> | -----------------> | -----------------> |	|
			|			用户线程2		|					|	  用户线程2		 |		重新标记	  |	    用户线程2	   |	 用户线程2		|	|
			|	CPU0 -----------------> |	  初始标记		| -----------------> | -----------------> | -----------------> | -----------------> |	|
			|			用户线程3		| ----------------> |	  并发标记		 |		重新标记	  |	    并发清除	   |	 重置线程	    |	|
			|	CPU0 -----------------> |					| -----------------> | -----------------> | -----------------> | -----------------> |	|
			|			用户线程4		|					|	  用户线程4		 |		重新标记	  |		用户线程4	   |	 用户线程4		|	|
			|	CPU0 ----------------->	|					| -----------------> | -----------------> | -----------------> | -----------------> |	|
			|															Concurrent Mark Sweep 收集器												|
			+---------------------------------------------------------------------------------------------------------------------------------------+
			A. CMS 整个过程比之前的收集器要复杂，整个过程分成 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段
				a. 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅
				只是标记出 GC Roots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快
				b. 并发标记（Concurrent-Mark）阶段：从 GC Roots 的直接关联对象开始遍历整个对象图大的过程，这个过程耗时较长但是不需要停顿用户线程，可以与
				垃圾收集线程一起并发运行
				c. 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户线程
				继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段大的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短
				d. 并发清除（Concurrent-Sweep）阶段：此阶段清理删除标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可
				以与用户线程同时并发的
		③ 分析
			A. 尽管 CMS 收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不
			过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间
			B. 由于最耗费时间地并发标记与并发清除阶段都不需要暂停工作，所以整体地回收是低停顿的。
			C. 另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS 收集器不能像其他收集
			器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间
			支持应用程序运行。要是 CMS 运行期间预留得到内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用
			Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了
			D. CMS 收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存极有可能是不连续的一些
			内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能选择空闲列表（Free
			List）执行内存分配
			E. 既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact？其实很简单，因为当并发清除时，用 Compact 整理内存的话，原来的用户线程使
			的内存就用不了。要保证用户线程能继续执行，前提得它运行得资源不受影响。Mark Compact 更适合“Stop the World”这种场景下使用
		④ CMS 的优点：
			A. 并发收集
			B. 低延迟
		⑤ CMS 的弊端
			A. 会产生内存碎片：导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 Full GC
			B. CMS 收集器对 CPU 资源非常敏感：在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低
			C. CMS 收集器无法处理浮动垃圾：可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程
			是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回
			收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间
	G1 回收过程	
		E. 年轻代 GC
			a. JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程
			b. 年轻代垃圾回收只会回收 Eden 区和 Survivor 区
			c. YGC时，首先 G1 停止应用程序的执行（Stop-the-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的
			回收集包含年轻代 Eden 区和 Survivor 区所有的到内存分段
			d. 然后开始如下回收过程
				(1) 第一阶段，扫描根：根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象入口
				(2) 第二阶段，更新 RSet：处理 dirty card queue（脏卡表：对于应用程序的引用赋值语句 object.field = object，JVM 会在之前和之后执行特殊的操作以
				在 dirty card queue 中入队一个保存了对象引用信息的 card。在年轻代回收的时候，G1 会对 Dirty Card Queue 中所有的 card 进行处理，以更新 RSet，
				保证 Reset 实时准确的反映引用关系。那为什么不在引用赋值语句处直接更新 RSet，这是为了性能的需求，RSet 的处理需要线程同步，开销会很大，使用队列
				性能会好很多）中的 card，更新 RSet。此阶段完成后，RSet 可以准确的反映老年代对所在的内存分段中对象的引用
				(3) 第三阶段，处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活对象
				(4) 第四阶段，复制对象：此阶段，对象数被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存分段中存活的对象
				年龄如果未达到阈值，年龄会加1，达到阈值会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间
				(5) 第五阶段，处理引用：处理 Soft、Weak、Phantom、Final、JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续
				存储的，没有碎片，所以复制过程可以达到内存管理的效果，减少碎片
		F. 并发标记过程
			a. 初始标记阶段：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC
			b. 根区域扫描（Root Region Scanning）：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 Young GC 之前完成
			c. 并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 Young GC 中断。在并发标记阶段，若发现区域对象中的所
			有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）
			d. 再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning
			（SATB）
			e. 独占清理（Cleanup，STW）：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下个阶段做准备。是 STW 的。这个阶段并不会
			实际上区做垃圾的收集
			f. 并发清理阶段：识别并清理完全空闲的区域
		G. 混合回收
			a. 当越来越多的对象晋升到老年代 Old Region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，集 Mixed GC，该算法并不是一个 Old GC，除了
			回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选哪些 Old Region 进行收集，从而可以对哪些
			Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC
			b. 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过
			“-XX:G1MixedGCCountTarget 设置”）被回收
			c. 混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，
			只是回收集多了老年代的内存分段。具体过程参照上面的年轻代回收过程
			d. 由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否
			被回收，“-XX:G1MixedGCLiveThresholdPercent”，默认为 65%，意思是垃圾占内存分段比例要达到 65% 才会被回收。如果垃圾占比太低，意味着存活的对象占比高，
			在复制的时候会花费更多时间
			e. 混合回收并不一定要进行 8 次。有一个阈值“-XX:G1HeapWastePercent”，默认值为 10%，意思是允许整个堆内存中有 10% 的空间被浪费，意味着如果发现可以回
			收垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。
		H. Full GC
			a. G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-the-World），使用单线程的内存回收算法进行垃圾回
			收，性能会非常差，应用程序停顿时间会很长。
			b. 要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回
			退到 Full GC，这种情况可以通过增大内存解决
			c. 导致 G1 Full GC 的原因可能有两个
				(1) Evacuation（回收阶段） 的时候没有足够的 to-space 来存放晋升的对象
				(2) 并发处理过程完成之前空间耗尽
			
字节码与类加载
	1. Class 文件的总体结构如下：
		a. 魔数
		b. Class 文件版本
		c. 常量池
		d. 访问标记
		e. 类索引，父类索引，接口索引集合
		f. 字段表集合
		g. 方法表集合
		h. 属性表集合
	2. JVM 中的字节码指令集按用途大致分成 9 类
		a. 加载与存储指令
			a. （局部变量压栈指令）将一个局部变量加载到操作数栈：xload、xload_<n>（其中 x 为 i、l、f、d、a，n 为 0 到 3）
			b. （常量入栈指令）将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_nul、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d>
			c. （出栈装入局部变量表指令）将一个数值从操作数栈存储到局部变量表：xstore、xstore_<n>（其中 x 为 i、l、f、d、a，n 为 0 到 3）；xastore（其中 x 为 i、
			l、f、d、a、b、c、s）
			+-----------------------------------+----------+-------------------------------+
			| 类型								| 常用指令 | 范围			  			   |
			+-----------------------------------+----------+-------------------------------+
			| int（boolean、byte、char、short） | iconst   | [-1, 5]					   |
			|									| bipush   | [-128, 127]				   |
			|									| sipush   | [-32768, 32767]			   |
			|									| ldc	   | any int value				   |
			+-----------------------------------+----------+-------------------------------+
			| long								| lconst   | 0 和 1						   |
			|									| ldc	   | any long value				   |
			+-----------------------------------+----------+-------------------------------+
			| float								| fconst   | 0，1 和 2					   |
			|									| ldc	   | any float value			   |
			+-----------------------------------+----------+-------------------------------+
			| double							| dconst   | 0 和 1						   |
			|									| ldc	   | any double value			   |
			+-----------------------------------+----------+-------------------------------+
			| reference							| aconst   | null						   |
			|									| ldc	   | String literal，Class literal |
			+-----------------------------------+----------+-------------------------------+
		b. 算术指令
			A. 加法指令：iadd、ladd、fadd、dadd
			B. 减法指令：isub、lsub、fsub、dsub
			C. 乘法指令：imul、lmul、fmul、dmul
			D. 除法指令：idiv、ldiv、fdiv、ddiv
			E. 求余指令：irem、lrem、frem、drem		// remainder：余数
			F. 取反指令：ineg、lneg、fneg、dneg		// negation：取反
			G. 自增指令：iinc
			H. 位运算指令，又可分为：
				a. 位移指令：ishl、ishr、iushr、lshl、lshr、lushr
				b. 按位或指令：ior、lor
				c. 按位与指令：iand、land
				d. 按位异或指令：ixor、lxor
			I. 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp
		c. 类型转换指令
			宽化类型转换
				从 int 类型到 long、fload 或者 double 类型。对应的指令为：i2l、i2f、i2d
				b. 从 long 类型到 float 或者 double 类型。对应的指令为：l2f、l2d
				c. 从 float 类型到 double 类型。对应的指令为：f2d
				d. 简化为：int --> long --> float --> double
			窄化类型转换	
				从 int 类型至 byte、short 或者 char 类型。对应的指令有：i2b、i2s、i2c
				b. 从 long 类型到 int 类型。对应的指令有：l2i
				c. 从 float 类型到 int 或者 long 类型。对应的指令有：f2i、f2l
				d. 从 double 类型到 int、long 或者 float 类型。对应的指令有：d2i、d2l、d2f
		d. 对象的创建与访问指令
			创建指令
				创建类实例的指令：new
				创建数组的指令
					a. 创建数组的指令：newarray、anewarray、multianewarray
					b. newarray：创建基本数据类型数组
					c. anewarray：创建引用类型数组
					d. multianewarray：创建多维数组
			字段访问指令
				A. 对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素
				a. 访问字段（static 字段，或者称为类变量）的指令：getstatic、putstatic
				a. 访问类实例字段（非 static 字段，或者称为实例变量）的指令：getfield、putfield
			数组操作指令
				A. 数组操作指令主要有：xastore 和 xaload 指令。具体为
				a. 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload
				b. 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore
				c. 取数组长度指令：arraylength。该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈
			检查类实例或数组类型的指令：instanceof、checkcast
				a. 指令 checkcast 用于检查类型强制转换是否可以进行。如果可以进行，那么 checkcast 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常。
				b. 指令 instanceof 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈
		e. 方法调用与返回指令
			① 方法调用指令	
				A. 方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic
				B. 以下 5 条指令用于方法调用：
					a. invokevirtual：指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是 Java 语言中最常见的方法分派方式
					b. invokeinterface：指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用
					c. invokespecial：指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会在
					调用时进行动态派发
					d. invokestatic：指令用于调用命名类中的类方法（static 方法）。这是静态绑定的
					e. invokedynamic：调用动态绑定的方法，这个是 JDK1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面 4 条调用
					指令的分派逻辑都固化在 Java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的
			② 方法返回指令：
				A. 方法调用结束前，需要进行返回。方法返回指令是根据返回值类型区分的
					a. 包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、dreturn 和 areturn
					b. 另外还有一条 return 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法（代码块）使用
		f. 操作数栈管理指令
			A. 将一个或两个元素从栈顶弹出，并直接废弃：pop、pop2
			B. 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2
			C. 将栈最顶端的两个 Slot 数值位置交换：swap。Java 虚拟机没有提供交换两个 64 位 数据类型（long、double）数值的指令
			D. 指令 nop，是一个非常特殊的指令，它的字节码 0x00。和汇编语言中的 nop 一样，它表示什么都不做。这条指令一般可用于调试、占位等。
			E. 这些指令属于通用型，对栈的压入或者弹出无需指明数据类型
		g. 比较控制指令
			条件跳转指令：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull。
			比较条件跳转指令：if_icmpeq、if_icmpne、if_icmplt、if_icmple、if_icmpgt、if_icmpge、if_acmpeq、if_acmpne
			多条件跳转指令
				A. 多条件分支跳转指令是专为 switch-case 语句设计的，主要有 tableswitch 和 lookupswitch
					+--------------+-------------------------------------+
					| 指令名称	   | 描述								 |
					| tableswitch  | 用于 switch 条件跳转，case 值连续	 |
					| lookupswitch | 用于 switch 条件跳转，case 值不连续 |
					+--------------+-------------------------------------+
			条件跳转指令
				A. 目前主要的无条件跳转指令为 goto。指令 goto 接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定
				的位置处。
				B. 如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令 goto_w，它和 goto 有相同的作用，但是它接收 4 个字节的操作数，可以表示更大的地址范围
		h. 异常处理指令
			抛出异常指令：athrow
			异常处理与异常表
				A. 异常处理：在 Java 虚拟机中处理异常（catch 语句）不是由字节码指令来实现的（早期使用 jsr、ret 指令），而是采用异常表来完成的。
				B. 异常表
					a. 如果一个方法定义了一个 try-catch 或者 try-finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者 finally 块的信息。异常表保存了每个异
					常处理信息。比如：
						(1) 起始位置
						(2) 结束位置
						(3) 程序计数器记录的代码处理的偏移地址
						(4) 被捕获的异常类在常量池中的索引
		i. 同步控制指令
			monitorenter 和 monitorexit
	3. 类的加载过程（类的生命周期）
		① 加载（Loading）阶段
			A. 加载的理解
				a. 所谓加载，简而言之就是将 Java 类的字节码文件加载到机器内存中，并在内存中构建出 Java 类的原型——类模板对象。所谓类模板对象，其实就是 Java 类在 JVM 内存
				中的一个快照，JVM 将从字节码文件中解析出常量池、类字段、类方法等信息存储到类模板中，这样 JVM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 
				Java类的成员变量进行遍历，也能进行 Java 方法的调用
				b. 反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射
			B. 加载完成的操作
				a. 加载阶段，简而言之，查找并加载类的二进制数据，生成 Class 的实例
				b. 在加载类时，Java 虚拟机必须完成以下三件事情
					(1) 通过类的全名，获取类的二进制数据流
					(2) 解析类的二进制数据流为方法区内的数据结构（Java 类模型）
					(3) 创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口
		② 链接（Linking）阶段
			A. 链接阶段之验证（Verification）环节
				a. 当类加载到系统后，就开始链接操作，验证是链接操作的第一步
				b. 它的目的是保证加载的字节码是合法、合理并符合规范的
				c. 验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示
									  +-  +----------------------------------+
					+--------------+  |	  |				 魔数检查			 |
					|   格式检查   | -+   |				 版本检查			 |
					+--------------+  |   |    			 长度检查			 |
							|		  +-  +----------------------------------+
							|
							↓		  +-  +----------------------------------+
					+--------------+  |	  |    		  是否继承final			 |
					|   语义检查   | -+   |    			是否有父类			 |
					+--------------+  |   |        抽象方法是否有实现		 |
							|		  +-  +----------------------------------+
							|		  
							↓		  +-  +----------------------------------+
					+--------------+  |	  |    跳转指令是否指向正确的位置    |
					|  字节码验证  | -+   |       							 |
					+--------------+  |   |        操作数类型是否合理		 |
							|		  +-  +----------------------------------+
							|		  
							↓		  +-  +----------------------------------+
					+--------------+  |	  |       							 |
					| 符号引用验证 | -+   |    符号引用的直接引用是否存在    |
					+--------------+  |   |        							 |
									  +-  +----------------------------------+
			B. 链接阶段之准备（Preparation）环节：为类的静态变量分配内存，并将其初始化为默认值
			C. 链接阶段之解析（Resolution）环节：将类、接口、字段和方法的符号引用转为直接引用
		③ 初始化（Initialization）阶段
			A. 为类的静态变量赋予正确的初始值。
			B. Java 编译器并不会为所有的类都产生<clinit>() 初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含<clinit>() 方法？
				a. 一个类中并没有声明任何的类变量，也没有静态代码块时
				b. 一个类中声明了类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时
				c. 一个类中包含 static final 修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式
			C. static 与 final 的搭配问题
				A. 说明：使用 static + final 修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值
				B. 代码举例：
					public static int num = 1; // 在初始化阶段的 <clinit>() 方法中赋值
					public static final int NUM_CONST = 2; // 在链接阶段的准备环节进行显式赋值
					public static Integer integerNum = 3; // 在初始化阶段的 <clinit>() 方法中赋值
					public static final Integer INTEGER_NUM = 4; // 在初始化阶段的 <clinit>() 方法中赋值
					public static final String STRING0 = "helloworld0"; // 在链接阶段的准备环节进行显式赋值
					public static final String STRING1 = new String("helloworld1"); // 在初始化阶段的 <clinit>() 方法中赋值
					public static final int NUM_CONST1 = new Random().nextInt(10); // 在初始化阶段的 <clinit>() 方法中赋值
				C. 结论：
					a. 在链接阶段的准备环节赋值的情况：
						(1) 对于基本数据类型的字段来说，如果使用 static final 修饰，并显式赋值（赋值常量）
						(2) 对于 String 类型来说，如果使用字面量的方式进行显式赋值，并且使用 static final 修饰
					b. 在初始化阶段的 <clinit>() 方法中赋值的情况
						(1) 对于基本数据类型的字段来说，使用 static final 修饰，但是使用方法调用的方式进行显式赋值
						(2) 对于 String 类型来说，使用 static final 修饰，但是使用构造器调用的方式进行显式赋值
				D. 最终结论：使用 static + final 修饰，并且赋值时不涉及方法或者构造器调用的基本数据类型或者 String 类型的显式赋值，则是在链接阶段的准备环节进行的。
			D. 类的初始化情况：主动使用 VS 被动使用
				主动使用
				a. 当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化
				b. 当调用类的静态方法时，即当使用了字节码 invokestatic 指令
				c. 当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量、赋值变量操作）
				d. 当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forName("com.li.Test")
				e. 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
				f. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。
				g. 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。
				被动使用
				当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。当通过子类引用父类的静态变量，不会导致子类的初始化
				当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。当通过子类引用父类的静态变量，不会导致子类的初始化				
				引用常量（字面量）不会触发此类或者接口的初始化，因为常量在链接阶段就已经被显式赋值了。（除非常量是在调用 <clinit>() 时进行赋值的）
				调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化
				总结：主动使用会调用 <clinit>() 方法，进而进行类的初始化（Initialization）阶段，而被动调用不会调用 <clinit>() 方法，进而没有进行类的初始化
				（Initialization）阶段，没有初始化不代表没有进行加载
		④ 过程四：类的使用（Using）：任何一个类型在使用之前都必须经历过完整的加载、链接和初始化三个类加载步骤。
		⑤ 类的卸载（Unloading）
			需要同时满足以下三个条件：
				a. 该类所有的实例都已经被回收。也就是 Java 堆中不存在该类及任何派生子类的实例
				b. 加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替代类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的
				c. 该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法
	4. 类的加载器
		① 概述
			A. 类加载器是 JVM 执行类加载机制的前提
			B. ClassLoader 的作用：ClassLoader 是 Java 的核心组件，所有的 Class 都是由 ClassLoader 进行加载的，ClassLoader 负责通过各种方式将 Class 信息的二进制数据流读
			流读入 JVM 内部，转换为一个与目标类对应的 java.lang.Class 对象实例。然后交给 Java 虚拟机进行链接、初始化等操作。因此，ClassLoader 在整个装载阶段，只能影响到
			类的加载，而无法通过 ClassLoader 去改变类的链接和初始化行为，至于它是否可以运行，则由 Execution Engine（执行引擎）决定
		② 类的加载器分类
			A. 引导类加载器（引导类加载器，Bootstrap ClassLoader），只加载包名为 java、javax、sun 等开头的类
			B. 扩展类加载器，从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jar/lib/ext 子目录下加载类库
			C. 系统类加载器
			D. 用户自定义类加载器
		③ 双亲委派模型
			A. 如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类的
			加载任务，就成功返回。只有父类加载器无法完成此加载任务，才会自己去加载
			B. 双亲委派机制优势
				a. 避免类的重复加载，确保一个类的全局唯一性。Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父类加载器
				已经加载了该类时，就没有必要子类加载器再加载一次
				b. 保护程序安全，防止核心 API 被随意篡改
			C. 双亲委派模式的弊端
				a. 检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个 ClassLoader 的职责非常明确，但是同时会带来一个问题，即顶层的 ClassLoader 无法
				访问底层的 ClassLoader 所加载的类
				b. 通常情况下，启动类加载器中的类为系统的核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题的，但
				是系统类访问应用程序类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用程序类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接
				口和工厂方法都在启动类加载器中，这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。
		④ 破坏双亲委派机制
			A. 第一次破坏双亲委派机制：双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前
			B. 第二次破坏双亲委派机制：线程上下文类加载器
			C. 第三次破坏双亲委派机制：双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。
		⑤ 沙箱安全机制
			Java 安全模型的核心就是 Java 沙箱（sandbox），沙箱是一个限制程序运行的环境
			沙箱机制就是将 Java 代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造
			成破坏。
			 沙箱主要限制系统资源访问，CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样
三性能监控与调优
	1. 性能优化的步骤
		① 第 1 步（发现问题）：性能监控
			A. 描述
				a.一种以非强行或者入侵方式收集或者查看应用运营性能数据的活动
				b. 监控通常是指一种在生产、质量评估或者开发环境下实施的带有预防或主动性的活动
				c. 当应用相罐干系人提出性能问题却没有提供足够多的线索时，首先需要进行性能监控，随后是性能分析
			B. GC 频繁
			C. CPU Load 过高
			D. OOM
			E. 内存泄露
			F. 死锁
			G. 程序响应时间较长
		② 第 2 步（排查问题）：性能分析
			A. 描述
				a. 一种以侵入方式收集运行性能数据的活动，它会影响应用的吞吐量或者响应性
				b. 性能分析是针对性能问题的答复结果，关注的范围通常比性能监控更加集中
				c. 性能分析很少在生产环境下进行，通常是在质量评估、系统测试或者开发环境下进行，是性能监控之后的步骤
			B. 打印 GC 日志，通过 GCViewer 或者 http://gceasy.io 来分析日志信息
			C. 灵活运用命令行工具：jstack、jmap、jinfo 等
			D. dump 出堆文件，使用内存分析工具分析文件
			E. 使用阿里 Arthas 或 jconsole、JVisualVM 来实时查看 JVM 状态
			F. jstack 查看堆栈信息
		③ 第 3 步（解决问题）：性能调优
			A. 描述：一种为改善应用响应性或吞吐量而更改参数、源代码、属性配置的活动，性能调优是在性能监控、性能分析之后的活动
			B. 适当增加内存，根据业务背景选择垃圾回收器
			C. 优化代码，控制内存使用
			D. 增加机器，分散节点压力
			E. 合理设置线程池线程数量
			F. 使用中间件提高程序效率，比如缓存，消息队列等
	2. VM 监控及诊断工具-命令篇
		jps：查看正在运行的 Java 进程
		jstat：查看 JVM 统计信息
		jinfo：实时查看和修改 JVM 配置参数
		jmap：导出内存映像文件 & 内存使用情况
		jhat：JDK 自带堆分析工具
		jstack：打印 JVM 中线程快照
		jcmd：多功能命令行
		jstatd：远程主机信息收集
	3. JVM 监控及诊断工具-GUI篇
		A. JDK 自带的工具
			a. jconsole：JDK 自带的可视化监控工具。查看 Java 应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等。位置：JAVA_HOME\bin\jconsole.exe
			b. jvisualvm：Visual VM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机上运行的基于 Java 技术的应用程序的详细信息。位置：JAVA_HOME\bin\jvisualvm.exe
			c. jmc：Java Mission Control，内置 Java Flight Recorder。能够以极低的性能开销收集 Java 虚拟机的性能数据
		B. 第三方工具
			a. MAT（Memory Analyzer Tool）：是基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java Heap 分析工具，它可以帮助查找内存泄露和减少内存消耗。Eclipse 的
			插件形式
			b. JProfiler：商业软件，需要付费。功能强大。与 Visual VM 类似
			c. Arthas：Alibaba 开源的 Java 诊断工具。深受 开发者喜爱
			d. Btrace：Java 运行时追踪工具。可以在不停机的情况下，跟踪指定的方法调用、构造器函数调用和系统内存等信息。
	4. Java 中内存泄露的 8 种情况
		静态集合类
		单例模式
		内部类持有外部类
		各种连接，如数据库连接、网络连接和 IO 连接等使用完之后没有正常的关闭
		变量不合理的作用域
		改变哈希值
		缓存泄露
		监听器和回调
	5. JVM 运行时参数
		① 打印设置的 XX 选项及值
			A. -XX:+PrintCommandLineFlags：可以让在程序运行前打印用户手动设置或者 JVM 自动设置的 XX 选项
			B. -XX:+PrintFlagsInitial：打印出所有 XX 选项的默认值
			C. -XX:+PrintFlagsFinal：打印出 XX 选项在运行程序时生效的值
			D. -XX:+PrintVMOptions：打印 JVM 的参数
		② 堆、栈、方法区等内存大小设置
			A. 栈：-Xss128k，等价于 -XX:ThreadStackSize，设置每个线程的栈大小为 128k
			B. 堆内存
				a. -Xms100m：等价于 -XX:InitialHeapSize，设置初始 Java 堆大小为 100m
				b. -Xmx100m：等价于 -XX:MaxHeapSize，设置最大 Java 堆大小为 100m
				c. -Xmn2g：设置年轻代大小为 2G，官方推荐配置为整个堆大小的 3/8（-XX:NewSize 和 -XX:MaxNewSize 合在一起的结果）
				d. -XX:NewSize=1024m：设置年轻代初始值为 1024M
				e. -XX:MaxNewSize=1024m：设置年轻代最大值为 1024M
				f. -XX:SurvivorRatio=8：设置年轻代中 Eden 区与一个 Survivor 区的比值，默认为 8
					(1) 默认情况下，新生代占 1/3，老年代占 2/3，其中，Eden 默认占新生代的 8/10，Survivor0 和 Survivor 各占新生代的 1/10
					(2) 但是通过 Visual VM 查看 JVM 内存时发现，新生代中的 Eden 区 和 Survivor 区的比例不是默认的 8:1:1
					(3) 原因是 JVM 中的参数“UseAdaptiveSizePolicy”默认为 true，该参数会自动选择各区大小比例
					(4) 若将“UseAdaptiveSizePolicy”选项设置为 false，无法使  Eden 区 和 Survivor 区的比例恢复成 8:1:1，还必须显式地将“SurvivorRatio”的选项设置为 8。
					(5) 举例：-XX:-UseAdaptiveSizePolicy -XX:SurvivorRatio=8 
					(6) 建议：“UseAdaptiveSizePolicy”选项默认设置为 true，不指定“SurvivorRatio”参数的值，让 JVM 自动选择各区大小比例
				g. -XX:+UseAdaptiveSizePolicy：自动选择各区大小比例
				h. -XX:NewRation=4：设置老年代与年轻代（包括一个 Eden 和两个 Survivor 区）的比值，默认值为 2
				i. -XX:PretenureSizeThreshold=1024：设置让大于此阈值的对象直接分配在老年代，单位为字节，只对 Serial、ParNew 收集器有效
				j. -XX:MaxTenuringThreshold=15：默认值为 15，新生代每次 MinorGC 之后，还存活的对象年龄 +1，当对象的年龄大于设置的这个阈值时就进入老年代
				k. -XX:+PrintTenuringDistribution：让 JVM 在每次 MinorGC 后打印出当前使用的 Survivor 中对象的年龄分布
				l. -XX:TargetSurvivorRatio=50：表示 MinorGC 结束后 Survivor 区域中占用空间的期望比值
			C. 方法区
				a. 永久代
					(1) -XX:PermSize=256m：设置永久代初始值为 256m
					(2) -XX:MaxPermSize=256m：设置永久代最大值为 256m
				b. 元空间
					(1) -XX:MetaspaceSize：元空间初始大小
					(2) -XX:MaxMetaspaceSize：元空间最大值，默认没有限制
					(3) -XX:+UseCompressedOops：压缩对象指针
					(4) -XX:+UseCompressedClassPointers：压缩类指针
					(5) -XX:+CompressedClassSpaceSize：设置 Klass MetaspaceSize 的大小，默认 1G
			D. 直接内存：-XX:MaxDirectMemorySize，指定 DirectMemorySize 容量，若未指定，则默认与 Java 堆最大值一样
		③ OOM 相关的选项
			A. -XX:+HeapDumpOnOutOfMemoryError：在内存出现 OOM 时，把 Heap 转存（Dump）到文件以便后续分析
			B. -XX:+HeapDumpBeforeFullGC：在出现 Full GC 之前，生成 Heap 转储文件
			C. -XX:HeapDumpPath=<path>：指定 Heap 转储文件的存储路径
			D. -XX:OnOutOfMemoryError：指定一个可行性程序或者脚本的路径，当发生 OOM 时，去执行这个脚本
		④ 垃圾收集器相关选项
			A. 查看默认垃圾收集器
				a. -XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）
				b. 使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程 ID
			B. Serial 回收器
				a. Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾收集器。Serial Old 是运行在 Client 模式下的默认老年代垃圾收集器
				b. -XX:+UseSerialGC：指定年轻代和老年代都使用串行收集器。等价于新生代用 Serial GC，且老年代用 Serial Old GC。可以获得最高的单线程收集效率
			C. ParNew 回收器
				a. -XX:+UseParNewGC：手动指定使用 ParNew 收集器执行内存回收任务，它表示年轻代使用并行收集器，不影响老年代
				b. -XX:ParallelGCThreads=N：限制线程数量，默认开启和 CPU 数量相同的线程数
			D. Parallel 回收器
				a. -XX:+UseParallelGC：手动指定年轻代使用 Parallel 并行收集器执行内存回收任务
				b. -XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器
					(1) 分别适用于新生代和老年代，JDK8 的默认垃圾收集器
					(2) 上面两个参数，默认开启一个，另一个也会被开启（互相激活）
				c. -XX:ParallelGCThreads：设置年轻代并行收集器的线程数。一般的，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能
					(1) 在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 数量
					(2) 当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+(5*CPU_Count/8)
				d. -XX:MaxGCPauseMills：设置垃圾收集器最大停顿时间（即 STW 的时间），单位是毫秒
					(1) 为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作室会调整 Java 堆大小或者其他一些参数
					(2) 对于用户来讲，停顿时间越短体验越好。但是在服务器端，注重高并发，整体地吞吐量，所以服务器端适合 Parallel，进行控制
					(3) Parallel GC 追求高吞吐量，因此不建议在暂停时间多做调整，因此该参数使用需要谨慎
				e. -XX:GCTimeRatio：垃圾收集时间占总时间地比例（=1/(n+1)）。用于衡量吞吐量地大小。
					(1) 取值范围 (0, 100)，默认值 99，也就是垃圾回收时间不超过 1%
					(2) 与前一个 -XX:MaxGCPauseMills 参数有一定矛盾性，暂停时间越长，GCTimeRatio 参数就越容易超过设定地比例
				f. -XX:+UseAdaptiveSizePolicy：设置 Parallel Scavenge 收集器具有自适应调节策略
					(1) 在这种模式下，年轻代地大小、Eden 和 Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点
					(2) 在手动调优比较困难的场合，可以直接使用这种自适应的方式，进指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），
					让虚拟机自己完成调优工作。
			E. CMS 回收器
				a. -XX:+UseConcMarkSweepGC：手动指定使用 CMS 收集器执行内存回收任务，开启该参数后会自动将 -XX:+UseParNewGC 打开。即 ParNewGC（年轻代使用）+ CMS（
				老年代使用）+ Serial Old（后备方案） 的组合
				b. -XX:CMSInitiatingOccupancyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收
					(1) JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次 CMS 回收。JDK6 及以后版本默认值为 92%
					(2) 如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，
					如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行回收器。因此通过该选项便可以有效降低 Full GC 的执行次数。
				c. -XX:+UseCMSCompactAtFullCollection：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以避免内存碎片的产生。不过由于内存压缩整理过程无法并发，
				所带来的问题就是停顿时间变得更长了
				d. -XX:CMSFullGCsBeforeCompaction：设置在执行多少次 Full GC 后对内存空间进行压缩整理。
				e. -XX:ParallelCMSThreads：设置 CMS 的线程数量
					(1) CMS 默认启动的线程数是 (ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的
					影响，应用程序的性能在垃圾回收阶段可能会非常糟糕
				f. 另外，CMS 收集还有如下常用参数
					(1) -XX:ConcGCThreads：设置并发垃圾收集器的线程数，默认该值是基于 ParallelCMSThreads 计算出来的
					(2) -XX:+UseCMSInitiatingOccupancyOnly：是否动态可调，用这个参数可以使 CMS 一直按 CMSInitiatingOccupancyFraction 设定的值启动
					(3) -XX:+CMSScavengeBeforeRemark：强制 HotSpot 虚拟机在 CMS Remark 阶段之前做一次 minor GC，用于提高 Remark 阶段的速度
					(4) -XX:+CMSClassUnloadingEnable：如果有的话，启用回收 Perm 区（JDK8 之前）
					(5) -XX:+CMSParallelInitialEnable：用于开启 CMS initial-mark 阶段采用多线程的方式进行标记，用于提高标记速度，在 JDK8 开始已经默认开启
					(6) -XX:+CMSParallelRemarkEnable：用于开启 CMS Remark 阶段采用多线程的方式进行重新标记，默认开启
					(7) -XX:+ExplicitGCInvokesConcurrent、ExplicitGCInvokesConcurrentAndUnloadsClasses：这两个参数用户指定 HotSpot 虚拟机在执行 System.gc() 时使用
					CMS 周期
					(8) -XX:+CMSPrecleaningEnable：指定 CMS 是否需要进行 Pre cleaning 这个阶段
				g. 特别说明
					(1) JDK9 新特性：CMS 被标记为 Deprecate 了（JEP291）。如果对 JDK9 及以上版本的 HotSpot 虚拟机使用参数 -XX:+UseConcMarkSweepGC 来开启 CMS 收集器
					的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃
					(2) JDK14 新特性：删除 CMS 垃圾回收器（JEP363）。移除了 CMS 垃圾收集器，如果在 JDK14 中使用 -XX:+UseConcMarkSweepGC 的话，JVM 不会报错，只是给出
					一个 warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM。
			F. G1 回收器
				a. -XX:+UseG1GC：手动指定使用 G1 收集器执行内存回收任务
				b. -XX:G1HeapRegionSize：设置每个 Region 的大小，值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内
				存的1/2000
				c. -XX:MaxGCPauseMills：设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms
				d. -XX:ParallelGCThread：设置 STW 时 GC 线程数的值。最多设置为 8
				e. -XX:ConcGCThreads：设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。
				f. -XX:InitiatingHeapOccupancyPercent：设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC，默认值是 45
				g. -XX:G1NewSizePercent、-XX:G1MaxNewSizePercent：新生代占用整个堆内存的最小百分比（默认 5%）和最大百分比（默认 60%）
				h. -XX:G1ReservePercent=10：保留内存区域，防止 to space（Survivor 中的 To 区）溢出
				i. Mixed GC 调优参数：G1 收集器主要涉及到 Mixed GC，Mixed GC 会回收 Young 区和部分 Old 区。G1 关于 Mixed GC 调优常用参数：
					(1) -XX:InitiatingHeapOccupancyPercent：设置堆占用率的百分比（0 到 100），达到这个数值的时候触发 Global Concurrent Marking（全局并发标记），默认
					为 45%。值为 0 表示间断进行全局并发标记
					(2) -XX:G1MixedGCLiveThresholdPercent：设置 Old 区的 region 被回收时的额对象占比，默认占用率为 85%。只有 Old 区的 region 中存活的对象占用到了这个
					百分比，才会在 Mixed GC 中被回收
					(3) -XX:G1HeapWastePercent：在 Global Concurrent Marking（全局并发标记）结束之后，可以知道所有的区有多少空间要被回收，在每次 Young GC 之后和再次
					发生 Mixed GC 之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生 Mixed GC
					(4) -XX:G1MixedGCCountTarget：一次 Global Concurrent Marking（全局并发标记）之后，最多执行 Mixed GC 的次数，默认是 8
					(5) -XX:G1OldCSetRegionThresholdPercent：设置 Mixed GC 收集周期中要收集的 Old Region 数的上限。默认值是 Java 堆的 10%
			G. 怎么选择垃圾回收器
				a. 优先调整堆的大小让 JVM 自适应完成
				b. 如果内存小于 100M，使用串行收集器
				c. 如果是单核、单机程序，并且没有停顿时间的要求，使用串行收集器
				d. 如果是多核 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择
				e. 如果是多核 CPU、追求低停顿时间，需要快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器，官方推荐 G1，性能高。现在互联网项目，基本都是
				使用 G1 收集器
				f. 特别说明
					(1) 没有最好的收集器，更没有万能的收集器
					(2) 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器
		⑤ GC 日志相关选项
			A. 常用参数
				a. -verbose:gc：输出 GC 日志信息，默认输出到标准输出，可以独立使用
				b. -XX:+PrintGC：等同于 -verbose:gc，表示打开简化的 GC 日志，可以独立使用
				c. -XX:+PrintGCDetails：在发生垃圾回收时打印回收详细的日志，并在进程退出时输出当前内存各个区域分配情况，可以独立使用
				d. -XX:+PrintGCTimeStamps：输出 GC 发生时的时间戳，不可以独立使用，需要配合 “-XX:+PrintGCDetails”、“-XX:+PrintGC” 或者 “-verbose:gc” 一起使用
				e. -XX:+PrintGCDateStamps：输出 GC 发生时的时间戳（以日期的形式），不可以独立使用，需要配合“-XX:+PrintGCDetails”、“-XX:+PrintGC”或者“-verbose:gc”一起使用
				f. -XX:+PrintHeapAtGC：每一次 GC 前和 GC 后，都打印堆信息，可以独立使用，如果使用 -XX:+PrintGCDetails，则会输出两个选项的并集部分
				g. -Xloggc:<file>：把 GC 日志写入到一个文件中去，而不是打印到标准输出中
			B. 其他参数
				a. -XX:+TraceClassLoading：监控类的加载
				b. -XX:+PrintGCApplicationStoppedTime：打印 GC 时线程的停顿时间
				c. -XX:+PrintGCApplicationConcurrentTime：垃圾收集之前打印出应用未中断的执行时间
				d. -XX:+PrintReferenceGC：记录回收了多少种不同引用类型的引用
				e. -XX:+PrintTenuringDistribution：让 JVM 在每次 Minor GC 后打印出当前使用的 Survivor 中对象的年龄分布
				f. -XX:+UseGCLogFileRotation：启用 GC 日志文件的自动转储
				g. -XX:NumberOfGClogFiles=1：GC 日志文件的循环数目
				h. -XX:GCLogFileSize：控制 GC 日志文件的大小
		⑥ 其他参数
			A. -XX:+DisableExplicitGC：禁止 HotSpot 执行 System.gc()，默认禁用
			B. -XX:ReservedCodeCacheSize=<n>[g|m|k]、-XX:InitialCodeCacheSize=<n>[g|m|k]：指定代码缓存的大小
			C. -XX:+UseCodeCacheFlushing：使用该参数让 JVM 放弃一些被编译的代码，避免代码缓存被占满时 JV吗 切换到 interpreted-only 的情况
			D. -XX:+DoEscapeAnalysis：开启逃逸分析
			E. -XX:+UseBiasedLocking：开启偏向锁
			F. -XX:+UseLargePages：开启使用大页面
			G. -XX:+UseTLAB：使用 TLAB，默认打开
			H. -XX:TLABSize：设置 TLAB 大小


