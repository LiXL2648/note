一、对象的简介
	1. JS中的数据类型
		①String：字符串类型
		②Number：数值类型
		③Boolean：布尔类型
		④Null：空值
		⑤Undefined：未定义
		⑥Object：对象
	2. 分类：
		以上的前五种数据类型属于基本数据类型，一般数据类型除了基本数据类型其余的即为对象
	3. 基本数据类型的缺陷
		①基本数据类型都是单一的值，值与值之间没有任何联系
		②使用基本数据类型的数据，所创建的变量都是一个独立的个体，不能成为一个整体
	4. 对象：对象属于一种复合的数据类型，在对象中可以保存多个不同的数据类型的属性
	5. 对象的分类：
		①内建对象
			A. 由ES标准中定义的对象，在任何实现了ES标准的浏览器中都可以使用
			B. 比如：Math String Number Boolean Function Object.....
		②宿主对象
			A. 由JS的运行环境提供的对象，目前来说主要指由浏览器提供的对象
			B. 比如BOM DOM
		③自定义对象
			由开发人员自己创建的对象
二、对象的基本操作
	1. 创建对象：
		①使用new关键字调用函数，是构造函数constructor，构造函数是专门用于创建对象的函数
			注：使用typeof检查对象的类型时，返回的是object
		②语法：var 对象名 = new Object();
		②举例：var obj = new Object();
	2. 属性：
		①保存于对象中的值称为属性
		②向对象中添加属性，
			-语法：对象名.属性 = 属性值;
			-举例：obj.name = "li";
		③读取对象中的属性
			-语句：对象名.属性名;
			-举例：console.log(obj.name);
			-如果读取对象中不存在的属性，程序不会报错而是会返回undefined
			-读取时必须通过对象读取，否则该属性没有被声明为变量时将会报错
		④修改对象的属性值
			-语法：对象名.属性 = 属性值;
			-举例：obj.name = "li";
			-跟向对象中保存属性的操作是一样的
		⑤删除对象的属性值
			-语法：delete 对象名.属性名
			-举例：delete obj.name;
	3. 属性名：
		①对象中的属性名不强制要求遵守标识符的规范，任何属性名均可使用，但是使用时仍然按照标识符的规范。
		②如果使用特殊的属性名，不能采用对象.属性名的方式，需要使用另一种方式
		③语法：
			-创建：对象["属性名"]=属性值；
			-读取：console.log(对象["属性名"]);
		④使用对象["属性名"]的方式去创建一个属性，更加灵活
		⑤在[]中可以直接传递一个变量，这个变量的值是多少就会读取到这个属性
		⑥举例：
			var n = "name";
			obj[n] = "li";
			console.log(obj[n]);
	4. 属性值：
		①对象的属性值可以是任意数据类型的值，也可以是对象。
		②举例：
			var obj = new Object();
			var stu = new Object();
			stu.id = "2648";
			stu.pro = "信计";
			obj.name = "li";
			obj.job = stu;
	5. in 运算符
		①听过in运算符可以判断一个对象中是否包含有指定的属性，如果有返回true，反之返回false
		②语法：
			属性名 in 对象
		③举例：
			console.log(name in obj);
三、对象的堆空间
	1. 基本数据类型
		String、Number、Boolean、Null、Undefined
	2. 引用数据类型
		Object
	3. JS中变量都是直接保存在栈内存中，而基本数据类型的值是直接保存在栈内存中
		值与值之间的是相互独立存在的，修改一个变量不会影响其他变量的值
	4. 对象是保存在堆内存中，每创建一个新的对象，就会在堆内存中开辟一个新的空间
		而对象名保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象的
		引用，当通过改变一个对象的属性时，另一个会随之改变
	5. 当两个对象指向同一个内存地址，将其中一个对象的指向设置为null，仅仅表示当前引用的堆空间地址值为null，
		不会影响另一个对象的指向
	6. 当比较两个基本数据类型的值时，比较的是两个变量的值，
		当比较两个对象时，比较的是两个对象的内存空间是否一样
四、对象的字面量：使用对象的字面量可以在创建对象时，直接指定对象中的属性
	1. 语法：var obj = {属性名:属性值,属性名:属性值,属性名:属性值,....};
		=对象字面量的属性名可以加双引号也可以不加，建议不加，但是对于特殊字符要求必须添加双引号
	2. 属性名和属性值是一组一组的明值对结构，名与值之间通过:链接
	3. 多个明值对之间通过,隔开，但是最后一个名值对不需要添加,
	4. 对象的字面量规范：
		var obj = {
			name:"li",
			age:18,
			sex:"男",
			job:{
				type:"stu",
				id:"2648"
			}
		};
五、函数的简介
	1. 函数Fuction：
		①函数也是一个对象
		②函数中可以封装一些功能（代码），有需要时可以执行这些功能（代码）
		③函数可以保存一些代码，有需要时可以调用
		④使用typeof检查一个函数对象时，结果返回function
	2. 创建一个函数方式一：
		①可以将要封装的代码以字符串的形式传递给构造函数
		②封装到函数的代码不会立即执行，而是在函数被调用的时候执行
		③调用函数的方法：函数();
		④当函数被调用时，函数中的代码会按照顺序执行
		⑤举例：
			var fun = new Fuction("console.log('这是我的第一个函数')");//创建一个函数对象
			fun();//调用函数，函数会执行其封装的代码
	3. 方式二：
		-语法：
			function 函数名([形参1,形参2,形参3,...]){
				函数体：
			}
			函数名([实参1,实参2,实参3,....]);
	4. 方式三：使用函数表达式来创建一个函数
		-语法：
			var 函数名 = function(){
				函数体
			};
			函数名();
六、参数：
	1. 形式参数（形参）：
		①可以在函数的()中指定一个或者多个形参（形式参数），多个形参之间使用,隔开
		②声明形参就相当于在函数的内部声明了对应的变量，但是不赋值
	2. 实际参数（实参）：
		①在调用函数时，可以在()中指定函数的实参（实际参数）
		②实参将会赋值给函数中对应的形参
	3. 调用函数时解析器不会检查实参的类型，所以要注意。是否有可能会接受到非法的参数，
		如果有可能则需要对函数的参数进行类别的检查，而且函数的实参是可以为任意的数据类型
	4. 调用函数时解析器不会检查实参的数量，多余的实参不会被赋值，
		如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined
七、返回值：可以使用return来设置函数的返回值
	1. 语法：
		return 值
	2. return后的值将会作为函数的返回值，可以定义一个变量来接收其结果
	3. 在函数中return后的语句都不会被执行
	4. 如果return后不加任何值，则该函数将返回一个undefined
	5. 如果函数没有return（返回值），则该函数同样是返回一个undefined。
八、立即执行函数：函数定义完，立即被调用
	1. 语法：
		(function([形参1,形参2,...]){
			函数体
		})([实参1,实参2,...]);
	2. 立即执行函数往往只会被调用一次
九、方法：
	1. 函数可以作为对象的属性，如果一个函数作为一个对象的属性，
		那么我们称这个函数是这个对象的方法，调用这个函数时称调用对象的方法（method）
	2. 函数与方法没有本质上的区别
	3. 举例1：
		var obj = new Object();
		obj.name = "li";
		obj.age = 18;
		obj.sex = "男";
		obj.callName = function(){
			console.log("名字" + obj.name);
		};
		obj.callName();
	4. 举例2：
		var person = {
			name = "li",
			age = 18,
			sex = "男",
			callName = function(){
				console.log("名字" + obj.name)
			}
		};
		person.callName();
十、枚举：枚举对象中的属性
	1. 使用for...in语句
	2. 语法：
		for(var 变量 in 对象){
			属性名：变量;
			属性值：对象[变量];
		}
	3. 执行流程：
		①对象中有几个属性，循环就会执行几次
		②每次执行循环时，都会将对象的属性赋值给变量，通过访问变量即可访问对象的属性
		③通过”对象[变量]“的方式即可访问对象的属性值。
十一、作用域：作用域指的是变量的作用范围
	1. 全局作用域：
		①直接编写在script标签中的JS代码，都在全局作用域
		②全局作用域在页面打开的时候被创建，在页面被关闭时被销毁
		③在全局作用域中有一个全局对象window，它代表的是一个浏览器窗口，它由浏览器创建，我们可以直接使用
		④在全局作用域中：
			A. 创建的变量都会作为window对象的属性保存
			B. 创建的函数都会作为window对象的方法保存
		⑤全局作用域中的变量都是全局变量，在页面中的任意部分都可以访问
	2. 变量声明提前：
		①使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会被赋值）
		②如果不使用var关键字声明变量，则程序不会报错，因为该变量会声明为window对象的属性，但是不会被声明提前
		③如果使用var声明变量，则该变量可以在声明之前被调用结果为undefined，而不使用var声明变量则不可在声明之前被调用，结果会报错
	3. 函数声明提前：
		①使用函数声明形式创建函数function 函数名(){}，它会在所有的代码被执行之前被创建，所以可以在函数声明之前调用该函数
		②使用函数表达式形式创建函数var fun = function(){}，它会在函数创建之前被声明，但是不会被赋值
			该函数不会被声明提前，因此不能在声明之前被调用
	4. 函数作用域：
		①调用函数时函数作用域被创建，函数执行完毕后，函数作用域被销毁
		②每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的
		③在函数作用域中可以调用全局作用域中的变量，在全局作用域中无法调用函数作用于中的变量
		④当在函数作用域中操作一个变量时，它会在自身作用域中寻找该变量，如果函数作用域中存在则直接使用
			如果函数作用域中不存在则返回上一级作用域去寻找，直到在全局作用域中
			如果全局作用域中依然没有找到该变量，则会包ReferenceError错误
		⑤在函数作用域中要访问全局变量，可以使用window对象去访问：window.全局变量名
		⑥函数作用域中也有声明提前的特性
			A 使用var关键字声明的变量，会在函数中所有的代码执行之前被声明
			B. 函数声明也会在函数作用域中左右代码被执行之前被执行
		⑦在函数作用域中，不实用var声明的变量都会成为全局函数
		⑧定义形参就相当于在函数作用域中什么了函数作用域中的变量
十二、this
	1. 解析器在调用函数时，每次都会向函数内部传递一个隐含的参数，这个隐含的参数就是this
	2. this指向的是一个对象，这个对象我们称之为函数执行额上下文对象。
	3. 根据函数的调用不同，this会指向不同的对象
		①以函数的形式调用时，this指向的永远都是window
		②以方法的形式调用时，this指向的是调用这个方法的对象
		③以构造函数的形式调用时，this指的是新创建的对象（实例）
十三、工厂方法：通过该方法可以创建大量的对象
	function creatObj(name, age, sex){
				var obj = {
					name:name,
					age:age,
					sex:sex,
					callName:function(){
						console.log(this.name);
					}
				};
				return obj;
			}
	var obj1 = creatObj("Li", 18, "男");
十四、构造函数
	1. 构造函数就是一个普通的函数，创建方式与普通的函数没有区别，不同的是构造函数的函数名习惯上首字母大写
	2. 构造函数和普通函数的区别就是调用的方式不同，普通函数是直接调用，而构造函数需要使用new关键字来调用
	3. 构造函数的执行流程：
		①立刻创建一个新的对象
		②将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象
		③逐行执行函数中的代码
		④将新建的对象作为返回值返回
	4. 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类
		我们通过一个构造函数创建的对象，称为该类的实例
	5. 使用instanceof可以检测一个对象是否是一个类的实例
		①语法：对象 instanceof 构造函数
		②如果是，则返回true，如果不是，则返回false
	6. 所有的对象都是Object的后代，所以任何对象和Object在做instanceof检查时，其结果都会返回true
	7. 举例：
		function Person(name, age, sex){
				this.name = name;
				this.age = age;
				this.sex = sex;
				this.callName = function(){
					console.log(this.name);
				};
			}
		var per = new Person("Li", 18, "男");
十五、原型对象：
	1. 背景：
		当我们需要创建大量对象时，在构造函数中声明的方法和属性同样会被创建多次，造成空间的浪费
	2. 解决方案：
		①将构造函数中共同的部分放到全局作用域中，通过构造函数中的属性去调用该函数
		②该方案的缺陷：	
			A. 将函数定义在全局作用域，会污染了全局作用域的命名空间
			B. 定义在全局作用域中的函数也会很不安全，容易被覆盖
	3. 原型对象：我们所创建的每个函数，解析器都会向函数中添加一个属性prototype，这个属性对应一个对象，
		这个对象就是我们所说的原型对象
		①如果函数作为普通的而调用prototype则没有任何作用
		②当函数以构造函数的方式调用时，它所创建的对象都会有一个隐含的属性，指向该构造函数的原型对象，
			我们可以通过__proto__来访问该属性
		③原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型的对象，我们可以将对象中
			公共的内容，统一到原型对象中
		④当我们访问对象的一个属性和方法时，它首先会在对象自身中寻找，如果对象中有该属性或者方法则直接使用，
			如果对象中没有，则会在原型对象中寻找，如果找到则直接使用
		⑤所有以后我们创建构造函数时，可以将这些对象公共的属性和方法，统一添加到构造函数中的原型对象中，
			这样就不用为每一个对象添加共同的属性或者方法
	4. 举例：
		function Person(name, age, sex){
				this.name = name;
				this.age = age;
				this.sex = sex;
		}
		
		Person.prototype.callName = function(){
			console.log("我的名字是：" + this.name);
		};
		
		var per1 = new Person("Li", 18, "男");
		var per2 = new Person("Lin", 18, "男");
		var per3 = new Person("Ke", 18, "女");
		per3.callName();
		console.log(per1.__proto__());//访问原型对象
	5. 原型对象扩展：
		1. 使用in检查一个对象中是否含有某个属性时，如果对象中不存在该对象而原型对象中有该对象也会返回true
		2. 可以使用对象的hasOwnProperty()方法检查对象自身是否含有某个熟悉，使用该方法时只有当自身含义该对象时才返回true
		3. 原型对象也是一个对象，所以他也有原型
			①当我们使用一个对象的属性时，会在对象自身中寻找，如果对象本身存在，则直接使用
			②如果对象本身不存在，则会在对象的原型对象中寻找，如果原型对象中存在，则直接使用
			③如果原型对象不存在，则在原型对象的原型中寻找，直至找到Object中对象的原型
			④Object对象的原型没有原型，如果Object中依然没有找到，则返回undefined。
十六、toString:
	1. 当创建一个类的对象并且打印该对象时，实际上调用的是Object中对象原型的toString()方法
	2. 由于调用toString()方法输出的结构不符合要求，因此需要重写toSting()方法
	3. 由于toString()方法需要对一个类的所有对象都满足，因此需要在类的原型中重写
	4. 举例：
		function Person(name, age, sex){
				this.name = name;
				this.age = age;
				this.sex = sex;
			}
		Person.prototype.toString = function(){
			return "Person[name = " + this.name+ ", age = " + this.age + ", sex = " + this.sex +"]"
		}
		var per1 = new Person("Li", 18, "男");
		console.log(per1);
十七、垃圾回收：
	1. 程序运行过程中会产生垃圾，这些垃圾积攒过多以后，会导致程序运行的速度变慢，
		因此需要一个垃圾回收机制，来处理程序运行过程中产生的垃圾
	2. 但一个对象没有任何的变量或者属性对它进行引用，此时我们将永远失去对该对象的操作，
		而此时的对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，
		因此，这类垃圾必须被处理
	3. 在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作
	4. 而我们需要完成的是将不需要操作的对象引用设置为null即可
 十八、call()和apply()：
	1. 相同点：
		①俩个方法都是函数对象的方法，需要通过函数的对象来调用
		②当通过函数的对象调用call()和apply()方法时，都会执行函数
			举例：
			//方式this指向的是window
			function fun(){
				console.log(this);
			}
			fun();
			fun.call();
			fun.apply();
		③在调用函数对象的call()和apply()方法时，可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this
			举例：
			//方式this指向的是传递进去的对象
			function fun(){console.log(this.name);}
			var obj1 = {name:"obj1"}
			var obj2 = {name:"obj2"}
			fun.call(obj1);
			fun.apply(obj2);
	2. 区别：
		call()方法可以将参数在对象之后依次传递
			举例：
			var obj = new Object();
			function fun(a, b){
				console.log(this);
				console.log("a="+a);
				console.log("b="+b);
			}
			fun.call(obj, 26, 48);
		apply()方法需要将实参封装到一个数组中统一传递
			举例：
			var obj = new Object();
			function fun(a, b){
				console.log(this);
				console.log("a="+a);
				console.log("b="+b);
			}
			fun.apply(obj, [26,48]);
	3. this情况:
		①以函数形式调用时，this永远都是指向window
		②以方法形式调用时，this指向的是调用方法的对象
		③以构造函数的形式调用时，this指向的是新创建的对象
		④使用call()和apply()调用时，this指向的是传递进来的对象
十九、arguments
	1. 在调用函数时，浏览器每次都会传递两个隐含的参数
		①this：函数的上下文对象this
		②arguments：封装实参的对象
	2. arguments：
		①arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度
		②在调用函数时，传递的实参都会在arguments中保存
		③arguments.length可以用来获取实参的个数
		④即使不定义形参，也可以通过arguments来使用实参，只不过比较麻烦
			举例：
				arguments[0]：表示第一个实参
				arguments[1]：表示第二个实参
				.....
		⑤在arguments对象中，有一个属性callee,该属性对应一个函数对象，就是指向函数的对象
				console.log(arguments.callee == fun);//true
	