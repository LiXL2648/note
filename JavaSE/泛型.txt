泛型（Generic）：
一. 为什么要使用泛型？
	1. 优化了程序的结构设计，解决元素存储的安全性问题
	2. 解决获取数据元素时，需要类型强转的问题（强转可能出现类型转化不匹配异常：ClassCastException）
	3. 把运行时的错误提前到编译时进行处理 
二. 泛型的使用
	1. 在集合中使用泛型
	2. 自定义泛型类、泛型接口、泛型方法
		A. 自定义泛型类：自定义泛型类实现见com.generic_class下的TestClass类
			①当实例化泛型类的对象时，指明泛型的类型，对应的类使用泛型的位置，都变为指定的泛型类型
			②如果自定义泛型类，但是在实例化时没有指明泛型的类型，则默认类型是Object类
			③继承泛型类或者实现泛型接口时，可以指明继承的类或者实现的接口的泛型类型
			④如果继承泛型类或者实现泛型接口时，没有指明继承的类或者实现的接口的泛型时，需要指明子类和继承类或者实现的接口都为<T>
		B. 泛型接口：自定义泛型接口的实现过程见com.generic.Dao下的各种实现类和接口
		C. 泛型方法：public <T> T getT(T t){},调用方法时，指明参数的类型，进而确定方法的返回值类型
	3. 泛型与继承的关系： 
		A. 若类A是类B的子类，那么List<A>就不是List<B>的子接口，而是List<A>和List<B>并列关系。
	4. 泛型通配符：
		A. ?：List<A>、List<B>、....都是List<?>的子类
		B. ? extends A：可以存放A及其子类
		C. ? super A：可以存放B及其子类
三. 对于泛型（集合类）
		
	1. 静态方法中不能使用类的泛型：因为抽象成员是随着类的加载而加载，而泛型是在创建对象的时候具体化，因此无法引用类的泛型
	2. 如果泛型类是一个接口或者抽象类，则不可以创建泛型类的对象
	3. 不能在catch中使用泛型
	4. 从泛型类派生子类，泛型类型需要具体化
	核心思想：把一个集合中的内容限制为一个特定的数据类型，这就是泛型背后的核心思想
四. 通配符的使用
	1. 可以读取声明为通配符的集合类的对象
	2. 不允许向声明为通配符的集合类中写入对象，原因是声明为通配符的集合无法确认写入什么类型的对象，因此不允许写入
	3. 唯一写可以写入的是null，原因是null是所有对象的默认值。
