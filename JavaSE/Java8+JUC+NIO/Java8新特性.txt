一. Java 8 新特性
	1. 主要内容
		① Lambda 表达式
		② 函数式接口
		③ 方法引用与构造器引用
		④ Stream API
		⑤ 接口中的默认方法与静态方法
		⑥ 新时间日期API
		⑦ 其他新特性
	2. 简介
		① 速度更快
			A. Hashmap 底层结构/原理
			B. 并发hashmap
			C. Java虚拟机
			D. Java内存模型
		② 代码更少（增加新语法Lambda表达式）
		③ 强大的 Steam API
		④ 便于并行
		⑤ 最大化减少空指针异常 OPtional
	3. 其中最核心的是Lambda表达式与 Stream API
二. Lambda表达式
	1. 为什么使用 Lambda 表达式
		① Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁，更灵活的代码。
		作为一种更为紧凑的代码风格，使Java的语言表达能力得到提升
			A. 匿名内部类
				Comparator<Integer> comparator = new Comparator<Integer>() {
					@Override
					public int compare(Integer o1, Integer o2) {
						return Integer.compare(o1, 02);
					}
				};
			B. Lambda表达式
				Comparator<Integer> comparator1 = (o1, o2) -> Integer.compare(o1, o2);
			C. 获取当前公司员工年龄小于18的员工信息
				a. 传统方式
					List<Employee> list = Arrays.asList(
						new Employee(1, "LiXL", 1, 18, 8000.00),
						new Employee(2, "YuCX", 0, 19, 9000.00),
						new Employee(3, "LinK", 1, 17, 7000.00),
						new Employee(4, "LinZH", 1, 18, 8000.00),
						new Employee(4, "LiLX", 0, 16, 9000.00)
					);
					private List<Employee> filterEmployee(List<Employee> list) {
						List<Employee> newList = new ArrayList<>();

						for (Employee employee: list) {
							if (employee.getAge() < 18) {
								newList.add(employee);
							}
						}

						return newList;
					}
				b. 优化方式一：策略设计模式，每多一个策略，则需要重新实现MyPredicate接口
					public interface MyPredicate<T> {

						boolean test(T t);
					}
					
					public class FilterEmployeeByAge implements MyPredicate<Employee> {

						@Override
						public boolean test(Employee employee) {
							return employee.getAge() < 18;
						}
					}
					
					private List<Employee> filterEmployeeByAge1(List<Employee> list, MyPredicate<Employee> myPredicate) {
						List<Employee> emps = new ArrayList<>();

						for (Employee employee: list) {
							if (myPredicate.test(employee)) {
								emps.add(employee);
							}
						}
						return  emps;
					}
				c. 优化方式二：匿名内部类，每增加一个策略，不需要实现MyPredicate接口，而是提供一个匿名内部类
					filterEmployeeByAge1(list, new MyPredicate<Employee>() {
						@Override
						public boolean test(Employee employee) {
							return employee.getSalary() > 8000;
						}
					})
				d. 优化方式三：lambda表达式
					List<Employee> emps = filterEmployeeByAge1(list, employee -> employee.getGender() == 0);
					emps.forEach(System.out::println);
				e. 优化方式四：Stream API
					list.stream().filter(employee -> employee.getGender() == 1).forEach(System.out::println);
		② Lambda表达式被称为语法糖或者糖衣语法。
	2. 基础语法：
		① Java 8 中引入了一个新的操作符 “->”，该操作符称为箭头操作符或者Lambda操作符，箭头操作符将 Lambda 表达式拆分为两部分
			A. 左侧：Lambda 表达式中的参数列表
			B. 右侧：Lambda 表达式中所需要执行的功能，即 Lambda 体
		② 语法格式：
			A. 无参数，无返回值：
				a. 语法：() -> {}，如果Lambda体中只有一条语句，则大括号可以省略
				b. 对应的函数式接口：Runnable
				c. 举例：
					Runnable runnable = new Runnable() {
						@Override
						public void run() {
							System.out.println("hello");
						}
					};
					runnable.run();
					
					Runnable runnable = () -> System.out.println("Hello");
					runnable.run();
				d. 注意：在局部内部类中使用了同级的局部变量时，需要声明该变量为 final，但是在 Java8 中，会隐式默认该变量为final修饰，不需要显示
				修饰，在Java 8 或者 Java 7中的局部内部类中，都不允许修改该变量。
			B. 有参数，无返回值：
				a. 语法：(T t) -> {}，如果只有一个参数，小括号可以省略，一般默认带上小括号
				b. 对应的函数式接口：Consumer
				c. 举例：
					Consumer<String> consumer = new Consumer<String>() {
						@Override
						public void accept(String str) {
							System.out.println(str);
						}
					};
					consumer.accept("Hello");

					Consumer<String> consumer1 = str -> System.out.println(str);
					consumer1.accept("World");
			C. 有两个以上的参数，并且有返回值，并且Lambda表达式中有多条语句
				a. 语法：(T t1, T t2) -> {} ，有多条语句时，大括号不能省略；只有一条语句时，return 可以省略不写；参数列表有多个时，小括号不能省略。
				b. 对应的函数式接口为：
				c. 举例：
					Comparator<Integer> comparator = new Comparator<Integer>() {
						@Override
						public int compare(Integer o1, Integer o2) {
							return Integer.compare(o1, o2);
						}
					};

					Comparator<Double> comparator1 = (d1, d2) -> {
						System.out.println("Comparator函数式接口");
						return Double.compare(d1, d2);
					};
			D. Lambda表达式参数列表的数据类型可以省略不写，因为Java 的 JVM编译器通过上下文可以推断出参数列表的数据类型，即“类型推断”，当接口中的泛型
			指明了参数列表中的数据类型时，此时Lambda表达式中参数列表的数据类型就可以省略不写
		③ Lambda表达式需要“函数式接口”的支持
			A. 函数式接口：接口中有只有一个抽象方法，则称为“函数式接口”
			B. 可以使用@FunctionalInterface注解检查其标注的接口是否为“函数式接口”
		④ 练习：
			A. 对一个数进行数学运算
				public interface MyFunction<T> {

					T operator(T t);
				}
		
				MyFunction<Integer> myFunction = x -> x * x;
				System.out.println( myFunction.operator(10));
			B. 调用Collections.sort()方法，通过定制排序比较两个Employee（先按照年龄比，年龄相同按姓名比），使用Lambda作为参数传递
				@Test
				public void test5() {
					Collections.sort(list, (e1, e2) -> {
						if (e1.getAge() == e2.getAge()) {
							return e1.getEmpName().compareTo(e2.getEmpName());
						} else {
							return Integer.compare(e1.getAge(), e2.getAge());
						}
					});
					list.forEach(System.out::println);
				}
			C.  声明函数式接口，接口中声明抽象方法，在测试类中，编写方法使用接口作为参数，将一个字符串转成大写，并作为返回值。再将该字符串进行截取
				@Test
				public void test6() {
					String value = getValue("LiXL&YuCX", str -> str.toUpperCase());
					value = getValue(value, str -> str.substring(0, 4));
					System.out.println(value);
				}

				
				private <T> T getValue(T t, MyFunction<T, T> myFunction) {
					return myFunction.operator(t);
				}
				
				public interface MyFunction<T, R> {

					R operator(T ... t);
				}
			D.  声明一个带两个泛型的函数式接口，泛型类型为<T, R>，T为参数，R为返回值，接口中声明抽象方法，在测试类中，使用该接口作为参数，计算两个long类型的和，
			再计算两个long类型的乘积
				public void test7() {
					Integer sum = getValue(args -> args[0] + args[1], 26, 48);
					System.out.println(sum);
					Integer mul = getValue(args -> args[0] * args[1], 26, 48);
					System.out.println(mul);
				}
				
				private <T> T getValue(MyFunction<T, T> myFunction, T ... t) {
					return myFunction.operator(t);
				}
				
				public interface MyFunction<T, R> {

					R operator(T ... t);
				}
二. 函数式接口
	1. 四大内置的核心函数式接口：
		① Consumer<T>：
			A. 消费型接口
			B. 抽象方法：void accept(T t);
			C. 举例：
				public void testConsumer() {
					consume(100D, menoy -> System.out.println("其次消费总共花费 " + menoy + " 元"));
				}

				public void consume(Double money, Consumer<Double> consumer) {
					consumer.accept(money);
				}
		② Supplier<T> ：
			A. 供给型接口
			B. 抽象方法：T get();
			C. 举例：
				@Test
				public void testSupplier() {
					List<Integer> list = supplie(10, () -> (int) (Math.random() * 100));
					list.forEach(System.out::println);
				}

				private List<Integer> supplie(int num, Supplier<Integer> supplier) {
					List<Integer> list = new ArrayList<>();
					for (int i = 0; i < num; i++) {
						Integer value = supplier.get();
						list.add(value);
					}
					return list;
				}
		③ Function<T, R>：
			A. 函数型接口
			B. 抽象方法：R apply(T t);
			C. 举例：
				@Test
				public void testFunction() {
					String result = strHandler("LiXL", str -> str.toUpperCase());
					System.out.println(result);
				}

				public String strHandler(String str, Function<String, String> function) {
					return function.apply(str);
				}
		④ Predicate<T>：
			A. 断言型接口
			B. 抽象方法：boolean test(T t);
			C. 举例：
				@Test
				public void testPredicate() {
					List<String> list = Arrays.asList("LiXL", "LiXC", "LiXY", "LiLX", "YuCX");
					List<String> newList = filter(list, str -> str.startsWith("Li"));
					System.out.println(newList);
				}

				private List<String> filter(List<String> list, Predicate<String> predicate) {
					List<String> newList = new ArrayList<>();
					list.forEach(str -> {
						if (predicate.test(str)) {
							newList.add(str);
						}
					});
					return newList;
				}
	2. 其他接口
		① BiFunction<T, U, R>：
			A. 参数类型：T,U
			B. 返回值类型：R
			C. 用途：对类型为 T，U 参数应用操作，返回 R 类型的结果。包含方法 R apply(T t, U u)
		② UnaryOperator<T>（Function<T, R> 的子接口）
			A. 参数类型：T
			B. 返回值类型：T
			C. 对类型为 T 的对象进行一元运算，并返回类型为 T 的结果，包含方法为 T apply(T t)
		③ BinaryOperator<T>（BiFunction<T, U, R>的子接口）：
			A. 参数类型：T，T
			B. 返回值类型：T
			C. 对类型为 T 的对象进行二元运算，并返回类型为 T 的结果，包含方法为 T apply(T t1, T t2)
		④ BiConsumer<T, U>
			A. 参数类型：T，U
			B. 返回值类型：void
			C. 对类型为 T，U 的参数进行操作，包含方法为 void accept(T t, U u);
		⑤ ToIntFunction<T>，ToLongFunction<T>，ToDoubleFunction<T>
			A. 参数类型：T，T
			B. 返回值类型：分别为 int，long，double
			C. 分别计算 int，long，double，值的函数
		⑥ IntFunction<R>，LongFunction<R>，DoubleFunction<R>
			A. 参数类型：分别为 int，long，double
			B. 返回值类型：R
			C. 参数分别为 int，long，double的函数
		⑦ BiPredicate<T, U>
			A. 参数类型：T，U
			B. 返回值类型为boolean
三. 方法引用和构造器引用
	1. 方法引用
		① 若Lambda体中的内容有方法已经实现，我们可以使用“方法引用”（可以理解为方法引用是Lambda表达式的另一种变现形式）
		② 主要有三种语法格式：
			A. 对象::实例方法名
				Consumer<String> consumer = x -> System.out.println(x);
				consumer.accept("Hello");

				Consumer<String> consumer1 = System.out::println;
				consumer1.accept("Hello World!");
				
				Employee employee = list.get(0);
				Supplier<String> supplier = employee::getEmpName;
				System.out.println(supplier.get());
			B. 类::静态方法名
				Comparator<Integer> com = (x, y) -> Integer.compare(x, y);
				int compare = com.compare(48, 26);
			   
				Comparator<Double> com1 = Double::compare;
				int compare1 = com1.compare(26D, 48D);
			C. 类::实例方法名
				BiPredicate<String, String> bp = (x, y) -> x.equalsIgnoreCase(y);
				System.out.println(bp.test("LiXL", "lixl"));

				BiPredicate<String, String> bp1 = String::equals;
				System.out.println(bp1.test("LiXL", "LiLX"));
		③ 注意：
			A. 进行方法引用时，Lambda体中调用方法的参数列表与返回值类型，需要与函数型接口中的抽象方法的参数列表和返回值保持一致
			B. 若Lambda的参数列表列表的第一个参数是方法的调用者，而第二个参数是实例方法的参数时，可以使用类名::实例方法。
	2. 构造器引用
		① 语法：类名::new
		② 举例：
			Supplier<Employee> supplier = () -> new Employee();
			System.out.println(supplier.get());

			Supplier<Employee> supplier1 = Employee::new;
			System.out.println(supplier1.get());
			
			Function<String, Employee> fun = x -> new Employee(x);
			System.out.println(fun.apply("LiXL"));

			Function<String, Employee> fun1 = Employee::new;
			System.out.println(fun1.apply("LiLX"));
		② 注意: 进行构造器引用时，Lambda体中调用构造器的参数列表与返回值类型，需要与函数型接口中的抽象方法的参数列表和返回值保持一致
	3. 数组引用：
		① 语法：Tyep::new
		② 举例：
			Function<Integer, String[]> fun = x -> new String[x];
			System.out.println(fun.apply(10).length);

			Function<Integer, String[]> fun1 = String[]::new;
			System.out.println(fun1.apply(20).length);
四.	强大的 Stream API
	1. 了解Stream
		① Java8 中有两大最为重要的改变，第一个就是 Lambda 表达式；另外一个则是 Steam API（java.util.stream.*）
		② Steam 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作。可以执行非常复杂的查找，过滤和映射数据等操作。
		③ 使用Stream API 对集合进行操作，就类似于使用SQL执行的数据查询。也可以使用 Stream API来并行执行操作。简而言之 Stream API 
		提供了一种高效且易于使用的处理数据的方式
	2. 什么是Stream
		① 流（Stream）：是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。“集合讲的是数据，流讲的是计算”
		② 注意：
			A. Stream 自己不会存储元素
			B. Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。
			C. Stream 操作是延迟执行的，这意味着他们会等到需要结果的时候才执行，
	3. Stream 的三个操作步骤
		① 创建Stream：一个数据源（如：集合，数组），获取一个流
		② 中间操作：一个中间操作链，对数据源的数据进行处理
		③ 中止操作（终端操作）：一个终止操作，执行中间操作链，并产生结果
	4. 创建Stream
		① Java 8 中的Collection接口被扩展，提供了两个获取流的方法
			A. default Stream<E> stream()：返回一个顺序流
			B. default Stream<E> parallelStream()：返回一个并行流
			C. 举例：
				List<Employee> emps = new ArrayList<>();
				Stream<Employee> stream = emps.stream();
				Stream<Employee> parallelStream = emps.parallelStream();
		② 由数组创建流
			A. Java 8 中的 Arrays的静态方法 stream()可以获取数组流
				static <T> Stream<T> stream(T[] array)：返回一个流
			B. 重载形式，能够处理对应基本类型的数组
				a. public static IntStream stream(int[] array)
				b. public static LongStream stream(long[] array)
				c. public static DoubleStream stream(double[] array)
			C. 举例
				Employee[] employees = new Employee[10];
				Stream<Employee> stream1 = Arrays.stream(employees);
		③ 通过Stream类中的静态方法of()
			A. static<T> Stream<T> of(T... values)
			B. 举例
				Stream<String> stream2 = Stream.of("LiXL", "LiLX");
		④ 创建无限流
			A. 迭代：
				a. static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)
				b. 举例
					Stream<Integer> stream3 = Stream.iterate(0, x -> x + 2);
					stream3.limit(10).forEach(System.out::println);
			B. 生成：
				a. static<T> Stream<T> generate(Supplier<T> s)
				b. 举例
					Stream<Integer> stream4 = Stream.generate(() -> (int) (Math.random() * 10000));
					stream4.limit(10).forEach(System.out::println);
	5. 中间操作
		① 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何处理！而在终止操作时一次性全部处理，
		称为“惰性求值”或则“延迟加载”
		② 筛选与切片
			A. Stream<T> filter(Predicate<? super T> predicate);
				a. 接收Lambda，从流中排除某些元素
				b. 举例：
					list.stream().filter(e -> e.getGender() == 1)
							.forEach(System.out::println);
				c. 过滤后会产生一个新流，但是不会执行任何操作，终止操作时会一次性执行全部内容
				d. 内部迭代：迭代操作由Stream API 完成
				e. 外部迭代：
					Iterator<Employee> iterator = list.iterator();
					while (iterator.hasNext()) {
						System.out.println(iterator.next());
					}
			B. Stream<T> distinct();
				a. 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素
				b. 举例：
					list.stream()
							.filter(e -> e.getSalary() > 7000)
							.distinct()
							.forEach(System.out::println);
				c. 需要重写 equals() 和hashCode() 方法
			C. Stream<T> limit(long maxSize);
				a. 截断流，使其元素不超过给定的数量
				b. 举例：
					list.stream()
							.filter(e -> e.getSalary() > 7000)
							.limit(2)
							.forEach(System.out::println);
				c. 若迭代次数满足条件，则会出现短路现在，即满足条件往后得迭代将不执行
			D. Stream<T> skip(long n);
				a. 跳过元素，返回一个扔掉前 n 个元素的流。若流中的元素不足 n 个，则返回一个空流。与limit(long maxSize)互补
				b. 举例：
					list.stream()
							.filter(e -> e.getSalary() > 7000)
							.skip(2)
							.forEach(System.out::println);
		③ 映射
			A. <R> Stream<R> map(Function<? super T, ? extends R> mapper);
				a. 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的流，将元素转换成其他形式或提取信息。
				b. 举例：
					// 将元素转换成其他形式
					List<String> strList = Arrays.asList("lixl", "yucx", "lilx");
					strList.stream()
							.map(str -> str.toUpperCase())
							.forEach(System.out::println);

					// 提取信息
					list.stream()
							.map(Employee::getEmpName)
							.distinct()
							.forEach(System.out::println);
			B. IntStream mapToInt(ToIntFunction<? super T> mapper);
				a. 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream
			C. LongStream mapToLong(ToLongFunction<? super T> mapper);
				a. 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream
			D. DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper);
				a. 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream
			E. <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
				a. 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流
				b. 方式一：该方式相当于List<List<Character>>.add(List<Character>)
					list.stream()
							.map(Employee::getEmpName) // 获取集合中员工名字组成得新流
							.map(TestStreamApi::getStream) // 获取每个名字转换成Character流的新流
							.forEach(s -> { // 遍历新流中的每个Character流
								s.forEach(System.out::println); // 遍历Character流
								System.out.println("-------------------");
							});
					private static Stream<Character> getStream(String str) {
						List<Character> charList = new ArrayList<>();

						for (Character c: str.toCharArray()) {
							charList.add(c);
						}
						return  charList.stream();
					}
				c. 方式二：该方式相当于List<Character>.addAll(List<Character>)
					list.stream()
							.map(Employee::getEmpName)
							.flatMap(TestStreamApi::getStream)
							.forEach(System.out::println);
		④ 排序
			A. Stream<T> sorted();
				a. 产生一个新流，其中按自然顺序排序（Comparable<T>）
				b. 举例：
					list.stream()
							.map(Employee::getSalary)
							.distinct()
							.sorted()
							.forEach(System.out::println);
			B. Stream<T> sorted(Comparator<? super T> comparator);
				a. 产生一个新流，其中按比较器顺序排序（Comparator<T>）
				b. 举例：
					list.stream()
							.sorted((e1, e2) -> {
								if (e1.getAge() == e2.getAge()) {
									return e1.getEmpName().compareTo(e2.getEmpName());
								} else {
									return Integer.compare(e1.getAge(), e2.getAge());
								}
							})
							.distinct()
							.forEach(System.out::println);
	6. 终止操作
		① 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List，Integer，甚至是void
		② 查找与匹配
			A. boolean allMatch(Predicate<? super T> predicate);
				a. 检查是否匹配所有元素
				b. 举例：
					boolean allMatch = list.stream()
							.allMatch(e -> e.getStatus().equals(Employee.Status.BUSY));
					System.out.println(allMatch);
			B. boolean anyMatch(Predicate<? super T> predicate);
				a. 检查是否至少匹配一个元素
				b. 举例：
					boolean anyMatch = list.stream()
							.anyMatch(e -> e.getStatus().equals(Employee.Status.FREE));
					System.out.println(anyMatch);
			C. boolean noneMatch(Predicate<? super T> predicate);
				a. 检查是否没有匹配所有元素
				b. 举例：
					boolean noneMatch = list.stream()
							.noneMatch(e -> e.getStatus().equals(Employee.Status.VOCATION));
					System.out.println(noneMatch);
			D. Optional<T> findFirst();
				a. 返回第一个元素
				b. 举例：
					Optional<Employee> optional = list.stream()
							.filter(e -> e.getStatus().equals(Employee.Status.FREE))
							.findFirst();
					System.out.println(optional.get());
				c. 返回一个Optional容器类，有效地避免空指针异常
			E. Optional<T> findAny();
				a. 返回当前流中的任意元素
				b. 举例：
					Optional<Employee> any = list.parallelStream()
							.filter(e -> e.getStatus().equals(Employee.Status.BUSY))
							.findAny();
					System.out.println(any.get());
				c. 使用并行流可以增加随机性
			F. long count();
				a. 返回流中元素地总数
				b. 举例：
					long count = list.stream()
							.filter(e -> e.getEmpName().startsWith("Li"))
							.count();
					System.out.println(count);
			G. Optional<T> max(Comparator<? super T> comparator);
				a. 获取流中的最大值
				b. 举例：
					Optional<Employee> optional = list.stream()
							.filter(e -> e.getEmpName().startsWith("Li"))
							.max((e1, e2) -> e1.getAge().compareTo(e2.getAge()));
					System.out.println(optional.get());
			H. Optional<T> 	(Comparator<? super T> comparator);
				a. 获取流中的最小值
				b. 举例：
					@Test
					public void testMin() {
						Optional<Employee> optional = list.stream()
								.filter(e -> e.getEmpName().startsWith("Li"))
								.min((e1, e2) -> e1.getAge().compareTo(e2.getAge()));
						System.out.println(optional.get());
					}
		③ 归约（reduce）：将流中的每个元素反复结合起来，得到一个值
			A. Optional<T> reduce(BinaryOperator<T> accumulator);
				a. 只需一个二元运算函数式接口
				b. 举例：
					Optional<Double> reduce = list.stream()
							.map(Employee::getSalary)
							.reduce(Double::sum);
					System.out.println(reduce.get());
				c. 结果返回一个Optional，原因是该方法没有起始值，而流中可能不存在一个元素。
			B. T reduce(T identity, BinaryOperator<T> accumulator);
				a. 需要两个参数，
					(1) identity：起始值
					(2) BinaryOperator：二元运算函数式接口
				b. 举例：
					Double reduce = list.stream()
							.map(Employee::getSalary)
							.reduce(0D, (x, y) -> x + y);
					System.out.println(reduce);
				c. 执行流程，将起始值作为x，将流中的第一个元素作为y，得到结果继续作为x，直到最终获取到总值。
			C. <U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner);
			D. 注：map 和reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名
		④ 收集（collect）：将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法
			A. Collector 接口方法的实现决定了如何对流执行收集操作（如收集到List，Set和Map）。但是Collectors实现类提供了很多静态方法，
			可以方便地创建常见收集器实例，具体方法与实例如下
			B. Collectors.toList():
				a. 将流中地元素收集到List中
				b. 举例：
					List<String> names = list.stream()
							.map(Employee::getEmpName)
							.distinct()
							.collect(Collectors.toList());
					names.forEach(System.out::println);
			C. Collectors.toSet():
				a. 将流中的元素收集到set中，去除重复元素
				b. 举例：
					Set<String> set = list.stream()
							.map(Employee::getEmpName)
							.collect(Collectors.toSet());
					set.forEach(System.out::println);
			D. Collectors.toCollection(Supplier<T> supplie)
				a. 如果需要收集到一些特殊的数据结构，则可以使用Collectors.toCollection(Supplier<T> supplie)
				b. Collectors.toCollection(Supplier<T> supplie) 方法需要一个供给型接口，用于提供对象
				c. 举例：
					HashSet<String> hashSet = list.stream()
							.map(Employee::getEmpName)
							.collect(Collectors.toCollection(HashSet::new));
					hashSet.forEach(System.out::println);
			E. Collectors.counting()
				a. 收集流中元素的总数
				b. 举例：
					Long counting = list.stream()
						.map(Employee::getAge)
						.distinct()
						.collect(Collectors.counting());
					System.out.println(counting);
			F. Collectors.averagingDouble/Collectors.averagingInteger/Collectors.averagingLong
				a. 获取流中元素的平均值
				b. 举例：
					Double averaging = list.stream()
							.collect(Collectors.averagingDouble(Employee::getSalary));
					System.out.println(averaging);
				c. Collectors.averagingDouble方法需要传入提取用于求平均值的元素，不需要额外提取
			G. Collectors.summingDouble/Collectors.summingInteger/Collectors.summingLong
				a. 获取流中元素的总和
				b. 举例：
					Double sum = list.stream()
							.collect(Collectors.summingDouble(Employee::getSalary));
					System.out.println(sum);
			H. Collectors.maxBy
				a. 获取流中的最大值
				b. 举例：
					Optional<Double> max = list.stream()
							.map(Employee::getSalary)
							.collect(Collectors.maxBy(Double::compareTo));
					System.out.println(max.get());
			I. Collectors.minBy
				a. 获取流中的最小值
				b. 举例：
					Optional<Integer> min = list.stream()
							.map(Employee::getAge)
							.collect(Collectors.minBy(Integer::compareTo));
					System.out.println(min.get());
			J. Collectors.groupingBy(Function<? super T, ? extends K> classifier)
				a. 分组
				b. 举例：
					 Map<Employee.Status, List<Employee>> map = list.stream()
							.collect(Collectors.groupingBy(Employee::getStatus));
					System.out.println(map);
			K. Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream
				a. 多级分组
				b. 举例：
					Map<Employee.Status, Map<Integer, List<Employee>>> map = list.stream()
							.collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy(Employee::getAge)));
					System.out.println(map);
			L. Collectors.partitioningBy
				a. 分区/分片
				b. 举例：
					Map<Boolean, List<Employee>> map = list.stream()
							.collect(Collectors.partitioningBy(e -> e.getEmpName().startsWith("Li")));
					System.out.println(map);
			M. Collectors.summarizingDouble/Collectors.summarizingInteger/Collectors.summarizingLong
				a. 收集流中元素的最大值/最小值等封装的对象
				b. 举例：
					DoubleSummaryStatistics summaryStatistics = list.stream()
							.collect(Collectors.summarizingDouble(Employee::getSalary));
					System.out.println(summaryStatistics.getMax());
					System.out.println(summaryStatistics.getAverage());
					System.out.println(summaryStatistics.getCount());
					System.out.println(summaryStatistics.getMin());
					System.out.println(summaryStatistics.getSum());
			N. Collectors.joining
				a. 连接字符串
				b. 举例：
					String join = list.stream()
							.map(employee -> employee.getId().toString())
							.collect(Collectors.joining(";"));
					System.out.println(join);
	7. 练习：
		① 给定一个数组列表，如何返回一个由每个元素的平方构成的列表，给定[1, 2, 3, 4]，返回[1, 4, 9, 16]
			List<Integer> list = Arrays.asList(1, 2, 3, 4);
			list.stream()
					.map(i -> i * i)
					.forEach(System.out::println);
		② 怎么使用map和reduce计算流中的Employee个数
			Integer reduce = list.stream()
					.map(employee -> 1)
					.reduce(0, (x, y) -> Integer::sum);
			System.out.println(reduce);
		③ 交易与交易员
			A. 交易员类
				public class Trader {

				private String name;
				private String city;

				public Trader() {
				}

				public Trader(String name, String city) {
					this.name = name;
					this.city = city;
				}

				public String getName() {
					return name;
				}

				public void setName(String name) {
					this.name = name;
				}

				public String getCity() {
					return city;
				}

				public void setCity(String city) {
					this.city = city;
				}

				@Override
				public boolean equals(Object o) {
					if (this == o) return true;
					if (o == null || getClass() != o.getClass()) return false;
					Trader trader = (Trader) o;
					return Objects.equals(name, trader.name) &&
							Objects.equals(city, trader.city);
				}

				@Override
				public int hashCode() {
					return Objects.hash(name, city);
				}

				@Override
				public String toString() {
					return "Trader{" +
							"name='" + name + '\'' +
							", city='" + city + '\'' +
							'}';
				}
			}
		B. 交易类
			public class Transaction {

				private Trader trader;
				private Integer year;
				private Integer value;

				public Transaction() {
				}

				public Transaction(Trader trader, Integer year, Integer value) {
					this.trader = trader;
					this.year = year;
					this.value = value;
				}

				public Trader getTrader() {
					return trader;
				}

				public void setTrader(Trader trader) {
					this.trader = trader;
				}

				public Integer getYear() {
					return year;
				}

				public void setYear(Integer year) {
					this.year = year;
				}

				public Integer getValue() {
					return value;
				}

				public void setValue(Integer value) {
					this.value = value;
				}

				@Override
				public boolean equals(Object o) {
					if (this == o) return true;
					if (o == null || getClass() != o.getClass()) return false;
					Transaction that = (Transaction) o;
					return Objects.equals(trader, that.trader) &&
							Objects.equals(year, that.year) &&
							Objects.equals(value, that.value);
				}

				@Override
				public int hashCode() {
					return Objects.hash(trader, year, value);
				}

				@Override
				public String toString() {
					return "Transaction{" +
							"trader=" + trader +
							", year=" + year +
							", value=" + value +
							'}';
				}
			}
		C. 交易：
			List<Transaction> transactions = Arrays.asList(
					new Transaction(new Trader("LiXL", "广州"), 1996, 48),
					new Transaction(new Trader("YuCX", "广州"), 1995, 29),
					new Transaction(new Trader("LiLX", "东莞"), 1996, 30),
					new Transaction(new Trader("LinK", "广州"), 1996, 18),
					new Transaction(new Trader("LinZH", "广州"), 1996, 20),
					new Transaction(new Trader("LiXC", "深圳"), 1992, 27)
			);
		D. 找出1996年发生的所有交易，并按交易额排序（从低到高）
			transactions.stream()
                .filter(t -> t.getYear() == 1996)
                .sorted((t1, t2) -> Integer.compare(t1.getValue(), t2.getValue()))
                .forEach(System.out::println);
		E. 交易员都在哪些不同的城市工作过
			transactions.stream()
                .map(Transaction::getTrader)
                .map(Trader::getCity)
                .collect(Collectors.toSet())
                .forEach(System.out::println);
		F. 查找所有来自广州的交易员，并按照姓名排序
			transactions.stream()
                .map(Transaction::getTrader)
                .filter(t -> t.getCity().equals("广州"))
                .sorted((t1, t2) -> t1.getName().compareTo(t2.getName()))
                .forEach(System.out::println);
		G. 返回所有交易员姓名的字符串，按字母顺序排序
		H. 有没有交易员在东莞工作的
		I. 打印生活在广州的交易员的所有交易额
		J. 所有交易中，最高的交易额是多少
		K. 找到交易额最小的交易
五、并行流与串行流
	1. 了解Fork/Join框架
		① Fork/Join框架：就是在必要的情况下，将一个大任务，进行拆分（fork）成若干个小任务（拆到不可再拆时），
		再将一个个的小任务运算的结果进行join汇总
											--------
											| 任务 |
											--------
										   fork |
							--------------------|---------------------
							↓ 							    		 ↓
					    ----------								----------
						| 子任务 |								| 子任务 | 				---------------------
						----------								----------				|					|
							↓ forke								fork ↓					|   任务递归分配	|
				--------------------------			    --------------------------		|	成若干个小任务	|
				↓						 ↓				↓						 ↓		|					|
			----------				----------		----------				----------	---------------------
			| 子任务 |				| 子任务 |		| 子任务 |				| 子任务 |
			----------				----------		----------				----------
			--------------------------------------------------------------------------- ---------------------
				↓						 ↓				↓						 ↓		| 	  				|
			----------				----------		----------				----------  |	   并行求值		|
			|		 |				|		 |		|		 |				|		 |	|					|
			----------				----------		----------				----------	---------------------
				|		  Join			 |				|		  Join			 |
				--------------------------				--------------------------
							↓										↓					---------------------
						---------			join				---------				|					|
						|		| -----------------------------	|		|				|	合并部分结果	|
						---------			  |					---------				|					|
											  ↓											---------------------
											-----
											|	|
											-----
		② 代码
			import java.util.concurrent.RecursiveTask;

			public class ForkJoinTask extends RecursiveTask<Long> {

				private Long start;

				private Long end;

				private static final Long THRESHOL = 10000L;

				public ForkJoinTask(Long start, Long end) {
					this.start = start;
					this.end = end;
				}

				@Override
				protected Long compute() {

					long length = end - start;

					if (length <= THRESHOL) {

						long sum = 0;

						for (long i = start; i <= end; i++) {
							sum += i;
						}

						return sum;
					} else {

						long middle = (start + end) / 2;

						ForkJoinTask left = new ForkJoinTask(start, middle);
						left.fork();

						ForkJoinTask right = new ForkJoinTask(middle + 1, end);
						right.fork();

						return left.join() + right.join();
					}
				}
			}
			
			public void testForkJoinTask() {

				Instant startTime = Instant.now();

				ForkJoinPool forkJoinPool = new ForkJoinPool();

				ForkJoinTask forkJoinTask = new ForkJoinTask(0L, 50000000000L);

				Long sum = forkJoinPool.invoke(forkJoinTask);

				System.out.println(sum);

				Instant endTime = Instant.now();
				System.out.println(Duration.between(startTime, endTime).toMillis()); // 277 5808 35519
			}
	
	2. Fork / Join 框架与传统线程池的区别
		① 	采用“工作窃取”模式（work-stealing）: 当执行新的任务时它可以将其拆分成更小的任务执行，并将小任务加到线程队列中，
		然后再从随机线程的队列中偷一个并把它放在自己的队列中
		② 相对于一般的线程池实现，fork /join 框架的优势体现于现在对其中包含的任务的处理方式上，在一般的线程会处于等待状态，
		而Fork / Join 框架实现中，如果某个子问题由于等待另一个子问题的完成而无法继续运行，那么处理该子问题的线程会主动寻找
		其他尚未运行的子问题来执行，这种方式减少了线程等待的时间，提高了性能
	3. 并行流与顺序流
		① 并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流
		② Java 8 中将并行流进行了优化，我们很容易的对数据进行并行操作，Stream API 可以声明性地通过parallel()与
		sequential()在并行流与顺序流之间进行切换
		③ 代码：
			@Test
			public void testparallel() {

				Instant startTime = Instant.now();

				long sum = LongStream.rangeClosed(0, 50000000000L)
						.parallel()
						.reduce(0, Long::sum);

				System.out.println(sum);

				Instant endTime = Instant.now();
				System.out.println(Duration.between(startTime, endTime).toMillis()); // 18555
			}
六、Optional 类
	1. Optional<T>（java.util.Optional） 类是一个容器类，代表一个值存在或者不存在，原来null表示一个值不存在，现在Optional可以
	更好的表达这个概念，并且避免空指针异常
	2. 常用API
		① Optional.of(T t)：创建一个Optional实例
		② Optional.empty()：创建一个空的Optional实例
		③ Optional.ofNullable(T t)：若 t 不为null，创建Optional实例，否则创建空实例
		④ isPresent()：判断是否包含值
		⑤ orElse(T t)：如果调用对象包含值，返回改值，否则返回t
		⑥ orElseGet(Supplier s)：如果调用对象包含值，返回该值，否则返回s获取的值
		⑦ map(Function f)：如果有值对其进行处理，并返回处理后的Optional，否则返回Optional.empty()
		⑧ flatMap(Function mapper)：与map类似，要求返回值必须是Optional
七、接口中的默认方法与静态方法
	1. 接口中的默认方法
		① Java 8 中允许接口中包含具有实现的方法，该方法称为“默认方法”，默认方法使用default关键字修饰。
		② 代码：
			public interface DefaultMethod {
    
				void test();
				
				default String hello() {
					return "Hello";
				}
			}
		③ 接口中默认方法的“类优先”原则
			A. 若接口中定义了一个默认方法，而另一个父类或者接口中又定义了一个同名的方法时，选择父类中的方法。如果一个父类提供了
			具体实现，那么接口中具有相同名称和参数的默认方法会被忽略
				a. 代码
					public class SameMethodClass {

						public String hello() {
							return "Hello WOrld";
						}
					}
					
					public class DefaultMethodInterfaceImpl extends SameMethodClass implements DefaultMethodInterface {

						@Override
						public void test() {
							DefaultMethodInterfaceImpl defaultMethodInterfaceImpl = new DefaultMethodInterfaceImpl();
							String hello = defaultMethodInterfaceImpl.hello();
							System.out.println(hello);
						}

						public static void main(String[] args) {
							DefaultMethodInterfaceImpl defaultMethodInterface = new DefaultMethodInterfaceImpl();
							defaultMethodInterface.test();
						}
					}
				b. 输出：Hello WOrld	
			B. 接口冲突，如果一个父接口提供了一个默认方法，而另一个接口也提供了	一个具有相同名称和参数列表的方法（不管方法是否默认），
			那么必须覆盖该方法来解决冲突.
				a. 代码：
					public class SameMethodClass {

						public String hello() {
							return "Hello WOrld";
						}
					}
				
					import com.li.java8.interfact.DefaultMethodInterface;
					import com.li.java8.interfact.SameMethodInterface;

					public class SameMethodInterfaceImpl implements DefaultMethodInterface, SameMethodInterface {

						@Override
						public void test() {
							SameMethodInterfaceImpl sameMethodInterface = new SameMethodInterfaceImpl();
							System.out.println(sameMethodInterface.hello());
						}

						@Override
						public String hello() {
							return SameMethodInterface.super.hello();
						}

						public static void main(String[] args) {
							SameMethodInterfaceImpl sameMethodInterface = new SameMethodInterfaceImpl();
							sameMethodInterface.test();
						}
					}
				b. 输出：Hello LiXL
	2. 接口中的静态方法
		public interface SameMethodInterface {

			default String hello() {
				return "Hello LiXL";
			}

			public static String say() {
				return "hello";
			}
		}
八、新时间日期API
	1. 传统时间日期格式化的线程安全
		① 代码
			public class DateFormateTest {

				public static void main(String[] args) throws Exception {
					SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

					Callable<Date> task = new Callable<Date>() {
						@Override
						public Date call() throws Exception {
							return sdf.parse("2020-11-24");
						}
					};

					ExecutorService pool = Executors.newFixedThreadPool(10);

					List<Future<Date>> futures = new ArrayList<>();

					for (int i = 0; i < 10; i++) {
						futures.add(pool.submit(task));
					}

					for (Future<Date> future : futures) {
						System.out.println(future.get());
					}
					
					pool.shutdown();
				}
			}
		② 解决方法：为时间格式化对象加上锁
			public class DateFormateThreadLocal {

					private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {
						@Override
						protected DateFormat initialValue() {
							return new SimpleDateFormat("yyyy-MM-dd");
						}
					};

					public static Date convert(String source) throws ParseException {
						return df.get().parse(source);
					}

				}
	2. 使用LocalDate、LocalTime和LocalDateTime
		① LocalDate、LocalTime和LocalDateTime类的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间和日期时间。
		它们提供了简单的日期或者时间，并不包含当前时间信息，也不包含时区相关信息
		② 注：ISO-8601日历系统是国际标准化组织制定的现代公民日期和时间表示法
		③ LocalDate、LocalTime和LocalDateTime的API：
			A. LocalDateTime LocalDateTime.now()：获取当前系统时间
			B. LocalDateTime LocalDateTime.of(int year, Month month, int dayOfMonth, int hour, int minute, int second)：指定年月日时分秒获取时间对象
			C. LocalDateTime plusMinutes(long minutes)：在指定的时间的基础上可以增加年、月、日、时、分、秒等。
			D. LocalDateTime minusHours(long hours)：在指定的时间的基础上可以减少年、月、日、时、分、秒等。
			E. int getDayOfMonth()/DayOfWeek getDayOfWeek()：在指定的时间中获取年份、月份、月的某天、星期的某天或者小时、分钟、秒等
				LocalDateTime dateTime = LocalDateTime.now();
				System.out.println(dateTime.getYear()); 
				System.out.println(dateTime.getMonthValue());
				System.out.println(dateTime.getDayOfMonth());
				System.out.println(dateTime.getHour());
				System.out.println(dateTime.getMinute());
				System.out.println(dateTime.getSecond());
				DayOfWeek dayOfWeek = dateTime.getDayOfWeek();
				System.out.println(dayOfWeek); // 	WEDNESDAY
				System.out.println(dateTime.getDayOfYear());
		④ 获取秒数：
			A. long toEpochSecond(ZoneOffset offset)
			B. 举例：
				LocalDateTime dateTime = LocalDateTime.now();
				long second = dateTime.toEpochSecond(ZoneOffset.ofHours(0))
	3. Instant
		① 时间戳（以 Unix 元年：1900-01-01 00:00:00 之间的毫秒值）
		② Instant 的 API
			A. Instant Instant.now()：获取当前时间，默认获取UTC时区（世界协调时间）
			B. OffsetDateTime atOffset(ZoneOffset offset)：设置时区偏移量，得到带偏移量的时间
				OffsetDateTime offsetDateTime = ins.atOffset(ZoneOffset.ofHours(8)); // 2020-11-25T22:48:39.455+08:00
			C. long toEpochMilli()：获取时间戳
			D. Instant Instant.ofEpochSecond(long epochSecond)：相对于元年的基础，加上某个时间单位
				System.out.println(Instant.ofEpochSecond(1)); // 1970-01-01T00:00:01Z
	4. Duration和Period
		① Duration：计算两个时间之间的间隔
		② Period：计算两个日期之间的间隔
		③ Duration 的API
			A Duration Duration.between(Temporal startInclusive, Temporal endExclusive)：计算两个时间之间的间隔，Duration是OS显示时间间隔的格式
				Instant ins1 = Instant.now();

				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
				}

				Instant ins2 = Instant.now();

				Duration duration = Duration.between(ins1, ins2);
				System.out.println(duration); // PT1.009S
			B long toMillis()：获取计算两个时间的间隔转换成毫秒
				System.out.println(duration.toMillis()); // 1001
		④ Period 的 API：
			A. 	Period Period.between(LocalDate startDateInclusive, LocalDate endDateExclusive)：计算两个日期之间的间隔，Period是OS显示时间间隔的格式
				LocalDate date1 = LocalDate.now();

				LocalDate date2 = LocalDate.of(1996, 5, 4);

				Period period = Period.between(date2, date1);
				System.out.println(period);
			B. int getYears()、int getMonths()、int getDays()：获取计算两个日期的间隔转换成年、月、日
				System.out.println(period.getYears());
				System.out.println(period.getMonths());
				System.out.println(period.getDays());
	5. 日期的操纵
		① TemporalAdjuster：时间校正器。有时候我们可能需要获取例如：将日期调整到“下个周日”等操作
		② TemporalAdjusters：该类通过静态方法提供了大量的常用TemporalAdjuster的实现
		③ TemporalAdjuster 和 TemporalAdjusters 的API：
			A. LocalDate with(TemporalAdjuster adjuster)：日期计算，需要传时间校正器对象 TemporalAdjuster，可以由TemporalAdjusters获取
				LocalDate localDate = LocalDate.now();
				System.out.println(localDate);
				LocalDate nextSATURDAY = localDate.with(TemporalAdjusters.next(DayOfWeek.SATURDAY)); // 获取下个周六的日期
				System.out.println(nextSATURDAY);
			B. LocalDate withDayOfMonth(int dayOfMonth)：获取当前月份的某一天的日期
				LocalDate withDayOfMonth = localDate.withDayOfMonth(10);
			C.  自定义日期时间校正规则
				@Test
				public void testWith() {
					LocalDate localDate = LocalDate.now();
					System.out.println(localDate);
					LocalDate with = localDate.with((l) -> {
						LocalDate date = (LocalDate) l;
						DayOfWeek dayOfWeek = date.getDayOfWeek();
						if (dayOfWeek.equals(DayOfWeek.FRIDAY)) {
							return date.plusDays(3);
						} else if (dayOfWeek.equals(DayOfWeek.SATURDAY)) {
							return date.plusDays(2);
						} else {
							return date.plusDays(1);
						}
					});
					System.out.println(with);
				}
	6. DateTimeFormatter
		① 日期格式化
		② DateTimeFormatter 的 API
			A. DateTimeFormatter DateTimeFormatter.ISO_DATE：DateTimeFormatter提供了多个ISO标准的时间格式化器
				LocalDateTime dateTime = LocalDateTime.now();
				String dateStr = dateTime.format(dft);
				System.out.println(dateStr);
			B. DateTimeFormatter DateTimeFormatter.ofPattern(String pattern)：自定义时间格式
				DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
				String dateTime = dateTimeFormatter.format(LocalDateTime.now());
				System.out.println(dateTime);
			C. LocalDateTime LocalDateTime.parse(CharSequence text, DateTimeFormatter formatter)：将时间字符串转换为时间对象
	7. 时区的处理
		① Java 8中加入了对时区的支持，带时区的时间分别为：ZonedDate、ZonedTime、ZonedDateTime，其中每个时区都对应着ID，地区ID
		都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等
		② ZoneId：该类中包含了所有的时区信息
		③ ZoneId 的 API
			A. Set<String> ZoneId.getAvailableZoneIds()：获取所有的时区
			B. LocalDateTime LocalDateTime.now(ZoneId.of(String ZoneId))：获取指定时区的时间
				LocalDateTime dateTime = LocalDateTime.now(ZoneId.of("America/New_York"));
			C. ZonedDateTime dateTime.atZone(ZoneId.of(String ZoneId))：返回与UTC标准时间的时差并且带时区信息的时间
				LocalDateTime dateTime = LocalDateTime.now(ZoneId.of("America/New_York"));
				ZonedDateTime zonedDateTime = dateTime.atZone(ZoneId.of("America/New_York"));
				System.out.println(zonedDateTime); // 2020-11-28T09:49:38.658-05:00[America/New_York]
			D. java.util.Date 与 java.time.LocalDateTime 的相互转换
				SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
				
				// Date 转换为 LocalDateTime
				Date date = new Date();
				System.out.println(sdf.format(date));
				LocalDateTime dateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
				System.out.println(dateTime.format(dtf));

				// LocalDateTime 转换为 Date
				Date date1 = Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());
				System.out.println(sdf.format(date1));
			E. java.time.LocalDateTime 转换成 java.time.Instant
				LocalDateTime dateTime = LocalDateTime.now();
				Instant instant = dateTime.toInstant(ZoneOffset.ofHours(0));
九、重复注解与类型注解
	1. 重复注解
		① 定义一个注解
			@Repeatable(MyAnnotations.class)
			@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
			@Retention(RetentionPolicy.RUNTIME)
			public @interface MyAnnotation {

				String value() default "LiXL";
			}
		② 此时并不能使用重复注解，需要定义重复注解容器
			@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
			@Retention(RetentionPolicy.RUNTIME)
			public @interface MyAnnotations {

				MyAnnotation[] value();
			}
		③ 需要在注解类上使用@Repeatable(MyAnnotations.class)指定该注解是可以重复的，并且指明注解容器
		④ 注：注解类和注解容器的成员方法的名称需要保持一致
		⑤ 在方法上可重复标注该注解，并且使用反射获取该方法上的注解
			@Test
			public void testAnnotation() {
				Class<AnnotationTest> clazz = AnnotationTest.class;
				try {
					Method method = clazz.getMethod("testAnnotations");
					List<MyAnnotation> myAnnotations = Arrays.asList(method.getAnnotationsByType(MyAnnotation.class));
					myAnnotations.forEach(a -> System.out.println(a.value()));
				} catch (NoSuchMethodException e) {
					e.printStackTrace();
				}
			}

			@MyAnnotation("Hello")
			@MyAnnotation("World")
			public void testAnnotations() {

			}
	3. 类型注解：可在参数上使用注解标注
		① 在注解类上的 @Target 上添加 TYPE_PARAMETER 枚举对象
		② 在方法的方法的参数走使用该注解
		③ 相关代码
			@Repeatable(MyAnnotations.class)
			@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, TYPE_PARAMETER})
			@Retention(RetentionPolicy.RUNTIME)
			public @interface MyAnnotation {

				String value() default "LiXL";
			}
		
			public void testAnnotations(@MyAnnotation String value) {
				System.out.println(value);
			}