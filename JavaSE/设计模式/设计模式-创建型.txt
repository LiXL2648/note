一、设计模式七大原则
	1. 设计模式的目的
		① 编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，
		具有更好
			A. 代码重用性（相同功能的代码，不用多次编写）
			B. 可读性（编程规范性, 便于其他程序员的阅读和理解）
			C. 可扩展性（当需要增加新的功能时，非常的方便，称为可维护）
			D. 可靠性（当我们增加新的功能后，对原来的功能没有影响）
			E. 使程序呈现高内聚，低耦合的特性
		② 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”
		③ Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤疤
	2. 设计模式七大原则
		① 设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即：设计模式为什么这样设计的依据）
		② 设计模式常用的七大原则有
			A. 单一职责原则
			B. 接口隔离原则
			C. 依赖倒转（倒置）原则
			D. 里氏替换原则
			E. 开闭原则
			F. 迪米特法则
			G. 合成复用原则
		③ 单一职责原则
			A. 基本介绍：对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执
			行错误，所以需要将类A的粒度分解为 A1，A2
			B. 应用实例
				a. 违反单一职责原则
					public class SingleResponsibility1 {
						public static void main(String[] args) {
							Vehicle vehicle = new Vehicle();
							vehicle.run("公车");
							vehicle.run("汽车");
							vehicle.run("火车");
						}
					}

					/**
					 * 违反了单一职责原则
					 * 根据交通工具运行方式不同，分解成不同类即可
					 */
					class Vehicle {
						public void run(String vehicle) {
							System.out.println(vehicle + "在公里上运行");
						}
					}
				b. 在类上遵循单一职责
					public class SingleResponsibility2 {
						public static void main(String[] args) {
							RoadVehicle roadVehicle = new RoadVehicle();
							roadVehicle.run("公车");
							roadVehicle.run("汽车");

							RailVehicle railVehicle = new RailVehicle();
							railVehicle.run("火车");
						}
					}

					/**
					 * 遵守单一职责原则
					 * 但是这样做的改动很大，既将类分解，同时修改客户端
					 * 直接修改 Vehicle 类，改动的代码会比较少
					 */
					class RoadVehicle {
						public void run(String vehicle) {
							System.out.println(vehicle + "在公里上运行");
						}
					}

					class RailVehicle {
						public void run(String vehicle) {
							System.out.println(vehicle + "在铁轨上运行");
						}
					}
				c. 在方法上遵循单一职责
					public class SingleResponsibility3 {
						public static void main(String[] args) {
							Vehicle2 vehicle = new Vehicle2();
							vehicle.runRoad("公车");
							vehicle.runWater("轮船");
							vehicle.runRail("火车");
						}
					}

					/**
					 * 这种修改方法没有对原来的类最大的修改，只是增加了方法
					 * 虽然没有在类的级别上遵守单一职责原则，但是在方法上，仍然是遵守单一职责原则的
					 */
					class Vehicle2 {

						public void runRoad(String vehicle) {
							System.out.println(vehicle + "在公里上运行");
						}

						public void runWater(String vehicle) {
							System.out.println(vehicle + "在水上运行");
						}

						public void runRail(String vehicle) {
							System.out.println(vehicle + "在铁轨上运行");
						}
					}
			C. 单一职责原则注意事项和细节
				a. 降低类的复杂度，一个类只负责一项职责。
				b. 提高类的可读性，可维护性
				c. 降低变更引起的风险
				d. 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级
				别保持单一职责原则
		④ 接口隔离原则（Interface Segregation Principle）
			A. 基本介绍：
				a. 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上
				b. 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须
				去实现他们不需要的方法。
				+-------------------+
				| A 通过 Interface1	|
				| 会依赖（使用）B	|
				| 但是 A 中只会使用 |
				| 到接口的 1，2，3	|
				| 三个方法			|
				+-------------------+
					|				+--------------------+
					|				|	I Interface1	 |
				+-----+				+--------------------+				+-----+
				| C A |------------>| operaction1() void |《------------| C B |
				+-----+				| operaction2() void |				+-----+
									| operaction3() void |				
				+-----+				| operaction4() void |				+-----+
				| C C |------------>| operaction5() void |《------------| C D |
				+-----+				+--------------------+				+-----+
					|
					|
				+-------------------+
				| C 通过 Interface1	|
				| 会依赖（使用）D	|
				| 但是 C 中只会使用 |
				| 到接口的 1，4，5	|
				| 三个方法			|
				+-------------------+
				c. 按隔离原则应当这样处理：将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则
			B. 违法接口隔离原则应用实例
				public class Segregation1 {

					public static void main(String[] args) {
						A a = new A();
						a.depend1(new B());
						a.depend2(new B());
						a.depend3(new B());

						C c = new C();
						c.depend1(new D());
						c.depend4(new D());
						c.depend5(new D());
					}
				}

				/**
				 * A 通过 Interface1 会依赖（使用）B
				 * 但是 A 中只会使用到接口的 1，2，3 三个方法
				 */
				class A {
					public void depend1(Interface1 interface1) {
						interface1.operation1();
					}

					public void depend2(Interface1 interface1) {
						interface1.operation2();
					}

					public void depend3(Interface1 interface1) {
						interface1.operation3();
					}
				}

				/**
				 * C 通过 Interface1 会依赖（使用）D
				 * 但是 C 中只会使用到接口的 1，4，5 三个方法
				 */
				class C {
					public void depend1(Interface1 interface1) {
						interface1.operation1();
					}

					public void depend4(Interface1 interface1) {
						interface1.operation4();
					}

					public void depend5(Interface1 interface1) {
						interface1.operation5();
					}
				}

				class B implements Interface1 {

					@Override
					public void operation1() {
						System.out.println("B实现了operation1方法");
					}

					@Override
					public void operation2() {
						System.out.println("B实现了operation2方法");
					}

					@Override
					public void operation3() {
						System.out.println("B实现了operation3方法");
					}

					@Override
					public void operation4() {
						System.out.println("B实现了operation4方法");
					}

					@Override
					public void operation5() {
						System.out.println("B实现了operation5方法");
					}
				}

				class D implements Interface1 {

					@Override
					public void operation1() {
						System.out.println("D实现了operation1方法");
					}

					@Override
					public void operation2() {
						System.out.println("D实现了operation2方法");
					}

					@Override
					public void operation3() {
						System.out.println("D实现了operation3方法");
					}

					@Override
					public void operation4() {
						System.out.println("D实现了operation4方法");
					}

					@Override
					public void operation5() {
						System.out.println("D实现了operation5方法");
					}
				}

				interface Interface1 {
					void operation1();
					void operation2();
					void operation3();
					void operation4();
					void operation5();
				}
			C. 应传统方法的问题和使用接口隔离原则改进
				a. 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去
				实现他们不需要的方法
				b. 将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则
				c. 接口Interface1中出现的方法，根据实际情况拆分为三个接口
											+--------------------+
											|	I Interface2	 |
											+--------------------+
									+------>| operaction1() void |◁-----+▲
					+-----+			|		+--------------------+		|		+-----+
					| C A |---------+									+-------| C B |
					+-----+			|		+--------------------+		|		+-----+
									|		|	I Interface3	 |		|
									|		+--------------------+		|
									+------>| operaction2() void |◁-----+▲
									+------>| operaction3() void |◁-----+▲
					+-----+			|		+--------------------+		|		+-----+
					| C C |---------+									+-------| C D |
					+-----+			|		+--------------------+		|		+-----+
									|		|	I Interface4	 |		|
									|		+--------------------+		|
									+------>| operaction4() void |◁-----+▲
											| operaction5() void |
											+--------------------+
				d. 代码实现
					public class Segregation2 {
						public static void main(String[] args) {
							A1 a1 = new A1();
							a1.depend1(new B1());
							a1.depend2(new B1());
							a1.depend3(new B1());

							C1 c1 = new C1();
							c1.depend1(new D1());
							c1.depend4(new D1());
							c1.depend5(new D1());
						}
					}

					class A1 {
						public void depend1(Interface2 interface2) {
							interface2.operation1();
						}

						public void depend2(Interface3 interface3) {
							interface3.operation2();
						}

						public void depend3(Interface3 interface3) {
							interface3.operation3();
						}
					}

					class C1 {
						public void depend1(Interface2 interface2) {
							interface2.operation1();
						}

						public void depend4(Interface4 interface4) {
							interface4.operation4();
						}

						public void depend5(Interface4 interface4) {
							interface4.operation5();
						}
					}

					class B1 implements Interface2, Interface3 {
						@Override
						public void operation1() {
							System.out.println("B1实现了operation1方法");
						}

						@Override
						public void operation2() {
							System.out.println("B1实现了operation2方法");
						}

						@Override
						public void operation3() {
							System.out.println("B1实现了operation3方法");
						}
					}

					class D1 implements Interface2, Interface4 {
						@Override
						public void operation1() {
							System.out.println("D1实现了operation1方法");
						}

						@Override
						public void operation4() {
							System.out.println("D1实现了operation4方法");
						}

						@Override
						public void operation5() {
							System.out.println("D1实现了operation5方法");
						}
					}

					interface Interface2 {
						void operation1();
					}

					interface Interface3 {
						void operation2();
						void operation3();
					}

					interface Interface4 {
						void operation4();
						void operation5();
					}
		⑤ 依赖倒转（倒置）原则
			A. 基本介绍，依赖倒转原则(Dependence Inversion Principle)是指：
				a. 高层模块不应该依赖低层模块，二者都应该依赖其抽象
				b. 抽象不应该依赖细节，细节应该依赖抽象
				c. 依赖倒转(倒置)的中心思想是面向接口编程
				d. 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的
				多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类
				e. 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成
			B. 应用实例
				public class Inversion1 {

					public static void main(String[] args) {
						Person person = new Person();
						person.receive(new Email());
					}
				}

				class Email {

					public String getInfo() {
						return "邮件信息：Hello World";
					}
				}

				/**
				 * 如果获取的对象是微信、短信等，则需要新增类，同时Person也要增加相应的接收方法
				 * 解决思想：引入一个抽象接口 IReceive，表示接收者，这样Person类与接口IReceive发生依赖
				 */
				class Person {

					public void receive(Email email) {
						System.out.println(email.getInfo());
					}
				}
			C. 使用依赖倒转（倒置）原则进行优化
				public class Inversion2 {

					public static void main(String[] args) {
						Phone phone = new Phone();
						phone.receive(new Sms());
						phone.receive(new Wx());
					}
				}

				class Phone {

					public void receive(IReceive receive) {
						System.out.println(receive.getInfo());
					}
				}
				class Wx implements IReceive {

					@Override
					public String getInfo() {
						return "微信消息：Hello World";
					}
				}
				class Sms implements IReceive {

					@Override
					public String getInfo() {
						return "短信消息：Hello World";
					}
				}
				interface IReceive {

					String getInfo();
				}
			D. 依赖关系传递的三种方式和应用案例
				a. 接口传递
					public void receive(IReceive receive) {
						System.out.println(receive.getInfo());
					}
				b. 构造方法传递
					private IReceive receive;

					public Phone(IReceive receive) {
						this.receive = receive;
					}
					
					public void receive() {
						System.out.println(receive.getInfo());
					}
				c. setter方式传递
					private IReceive receive;

					public void setReceive(IReceive receive) {
						this.receive = receive;
					}
					
					public void receive() {
						System.out.println(receive.getInfo());
					}
			E. 依赖倒转原则的注意事项和细节
				a. 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
				b. 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
				c. 继承时遵循里氏替换原则
		⑥ 里氏替换原则
			A. OO中的继承性的思考和说明
				a. 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果
				子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。
				b. 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类
				被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障
				c. 问题提出：在编程中，如何正确的使用继承？里氏替换原则
			B. 基本介绍
				a. 里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院的以为姓里的女士提出的。
				b. 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那
				么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。
				c. 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
				d. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题。
			C. 违法里氏替换原则的示例
				public class Liskov1 {
					public static void main(String[] args) {
						A a = new A();
						System.out.println("11-3=" + a.func1(11, 3));
						System.out.println("1-8=" + a.func1(1, 8));
						System.out.println("-----------------------");
						B b = new B();
						System.out.println("11-3=" + b.func1(11, 3));
						System.out.println("1-8=" + b.func1(1, 8));
						System.out.println("11+3+9=" + b.func2(11, 3));
					}
				}

				class A {
					public int func1(int num1, int num2) {
						return num1 - num2;
					}
				}

				class B extends A {
					public int func1(int a, int b) {
						return a + b;
					}

					public int func2(int a, int b) {
						return func1(a, b) + 9;
					}
				}
			D. 解决方法
				a. 发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父
				类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候
				b. 通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替。
				c. 代码实现
					public class Liskov2 {
						public static void main(String[] args) {
							C a = new C();
							System.out.println("11-3=" + a.func1(11, 3));
							System.out.println("1-8=" + a.func1(1, 8));
							System.out.println("-----------------------");
							D b = new D();
							System.out.println("11+3=" + b.func1(11, 3));
							System.out.println("1+8=" + b.func1(1, 8));
							System.out.println("11+3+9=" + b.func2(11, 3));
							System.out.println("-----------------------");
							System.out.println("11-3=" + b.func3(11, 3));
						}
					}

					class Base {

					}

					class C extends Base {
						public int func1(int num1, int num2) {
							return num1 - num2;
						}
					}

					class D extends Base {

						// 使用组合关系，在D中使用C的方法
						C c = new C();

						public int func1(int a, int b) {
							return a + b;
						}

						public int func2(int a, int b) {
							return func1(a, b) + 9;
						}

						public int func3(int a, int b) {
							return this.c.func1(a, b);
						}
					}
		⑦ 开闭原则
			A. 基本介绍
				a. 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则
				b. 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节
				c. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
				d. 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则
			B. 案例--画图形功能示例
				a. 类图
								+------------------------+
								| 	 C GraphicEditor	 |
								+------------------------+
								| +drawShape(): void	 |
								| +drawRectangle(): void |
								| +drawCircle(): void	 |
								+------------------------+
											|
											|
							+---------------+---------------+
							|				|				|
							↓				↓				↓
					+-----------+		+-------+		+--------+
					| Rectangle |------▷| Shape |◁------| Circle |▲
					+-----------+		+-------+		+--------+
				b. 代码实现
					public class GraphicEditorDemo1 {
						public static void main(String[] args) {
							GraphicEditor graphicEditor = new GraphicEditor();
							graphicEditor.drawShape(new Rectangle());
							graphicEditor.drawShape(new Circle());
						}
					}

					// 调用方
					class GraphicEditor {
						public void drawShape(Shape shape) {
							if (shape.type == 1) {
								drawRectangle();
							} else if (shape.type == 2) {
								drawCircle();
							}
						}
						private void drawRectangle() {
							System.out.println("绘制矩形");
						}

						private void drawCircle() {
							System.out.println("绘制圆形");
						}
					}

					class Shape {
						int type;
					}

					class Rectangle extends Shape {
						Rectangle() {
							super.type = 1;
						}
					}

					class Circle extends Shape {
						Circle() {
							super.type = 2;
						}
					}
			C. 案例优缺点
				a. 优点是比较好理解，简单易操作。
				b. 缺点是违反了设计模式的ocp原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能
				少修改代码
				c. 比如这时要新增加一个图形种类三角形，我们需要做如下修改，修改的地方较多
				d. 代码实现
					class Triangle extends Shape {
						Triangle() {
							super.type = 3;
						}
					}
					
					// 调用方
					class GraphicEditor {
						public void drawShape(Shape shape) {
							// ...
							} else if (shape.type == 3) {
								drawTriangle();
							}
							
							private void drawTriangle() {
								System.out.println("绘制三角形");
							}
						}
					}
					
					public class GraphicEditorDemo1 {
						public static void main(String[] args) {
							// ...
							graphicEditor.drawShape(new Triangle());
						}
					}
			D. 案例改进
				a. 思路：把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可，这样有新的图形种类时，只需要让新的图形类继承Shape，并实
				现draw方法即可
				b. 使用方的代码就不需要修 -> 满足了开闭原则
				c. 代码实现
					public class GraphicEditorDemo2 {

						public static void main(String[] args) {
							GraphicEditor1 graphicEditor = new GraphicEditor1();
							graphicEditor.drawShape(new Rectangle1());
							graphicEditor.drawShape(new Circle1());
							graphicEditor.drawShape(new Triangle1());
							graphicEditor.drawShape(new OtherGraphic());
						}
					}

					class GraphicEditor1 {
						public void drawShape(Shape1 shape) {
							shape.drawShape();
						}
					}

					class Rectangle1 extends Shape1 {
						Rectangle1() {
							super.type = 1;
						}

						@Override
						public void drawShape() {
							System.out.println("绘制矩形");
						}
					}

					class Circle1 extends Shape1 {
						Circle1() {
							super.type = 2;
						}

						@Override
						public void drawShape() {
							System.out.println("绘制圆形");
						}
					}

					class Triangle1 extends Shape1 {
						Triangle1() {
							super.type = 3;
						}

						@Override
						public void drawShape() {
							System.out.println("绘制三角形");
						}
					}

					class OtherGraphic extends Shape1 {
						OtherGraphic() {
							super.type = 4;
						}

						@Override
						public void drawShape() {
							System.out.println("绘制其他图形");
						}
					}

					abstract class Shape1 {
						int type;

						abstract void drawShape();
					}
		⑧ 迪米特法则
			A. 基本介绍
				a. 一个对象应该对其他对象保持最少的了解
				b. 类与类关系越密切，耦合度越大
				c. 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将
				逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息
				d. 迪米特法则还有个更简单的定义：只与直接的朋友通信
				e. 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，
				关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，
				陌生的类最好不要以局部变量的形式出现在类的内部。
			B. 应用实例
				a. 有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id
				b. 代码实现
					public class Demeter1 {

						public static void main(String[] args) {
							SchoolManager schoolManager = new SchoolManager();
							schoolManager.printAllEmployee(new CollegeManager());
						}
					}

					// 学校总部员工类
					class Employee {
						private final int id;

						public Employee(int id) {
							this.id = id;
						}

						public int getId() {
							return id;
						}
					}

					// 学院的职工类
					class CollegeEmployee {
						private final int id;

						public CollegeEmployee(int id) {
							this.id = id;
						}

						public int getId() {
							return id;
						}
					}

					class CollegeManager {
						public List<CollegeEmployee> getAllEmployee() {
							List<CollegeEmployee> list = new ArrayList<>();
							for (int i = 0; i < 10; i++) {
								list.add(new CollegeEmployee(i));
							}
							return list;
						}
					}

					class SchoolManager {
						public List<Employee> getAllEmployee() {
							List<Employee> list = new ArrayList<>();
							for (int i = 0; i < 5; i++) {
								list.add(new Employee(i));
							}
							return list;
						}

						public void printAllEmployee(CollegeManager sub) {
							// CollegeEmployee类并不是SchoolManager类的直接朋友
							List<CollegeEmployee> collegeEmployeeList = sub.getAllEmployee();
							for (CollegeEmployee collegeEmployee : collegeEmployeeList) {
								System.out.println(collegeEmployee.getId());
							}

							System.out.println();
							List<Employee> employeeList = getAllEmployee();
							for (Employee employee : employeeList) {
								System.out.println(employee.getId());
							}
						}
					}
			C. 应用实例改进
				a. 前面设计的问题在于SchoolManager中，CollegeEmployee类并不是SchoolManager类的直接朋友
				b. 按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合
				c. 对代码按照迪米特法则进行改进
				d. 代码实现
					public class Demeter2 {

						public static void main(String[] args) {
							SchoolManager1 schoolManager = new SchoolManager1();
							schoolManager.printAllEmployee(new CollegeManager1());
						}
					}

					// 学校总部员工类
					class Employee1 {
						private final int id;

						public Employee1(int id) {
							this.id = id;
						}

						public int getId() {
							return id;
						}
					}

					// 学院的职工类
					class CollegeEmployee1 {
						private final int id;

						public CollegeEmployee1(int id) {
							this.id = id;
						}

						public int getId() {
							return id;
						}
					}

					class CollegeManager1 {
						private List<CollegeEmployee1> getAllEmployee() {
							List<CollegeEmployee1> list = new ArrayList<>();
							for (int i = 0; i < 10; i++) {
								list.add(new CollegeEmployee1(i));
							}
							return list;
						}

						public void printAllEmployee() {
							List<CollegeEmployee1> collegeEmployeeList = getAllEmployee();
							for (CollegeEmployee1 collegeEmployee : collegeEmployeeList) {
								System.out.println(collegeEmployee.getId());
							}
						}
					}

					class SchoolManager1 {
						public List<Employee1> getAllEmployee() {
							List<Employee1> list = new ArrayList<>();
							for (int i = 0; i < 5; i++) {
								list.add(new Employee1(i));
							}
							return list;
						}

						public void printAllEmployee(CollegeManager1 sub) {
							// 将输出学院员工的方法，封装到 CollegeManager1
							sub.printAllEmployee();
							System.out.println();
							List<Employee1> employeeList = getAllEmployee();
							for (Employee1 employee : employeeList) {
								System.out.println(employee.getId());
							}
						}
					}
			D. 迪米特法则注意事项和细节
				a. 迪米特法则的核心是降低类之间的耦合
				b. 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系
		⑨ 合成复用原则
			A. 基本介绍：原则是尽量使用合成/聚合的方式，而不是使用继承
			B. 举例说明
			+--------------------+			+---------------------+
			| 		C A 		 |----------| 如果只是让B类去使用 |
			+--------------------+			| A类的方法，使用继承 |
			| operation1(): void |			| 就会让B和A的耦合性  |
			| operation2(): void |			| 增强				  |
			+--------------------+			+---------------------+
					   △
					   |
					   |
					+-----+
					| C B |
					+-----+
					
			+--------------------+
			| 		C A 		 | 
			+--------------------+		+-----+
			| operation1(): void |<-----| C B | 依赖
			| operation2(): void |		+-----+
			+--------------------+
			
			+--------------------+
			| 		C A 		 | 
			+--------------------+		+-----+
			| operation1(): void |----◁▷| C B | 聚合
			| operation2(): void |		+-----+
			+--------------------+
			
			+--------------------+
			| 		C A 		 | 
			+--------------------+		+-----+
			| operation1(): void |----◄►| C B | 组合
			| operation2(): void |		+-----+
			+--------------------+
	3. 设计原则核心思想
		① 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
		② 针对接口编程，而不是针对实现编程	
		③ 为了交互对象之间的松耦合设计而努力
二、UML类图
	1. UML基本介绍
		① UML——Unified modeling language UML(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录
		思路的结果
		② UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、
		泛化、依赖、组合、聚合等
		③ 使用UML来建模，常用的工具有 Rational Rose , 也可以使用一些插件来建模
	2. UML图
		① 画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML图分类：
			A. 用例图(use case)
			B. 静态结构图：类图、对象图、包图、组件图、部署图
			C. 动态行为图：交互图（时序图与协作图）、状态图、活动图
		② 说明：类图是描述类与类之间的关系的，是UML图中最核心的
	3. UML类图
		① 用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系
		② 类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合
		③ 依赖关系（Dependence）
			A. 只要是在类中用到了对方，那么他们之间就存在依赖关系
			B. 代码示例
				public class PersonService {
					private PersonDao personDao;//类

					public void save(Person person) {
					}

					public IDCard getIDCard(Integer personid) {
						return null;
					}

					public void modify() {
						Department department = new Department();
					}
				}
				
				public class PersonDao{}
				public class IDCard{}
				public class Person{}
				public class Department{}
			C. 依赖关系总结
				a. 类中用到了对方
				b. 如果是类的成员属性
				c. 如果是方法的返回类型
				d. 是方法接收的参数类型
				e. 方法中使用到
			D. UML 类图
										+--------------------------------------+
										| 			C PersonService			   |
										+--------------------------------------+
										| personDao: PersonDao				   |
										+--------------------------------------+
										| save(person: Person): void		   |
										| getIDCard(personid: Integer): IDCard |
										| modify(): void					   |
										+--------------------------------------+
															|
							+-----------------+-------------+---------------------------+
							↓				  ↓				↓							↓
					+-------------+		+----------+	+----------+			+--------------+
					| C PersonDao |		| C IDCard |	| C Person |			| C Department |
					+-------------+		+----------+	+----------+			+--------------+
		④ 泛化（继承）关系(generalization）
			A. 泛化关系实际上就是继承关系，是依赖关系的特例
			B. 代码示例
				public abstract class DaoSupport {
					public void save(Object entity) {
					}

					public void delete(Object id) {
					}
				}
				
				public class PersonService extends DaoSupport {

				}
			C. UML 类图
				+----------------------------+
				| 		A DaoSupport		 |
				+----------------------------+
				| save(entity: Object): void |
				| delete(id: Object): void	 |
				+----------------------------+
							△
							|
					+-----------------+
					| c PersonService |
					+-----------------+
		⑤ 实现关系（Implementation）
			A. 实现关系实际上就是A类实现B接口，他是依赖关系的特例
			B. 代码实现
				public interface PersonService {
					void delete(Integer id);
				}
				
				public class PersonServiceImpl implements PersonService {
					@Override
					public void delete(Integer id) {

					}
				}
			C. UML 类图
				+--------------------------+
				| 		I PersonService	   |
				+--------------------------+
				| delete(id: delete): void |
				+--------------------------+
							△
							.
							.
				+--------------------------+
				| 	C PersonServiceImpl	   |
				+--------------------------+
				| delete(id: delete): void |
				+--------------------------+
		⑥ 关联关系
			A. 关联关系实际上就是类与类之间的联系，他是依赖关系的特例
			B. 关联具有导航性：即双向关系或单向关系
			C. 关系具有多重性：如“1”（表示有且仅有一个），“0...”（表示0个或者多个），“0，1”（表示0个或者一个），“n...m”(表示n到 m个都可以)，
			“m...*”（表示至少m个）。
				a. 单向一对一关系
					public class Person {
						private IDCard card;
					}
					public class IDCard{}
				b. 双向一对一关系
					public class Person {
						private IDCard card;
					}
			D. UML 类图
				a. 单向一对一关系
					+----------+		  -card +----------+
					| C Person |--------------->| C IDCard |
					+----------+1			  1	+----------+
				b. 双向一对一关系
					+----------+ -person  -card +----------+
					| C Person |----------------| C IDCard |
					+----------+1			  1	+----------+
		⑦ 聚合关系（Aggregation）
			A. 聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。
			B. 如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：
			C. 代码实现
				public class Computer {

					private Mouse mouse;

					private Monitor monitor;

					public void setMouse(Mouse mouse) {
						this.mouse = mouse;
					}

					public void setMonitor(Monitor monitor) {
						this.monitor = monitor;
					}
				}
				
				public class Mouse {
				}
				
				public class Monitor {
				}
			D. UML 类图
				+------------------------------------+
				| 			   C Computer			 |
				+------------------------------------+
				| mouse: Mouse						 |
				| monitor: Monitor					 |
				+------------------------------------+
				| setMouse(mouse: Mouse): void		 |
				| setMonitor(monitor: Monitor): void |
				+------------------------------------+
								△
								▽
								|
				+---------------+--------------------+
				|									 |
			+---------+							+-----------+
			| C Mouse |							| C monitor |
			+---------+							+-----------+
		⑧ 组合关系（Composition）
			A. 组合关系：也是整体与部分的关系，但是整体与部分不可以分开。
			B. 定义实体：Person与IDCard、Head, 那么 Head 和Person 就是 组合，IDCard 和 Person 就是聚合。
			C. 但是如果在程序中Person实体中定义了对IDCard进行级联删除，即删除Person时连同IDCard一起删除，那么IDCard 和 Person 就是组合了
			D. 代码实现
				public class Person {
					private IDCard card;

					private final Head head = new Head();
				}
				public class IDCard {
				}
				public class Head {
				}
			E. UML 类图
							+--------------+
					+-----◄►| 	C Person   |◁▷------+        ▲
					|		+--------------+		|
					|		| card: IDCard |		|
					|		| head: Head   |		|
					|		+--------------+		|
				+---------+						+----------+
				|  C Head |						| C IDCard |
				+---------+						+----------+
三、设计模式概述
	1. 设计模式介绍
		① 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）
		代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
		② 设计模式的本质提高软件的维护性，通用性和扩展性，并降低软件的复杂度。
		③ <<设计模式>> 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称 “四人组 GOF”）
		④ 设计模式并不局限于某种语言，java，php，c++ 都有设计模式
	2. 设计模式类型
		① 设计模式分为三种类型，共23种
			A. 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
			B. 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
			C. 行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、
			状态模式、策略模式、职责链模式(责任链模式)。
四、单例模式
	1. 单例设计模式介绍
		① 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法
		(静态方法)。
		② 比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只
		需要一个SessionFactory就够，这是就会使用到单例模式。
	2. 单例设计模式八种方式
		① 单例模式有八种方式
			A. 饿汉式(静态常量)
			B. 饿汉式（静态代码块）
			C. 懒汉式(线程不安全)
			D. 懒汉式(线程安全，同步方法)
			E. 懒汉式(线程安全，同步代码块)
			F. 双重检查
			G. 静态内部类
			H. 枚举
		② 饿汉式（静态常量）
			A. 饿汉式（静态常量）应用实例
				a. 步骤如下
					(1) 构造器私有化 (防止 new)
					(2) 类的内部创建对象
					(3) 向外暴露一个静态的公共方法。getInstance
				b. 代码实现
					// 饿汉式（静态变量）
					public class Singleton1 {

						// 1. 构造器私有化，外部不能new
						private Singleton1() {

						}

						// 2. 本类内部创建对象实例
						private static final Singleton1 instance = new Singleton1();

						// 3. 提供一个公有的静态方法，返回实例对象
						public static Singleton1 getInstance() {
							return instance;
						}
					}
			B. 优缺点说明：
				a. 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。
				b. 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费
				c. 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，
				但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading
				的效果
				d. 结论：这种单例模式可用，可能造成内存浪费
		③ 饿汉式（静态代码块）
			A. 代码实现
				// 饿汉式（静态代码块）
					public class Singleton2 {

						// 1. 构造器私有化，外部不能new
						private Singleton2() {

						}

						// 2. 本类内部创建对象实例
						private static final Singleton2 instance;

						// 3. 静态代码块执行时，创建单例对象
						static {
							instance = new Singleton2();
						}

						// 4. 提供一个公有的静态方法，返回实例对象
						public static Singleton2 getInstance() {
							return instance;
						}
					}
			B. 优缺点说明：
				a. 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的
				实例。优缺点和上面是一样的。
				b. 结论：这种单例模式可用，但是可能造成内存浪费
		④ 懒汉式(线程不安全)
			A. 代码实现
				public class Singleton3 {
					private static Singleton3 instance;

					private Singleton3() {

					}

					public static Singleton3 getInstance() {
						if (instance == null) {
							instance = new Singleton3();
						}

						return instance;
					}
				}
			B. 优缺点说明：
				a. 起到了Lazy Loading的效果，但是只能在单线程下使用
				b. 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生
				多个实例。所以在多线程环境下不可使用这种方式
				c. 结论：在实际开发中，不要使用这种方式
		⑤  懒汉式(线程安全，同步方法)
			A. 代码实现
				public class Singleton4 {
					private static Singleton4 instance;

					private Singleton4() {

					}

					public static synchronized Singleton4 getInstance() {
						if (instance == null) {
							instance = new Singleton4();
						}

						return instance;
					}
				}
			B. 优缺点说明：
				a. 解决了线程不安全问题
				b. 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想
				获得该类实例，直接return就行了。方法进行同步效率太低
				c. 结论：在实际开发中，不推荐使用这种方式
		⑥ 懒汉式(线程安全，同步代码块)
			A. 代码实现
				public class Singleton5 {

					private static Singleton5 instance;

					private Singleton5() {

					}

					public static Singleton5 getInstance() {
						if (instance == null) {
							synchronized (Singleton5.class) {
								instance = new Singleton5();
							}
						}
						return instance;
					}
				}
			B. 优缺点说明：
				a. 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块
				b. 但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来
				得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例
				c. 结论：在实际开发中，不能使用这种方式
		⑦ 双重检查
			A. 代码实例
				public class Singleton6 {

					private static volatile Singleton6 instance;

					private Singleton6() {

					}

					public static Singleton6 getInstance() {
						if (instance == null) {
							synchronized (Singleton6.class) {
								if (instance == null) {
									instance = new Singleton6();
								}
							}
						}

						return instance;
					}
				}
			B. 优缺点说明：
				a. Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。
				b. 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步
				c. volatile 的作用是会让修改值立即同步到主存
				d. 线程安全；延迟加载；效率较高
				e. 结论：在实际开发中，推荐使用这种单例设计模式
		⑧ 静态内部类
			A. 代码实例
				class Singleton7 {

					private Singleton7() {

					}

					private static class SingletonInstance {
						private static final Singleton7 instance = new Singleton7();
					}

					public static Singleton7 getInstance() {
						return SingletonInstance.instance;
					}
				}
			B. 优缺点说明：
				a. 这种方式采用了类装载的机制来保证初始化实例时只有一个线程
				b. 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，
				从而完成Singleton的实例化。
				c. 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入
				的。
				d. 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
				e. 结论：推荐使用
		⑨ 枚举
			A. 代码演示
				public enum Singleton8 {
					INSTANCE;

					public void say() {
						System.out.println("Hello World!");
					}
				}
			B. 优缺点说明：
				a. 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
				b. 这种方式是Effective Java作者Josh Bloch 提倡的方式
				c. 结论：推荐使用

	3. 单例模式在JDK 应用的源码分析
		① JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)
		② 代码说明
			public class Runtime {
				private static Runtime currentRuntime = new Runtime();

				
				public static Runtime getRuntime() {
					return currentRuntime;
				}

				private Runtime() {}
			}
	4. 单例模式注意事项和细节说明
		① 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能	
		② 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
		③ 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、
		频繁访问数据库或文件的对象(比如数据源、session工厂等)
五、工厂设计模式
	1. 简单工厂模式
		① 案例
			A. 看一个披萨的项目：要便于披萨种类的扩展，要便于维护
			B. 披萨的种类很多(比如 GreekPizz、CheesePizz 等)
			C. 披萨的制作有 prepare，bake, cut, box
			D. 完成披萨店订购功能。
		② 使用传统的方式来完成
			A. 类图
						+---------------------------------------+
						| 				C Pizza 				|
						+---------------------------------------+
						| pizzaName: String						|				+---------+ 			+--------------+
						+---------------------------------------+<--------------| C Order |<------------| C OrderStore |
						| bake(): void							|			 	+---------+ 			+--------------+
						| cut(): void							|
						| box(): void							|
						| setPizzaName(pizzaName: String): void |
						+---------------------------------------+
										△
										|
						+---------------------------------------+
						|										|
				+-----------------+					+-----------------+
				|  C CheesePizza  |					|  C GreekPizza   |
				+-----------------+					+-----------------+
				| prepare(): void |					| prepare(): void |
				+-----------------+					+-----------------+
			B. 代码实现
				public abstract class Pizza {
					protected String pizzaName;

					public abstract void prepare();

					public void bake() {
						System.out.println(pizzaName + " baking");
					}

					public void cut() {
						System.out.println(pizzaName + " cutting");
					}

					public void box() {
						System.out.println(pizzaName + " boxing");
					}

					public void setPizzaName(String pizzaName) {
						this.pizzaName = pizzaName;
					}
				}

				public class CheesePizza extends Pizza {

					@Override
					public void prepare() {
						setPizzaName("奶酪披萨");
						System.out.println(pizzaName + " preparing");
					}
				}

				public class GreekPizza extends Pizza {

					@Override
					public void prepare() {
						setPizzaName("希腊披萨");
						System.out.println(pizzaName + " preparing");
					}
				}

				public class Order {

					public Order() {
						Pizza pizza;
						do {
							String type = getType();
							if ("greek".equals(type)) {
								pizza = new GreekPizza();
							} else if ("cheese".equals(type)) {
								pizza = new CheesePizza();
							} else {
								break;
							}
							pizza.prepare();
							pizza.bake();
							pizza.cut();
							pizza.box();
						} while (true);
					}

					public String getType() {
						System.out.println("输入披萨名称：");
						BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
						try {
							return br.readLine();
						} catch (IOException e) {
							throw new RuntimeException(e);
						}
					}
				}

				public class OrderStore {

					public static void main(String[] args) {
						new Order();
					}
				}
		③ 传统的方式的优缺点
			A. 优点是比较好理解，简单易操作。
			B. 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码
			C. 比如我们这时要新增加一个Pizza的种类(Pepper披萨)，我们需要做如下修改
				public class PepperPizza extends Pizza {

					@Override
					public void prepare() {
						setPizzaName("pepper披萨");
					}
				}
				public class Order {

					public Order() {
						//
							else if ("pepper".equals(type)) {
							pizza = new PepperPizza();
						}
					}
				}
			D. 改进的思路分析
				a. 分析：修改代码可以接受，但是如果我们在其它的地方也有创建Pizza的代码，就意味着，也需要修改，而创建Pizza的代码，往往有多处。
				b. 思路：把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该类就可，其它有创建到Pizza对象的代码就不需要修
				改了（简单工厂模式）
		④ 简单工厂模式基本介绍
			A. 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂
			模式家族中最简单实用的模式
			B. 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)
			C. 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式
		⑤ 使用简单工厂模式
			A. 简单工厂模式的设计方案: 定义一个可以实例化Pizaa对象的类，封装创建对象的代码。
			B. 代码实现
				public class SimpleFactory {

					public Pizza createPizza(String orderType) {
						Pizza pizza = null;
						if ("greek".equals(orderType)) {
							pizza = new GreekPizza();
						} else if ("cheese".equals(orderType)) {
							pizza = new CheesePizza();
						} else if ("pepper".equals(orderType)) {
							pizza = new PepperPizza();
						}
						return pizza;
					}
				}
				
				public class Order {

					private final SimpleFactory simpleFactory;

					public Order(SimpleFactory simpleFactory) {
						this.simpleFactory = simpleFactory;
					}

					public void creatOrder() {
						do {
							String orderType = getOrderType();
							Pizza pizza = simpleFactory.createPizza(orderType);
							if (pizza != null) {
								pizza.prepare();
								pizza.bake();
								pizza.cut();
								pizza.box();
							} else {
								System.out.println("订购失败");
								break;
							}
						} while (true);
					}

					private String getOrderType() {
						System.out.println("输入披萨名称：");
						BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
						try {
							return br.readLine();
						} catch (IOException e) {
							throw new RuntimeException(e);
						}
					}
				}
				
				public class OrderStore {

					public static void main(String[] args) {
						new Order(new SimpleFactory()).creatOrder();
					}
				}
			C. UML 类图
						+---------------------------------------+
						| 				C Pizza 				|
						+---------------------------------------+
						| pizzaName: String						|		+---------------------------------------+		+---------+ 		+--------------+
						+---------------------------------------+<------| 			C SimpleFactory 			|<------| C Order |<--------| C OrderStore |
						| bake(): void							|		+---------------------------------------+	 	+---------+ 		+--------------+
						| cut(): void							|		| createPizza(orderType: String): Pizza |
						| box(): void							|		+---------------------------------------+
						| setPizzaName(pizzaName: String): void |
						+---------------------------------------+
										△
										|
						+---------------------------------------+
						|										|
				+-----------------+					+-----------------+
				|  C CheesePizza  |					|  C GreekPizza   |
				+-----------------+					+-----------------+
				| prepare(): void |					| prepare(): void |
				+-----------------+					+-----------------+
	2. 工厂方法模式
		① 需求
			A. 假设你正在开发一款物流管理应用，最初版本只能处理陆上运输。
			B. 一段时间后， 这款应用变得极受欢迎，你每天都能收到十几次来自海运公司的请求，希望应用能够支持海上物流功能
		② 思路：
			A. 思路1：使用简单工厂模式，创建不同的简单工厂类，比如RoadLogisticsFactory、SeaLogisticsFactory，.从当前这个案例来说，也是可以的，但是
			考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好
			B. 思路2：使用工厂方法模式
		③ 工厂方法模式
			A. 工厂方法模式介绍
				a. 工厂方法模式设计方案：将创建运输方式的实例化功能抽象成抽象方法，在不同运输方式中具体实现
				b. 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类
		④ 使用工厂方法模式
			A. 代码实现
				public interface Transport {

					void driver();
				}
				
				public class TruckTransport implements Transport {

					@Override
					public void driver() {
						System.out.println("卡车运输");
					}
				}
				public class ShipTransport implements Transport {

					@Override
					public void driver() {
						System.out.println("轮船运输");
					}
				}
				public abstract class Logistics {

					public abstract Transport createTransport();

					public void planDelivery() {
						Transport transport = createTransport();
						transport.driver();
					}
				}
				public class RoadLogistics extends Logistics {

					@Override
					public Transport createTransport() {
						return new TruckTransport();
					}
				}
				public class SeaLogistics extends Logistics {

					@Override
					public Transport createTransport() {
						return new ShipTransport();
					}
				}
				public class Demo {

					public static void main(String[] args) {
						while (true) {
							String logisticsType = getLogisticsType();
							if ("road".equals(logisticsType)) {
								new RoadLogistics().planDelivery();
							} else if ("sea".equals(logisticsType)) {
								new SeaLogistics().planDelivery();
							} else {
								break;
							}
						}
					}

					public static String getLogisticsType() {
						System.out.println("请输入运输方式：");
						BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
						try {
							return bufferedReader.readLine();
						} catch (IOException e) {
							throw new RuntimeException(e);
						}
					}
				}
			B. UML 类图
								+----------------+										+------------------------------+
								|  I Transport   |<-------------------------------------| 			I Logistics		   |
								+----------------+										+------------------------------+
								| driver(): void |										| createTransport(): Transport |--->Transport transport = createTransport();
								+----------------+										| planDelivery(): void		   |	transport.driver();
										△												+------------------------------+
										.																△
										.																|
							.............................								+---------------+--------------+
							.							.								|							   |
				+-------------------+			+------------------+	+------------------------------+	+------------------------------+
				|  C TruckTransport |			|  C ShipTransport |	| 		C RoadLogistics		   |	| 		C SeaLogistics		   |
				+-------------------+			+------------------+	+------------------------------+	+------------------------------+
				| driver(): void	|			| driver(): void   |	| createTransport(): Transport |	| createTransport(): Transport |
				+-------------------+			+------------------+	+------------------------------+	+------------------------------+
	3. 抽象工厂模式
		① 基本介绍
			A. 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
			B. 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
			C. 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
			D. 将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类
			变成了工厂簇，更利于代码的维护和扩展。
		② 抽象工厂模式应用实例
			A. 跨平台 GUI 组件系列及其创建方式
			B. 在本例中， 按钮和复选框将被作为产品。 它们有两个变体： macOS 版和 Windows 版。
			C. 抽象工厂定义了用于创建按钮和复选框的接口。 而两个具体工厂都会返回同一变体的两个产品。
			D. 客户端代码使用抽象接口与工厂和产品进行交互。 同样的代码能与依赖于不同工厂对象类型的多种产品变体进行交互。
		③ 代码实现
			A. 代码实现
				a. button: 第一个产品层次结构
					public interface Button {

						void paint();
					}

					public class MacOSButton implements Button {

						@Override
						public void paint() {
							System.out.println("You have created MacOSButton.");
						}
					}

					public class WindowsButton implements Button {

						@Override
						public void paint() {
							System.out.println("You have created WindowsButton.");
						}
					}

				b. checkboxes: 第二个产品层次结构
					public interface Checkbox {

						void paint();
					}

					public class MacOSCheckbox implements Checkbox {

						@Override
						public void paint() {
							System.out.println("You have created MacOSCheckbox.");
						}
					}

					public class WindowsCheckbox implements Checkbox {

						@Override
						public void paint() {
							System.out.println("You have created WindowsCheckbox.");
						}
					}

				c. 工厂
					public interface GUIFactory {

						Button createButton();

						Checkbox createCheckbox();
					}

					public class MacOSFactory implements GUIFactory {
						@Override
						public Button createButton() {
							return new MacOSButton();
						}

						@Override
						public Checkbox createCheckbox() {
							return new MacOSCheckbox();
						}
					}

					public class WindowsFactory implements GUIFactory {

						@Override
						public Button createButton() {
							return new WindowsButton();
						}

						@Override
						public Checkbox createCheckbox() {
							return new WindowsCheckbox();
						}
					}

				d. 客户端
					public class Application {

						private final Button button;
						private final Checkbox checkbox;

						public Application(GUIFactory factory) {
							button = factory.createButton();
							checkbox = factory.createCheckbox();
						}

						public void paint() {
							button.paint();
							checkbox.paint();
						}
					}

					public class Demo {

						public static void main(String[] args) {
							Application application = configureApplication();
							application.paint();
						}

						public static Application configureApplication() {
							GUIFactory factory;
							String osName = System.getProperty("os.name").toLowerCase();
							if (osName.contains("mac")) {
								factory = new MacOSFactory();
							} else {
								factory = new WindowsFactory();
							}

							return new Application(factory);
						}
					}
			B. UML 类图
																+----------------------------+
								+-------------------+-----------| 		C MacOSFactory		 |
								|					|			+----------------------------+
								|					|			| createButton(): Button	 |
								↓					↓			| createCheckbox(): Checkbox |
						+---------------+	+---------------+	+----------------------------+
						| C MacOSButton |	|C MacOSCheckbox|				.
						+---------------+	+---------------+				.
						| paint(): void |	| paint(): void |				.
						+---------------+	+---------------+				.
								.					.						.
								▽					▽						▽	
						+---------------+	+---------------+	+----------------------------+		+----------------------------------+
				+------>|	I Button	|	|	I Checkbox	|	| 		I GUIFactory		 |<-----|			C Application		   |
				|		+---------------+	+---------------+	+----------------------------+		+----------------------------------+
				|		| paint(): void |	| paint(): void |	| createButton(): Button	 |		| button: Button				   |
				|		+---------------+	+---------------+	| createCheckbox(): Checkbox |		| checkbox: Checkbox			   |
				|				△					△			+----------------------------+		+----------------------------------+
				|				.					.						△						| Application(factory: GUIFactory) |
				|		+---------------+	+---------------+				.						| paint(): void					   |
				|		|C WindowsButton|	|WindowsCheckbox|				.						+----------------------------------+
				|		+---------------+	+---------------+				.										|
				|		| paint(): void |	| paint(): void |				.										|
				|		+---------------+	+---------------+	+----------------------------+						|
				|				↑					↑			| 		C WindowsFactory	 |						|
				|				|					|			+----------------------------+						|
				|				|					|			| createButton(): Button	 |						|
				|				+-------------------+-----------| createCheckbox(): Checkbox |						|
				|												+----------------------------+						|
				+---------------------------------------------------------------------------------------------------+
	4. 工厂模式在JDK-Calendar 应用的源码分析
		① JDK 中的Calendar类中，就使用了简单工厂模式
		② 代码示例
			public class CalendarTest {

				public static void main(String[] args) {
					Calendar cal = Calendar.getInstance();
					// 注意月份下标从0开始，所以取月份要+1
					System.out.println("年:" + cal.get(Calendar.YEAR));
					System.out.println("月:" + (cal.get(Calendar.MONTH) + 1));
					System.out.println("日:" + cal.get(Calendar.DAY_OF_MONTH));
					System.out.println("时:" + cal.get(Calendar.HOUR_OF_DAY));
					System.out.println("分:" + cal.get(Calendar.MINUTE));
					System.out.println("秒:" + cal.get(Calendar.SECOND));
				}
			}
			
			public static Calendar getInstance()
			{
				return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));
			}
			
			private static Calendar createCalendar(TimeZone zone,
                                           Locale aLocale)
			{
				CalendarProvider provider =
					LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
										 .getCalendarProvider();
				if (provider != null) {
					try {
						return provider.getInstance(zone, aLocale);
					} catch (IllegalArgumentException iae) {
						// fall back to the default instantiation
					}
				}

				Calendar cal = null;

				if (aLocale.hasExtensions()) {
					String caltype = aLocale.getUnicodeLocaleType("ca");
					if (caltype != null) {
						switch (caltype) {
						case "buddhist":
						cal = new BuddhistCalendar(zone, aLocale);
							break;
						case "japanese":
							cal = new JapaneseImperialCalendar(zone, aLocale);
							break;
						case "gregory":
							cal = new GregorianCalendar(zone, aLocale);
							break;
						}
					}
				}
				if (cal == null) {
					// If no known calendar type is explicitly specified,
					// perform the traditional way to create a Calendar:
					// create a BuddhistCalendar for th_TH locale,
					// a JapaneseImperialCalendar for ja_JP_JP locale, or
					// a GregorianCalendar for any other locales.
					// NOTE: The language, country and variant strings are interned.
					if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
						cal = new BuddhistCalendar(zone, aLocale);
					} else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"
							   && aLocale.getCountry() == "JP") {
						cal = new JapaneseImperialCalendar(zone, aLocale);
					} else {
						cal = new GregorianCalendar(zone, aLocale);
					}
				}
				return cal;
			}
	5. 工厂模式小结
		① 工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
		② 三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)
		③ 设计模式的依赖抽象原则
			A. 创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。
			B. 不要让类继承具体类，而是继承抽象类或者是实现interface(接口)
			C. 不要覆盖基类中已经实现的方法。
六、原型模式
	1. 克隆羊问题
		① 现在有一只羊tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和tom羊 属性完全相同的10只羊
		② 传统方式解决克隆羊问题
			A. 思路分析
				+----------+		+----------------------------------------------+
				| C Client | ------>| 					C Sheep					   |
				+----------+		+----------------------------------------------+
									| name: String								   |
									| age: int									   |
									| color: String								   |
									+----------------------------------------------+
									| Sheep(name: String, age: int, color: String) |
									| getName(): String							   |
									| getAge(): int								   |
									| getColor(): String						   |
									+----------------------------------------------+
			B. 代码实现
				public class Sheep {

					private String name;
					private int age;
					private String color;

					public Sheep(String name, int age, String color) {
						this.name = name;
						this.age = age;
						this.color = color;
					}

					public String getName() {
						return name;
					}

					public int getAge() {
						return age;
					}

					public String getColor() {
						return color;
					}

					@Override
					public String toString() {
						return "Sheep{" +
								"name='" + name + '\'' +
								", age=" + age +
								", color='" + color + '\'' +
								'}';
					}
				}
				
				public class Demo {

					public static void main(String[] args) {
						Sheep sheep = new Sheep("Tom", 1, "白色");

						Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
						Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
						Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
						Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());

						System.out.println(sheep);
						System.out.println(sheep2);
						System.out.println(sheep3);
						System.out.println(sheep4);
						System.out.println(sheep5);
					}
				}
		③ 传统的方式的优缺点
			A. 优点是比较好理解，简单易操作。
			B. 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低
			C. 总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活
			D. 改进的思路分析：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone
			的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力（原型模式）
	2. 基本介绍
		① 原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
		② 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
		③ 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()
	3. 原型模式原理结构图-uml类图
		+----------+		+-------------+
		| C Client |------->| C ProtoType |
		+----------+		+-------------+
							| clone()	  |
							+-------------+
								  △
								  |
					+-------------+-------------+
					|							| 
		+----------------------+		+----------------------+
		| C ConcreteProtoType1 |		| C ConcreteProtoType2 |
		+----------------------+		+----------------------+
		| clone()			   |		| clone()			   |
		+----------------------+		+----------------------+
		① 原理结构图说明
			A. Prototype : 原型类，声明一个克隆自己的接口
			B. ConcretePrototype: 具体的原型类, 实现一个克隆自己的操作
			C. Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样)
	4. 原型模式应用实例
		A. 复制图形：不使用标准 Cloneable接口的情况下如何实现原型模式。
		B. 代码实现
			public abstract class Shape {
				public int x;
				public int y;
				public String color;

				public Shape() {
				}

				public Shape(Shape shape) {
					if (shape != null) {
						this.x = shape.x;
						this.y = shape.y;
						this.color = shape.color;
					}
				}

				public abstract Shape clone();

				@Override
				public boolean equals(Object o) {
					if (this == o) return true;
					if (!(o instanceof Shape shape)) return false;
					return x == shape.x && y == shape.y && color.equals(shape.color);
				}
			}
			
			public class Circle extends Shape {

				public int radius;

				public Circle() {
				}

				public Circle(Circle circle) {
					super(circle);
					if (circle != null) {
						this.radius = circle.radius;
					}
				}

				@Override
				public Shape clone() {
					return new Circle(this);
				}

				@Override
				public boolean equals(Object o) {
					if (this == o) return true;
					if (!(o instanceof Circle circle && super.equals(o))) return false;
					return radius == circle.radius;
				}
			}
			
			public class Rectangle extends Shape {
				public int width;
				public int height;

				public Rectangle() {
				}

				public Rectangle(Rectangle rectangle) {
					super(rectangle);
					if (rectangle != null) {
						this.width = rectangle.width;
						this.height = rectangle.height;
					}
				}

				@Override
				public Shape clone() {
					return new Rectangle(this);
				}

				@Override
				public boolean equals(Object o) {
					if (this == o) return true;
					if (!(o instanceof Rectangle rectangle && super.equals(o))) return false;
					return width == rectangle.width && height == rectangle.height;
				}
			}
			
			public class Demo {

				public static void main(String[] args) {
					List<Shape> shapes = new ArrayList<>();
					List<Shape> shapesCopy = new ArrayList<>();

					Circle circle = new Circle();
					circle.x = 10;
					circle.y = 20;
					circle.radius = 15;
					circle.color = "rea";

					shapes.add(circle);
					Circle anotherCircle = (Circle) circle.clone();
					shapes.add(anotherCircle);

					Rectangle rectangle = new Rectangle();
					rectangle.width = 10;
					rectangle.height = 20;
					rectangle.color = "blue";
					shapes.add(rectangle);
					cloneAndCompare(shapes, shapesCopy);
				}

				private static void cloneAndCompare(List<Shape> shapes, List<Shape> shapesCopy) {
					shapes.forEach(shape -> shapesCopy.add(shape.clone()));
					for (int i = 0; i < shapes.size(); i++) {
						if (shapes.get(i) != shapesCopy.get(i)) {
							System.out.println(i + ": Shapes are different objects (yay!)");
							if (shapes.get(i).equals(shapesCopy.get(i))) {
								System.out.println(i + ": And they are identical (yay!)");
							} else {
								System.out.println(i + ": But they are not identical (booo!)");
							}
						} else {
							System.out.println(i + ": Shape objects are the same (booo!)");
						}
					}
				}
			}
	5. 原型模式在Spring框架中源码分析
		① Spring中原型bean的创建，就是原型模式的应用
		② 代码分析+源码
			@Component
			@Scope("prototype")
			public class Person {

				public String name = "LiXL";

				public int age = 25;

				private String idCard = "2648";

				@Override
				public String toString() {
					return "Person{" +
							"name='" + name + '\'' +
							", age=" + age +
							", idCard='" + idCard + '\'' +
							'}';
				}
			}
			
			public void testGetPerson() {
				AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Application.class);
				Person person = (Person) ac.getBean("person");
				Person person2 = (Person) ac.getBean("person");
				System.out.println(person == person2);
			}
			
			AbstractApplicationContext.class
			public Object getBean(String name) throws BeansException {
				this.assertBeanFactoryActive();
				return this.getBeanFactory().getBean(name);
			}
			
			AbstractBeanFactory.clss
			public Object getBean(String name) throws BeansException {
				return this.doGetBean(name, (Class)null, (Object[])null, false);
			}
			protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
				// ...
				} else if (mbd.isPrototype()) {
                    prototypeInstance = null;

                    Object prototypeInstance;
                    try {
                        this.beforePrototypeCreation(beanName);
                        prototypeInstance = this.createBean(beanName, mbd, args);
                    } finally {
                        this.afterPrototypeCreation(beanName);
                    }

                    beanInstance = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                }
			}
	6. 深入讨论-浅拷贝和深拷贝
		① 浅拷贝的介绍
			A. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
			B. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用
			值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对
			象的该成员变量值
			C. 浅拷贝是使用默认的 clone()方法来实现
		② 浅拷贝应用实例
			public class Sheep implements Cloneable {

				public String name;
				public int age;
				public String color;

				public Sheep friend;

				@Override
				public String toString() {
					return "Sheep{" +
							"name='" + name + '\'' +
							", age=" + age +
							", color='" + color + '\'' +
							", friend=" + friend +
							'}';
				}

				@Override
				public Sheep clone() {
					Sheep s = null;
					try {
						s = (Sheep) super.clone();
					} catch (CloneNotSupportedException e) {
						e.printStackTrace();
					}
					return s;
				}
			}
			
			public class Demo {

				public static void main(String[] args) {
					Sheep sheep = new Sheep();
					sheep.name = "Tom";
					sheep.age = 1;
					sheep.color = "白色";

					Sheep friend = new Sheep();
					friend.name = "Jack";
					friend.age = 2;
					friend.color = "黑色";
					sheep.friend = friend;

					Sheep sheep1 = sheep.clone();
					System.out.println(sheep.toString() + sheep.friend.hashCode());
					System.out.println(sheep1.toString() + sheep1.friend.hashCode());
				}
			}
		③ 深拷贝基本介绍
			A. 复制对象的所有基本数据类型的成员变量值
			B. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深
			拷贝要对整个对象进行拷贝
			C. 深拷贝实现方式1：重写clone方法来实现深拷贝
			D. 深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)
		④ 深拷贝应用实例
			A. 使用重写clone方法实现深拷贝
			B. 使用序列化来实现深拷贝
			C. 代码实现
				public class DeepCloneableTarget implements Serializable, Cloneable {

					public static final long serialVersionUID = 1L;

					public String cloneName;

					public String cloneClass;

					public DeepCloneableTarget(String cloneName, String cloneClass) {
						this.cloneName = cloneName;
						this.cloneClass = cloneClass;
					}

					@Override
					public String toString() {
						return "DeepCloneableTarget{" +
								"cloneName='" + cloneName + '\'' +
								", cloneClass='" + cloneClass + '\'' +
								'}';
					}

					// 方式1：重写clone方法来实现深拷贝
					@Override
					public DeepCloneableTarget clone() {
						try {
							return (DeepCloneableTarget) super.clone();
						} catch (CloneNotSupportedException e) {
							throw new AssertionError();
						}
					}
				}
				
				public class DeepPrototype implements Serializable, Cloneable {

					public static final long serialVersionUID = 1L;

					public String name;

					public DeepCloneableTarget deepCloneableTarget;

					public DeepPrototype(String name, DeepCloneableTarget deepCloneableTarget) {
						this.name = name;
						this.deepCloneableTarget = deepCloneableTarget;
					}

					public DeepCloneableTarget getDeepCloneableTarget() {
						return deepCloneableTarget;
					}

					@Override
					public String toString() {
						return "DeepPrototype{" +
								"name='" + name + '\'' +
								", deepCloneableTarget=" + deepCloneableTarget +
								'}';
					}

					// 方式1：重写clone方法来实现深拷贝
					@Override
					public DeepPrototype clone() {
						try {
							DeepPrototype clone = (DeepPrototype) super.clone();
							clone.deepCloneableTarget = clone.deepCloneableTarget.clone();
							return clone;
						} catch (CloneNotSupportedException e) {
							throw new AssertionError();
						}
					}

					// 方式2：通过对象序列化实现深拷贝
					public DeepPrototype copy() {
						DeepPrototype clone = null;
						try(ByteArrayOutputStream bos = new ByteArrayOutputStream();
							ObjectOutputStream oos = new ObjectOutputStream(bos)) {
							oos.writeObject(this);
							try(ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
								ObjectInputStream ois = new ObjectInputStream(bis)) {
								clone = (DeepPrototype) ois.readObject();
							}
						} catch (Exception e) {
							e.printStackTrace();
						}

						return clone;
					}
				}
				public class Demo {

					public static void main(String[] args) {

						DeepCloneableTarget target = new DeepCloneableTarget("deepCloneableTarget", "DeepCloneableTarget类");
						DeepPrototype deepPrototype = new DeepPrototype("deepPrototype", target);

						// 方式1：重写clone方法来实现深拷贝
						DeepPrototype deepPrototype1 = deepPrototype.clone();
						System.out.println(deepPrototype.toString() + deepPrototype.getDeepCloneableTarget().hashCode());
						System.out.println(deepPrototype1.toString() + deepPrototype1.getDeepCloneableTarget().hashCode());

						// 方式2：通过对象序列化实现深拷贝
						DeepPrototype deepPrototype2 = deepPrototype.copy();
						System.out.println(deepPrototype2.toString() + deepPrototype2.getDeepCloneableTarget().hashCode());
					}
				}
	7. 原型模式的注意事项和细节
		① 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
		② 不用重新初始化对象，而是动态地获得对象运行时的状态
		③ 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码
		④ 在实现深克隆的时候可能需要比较复杂的代码
		⑤ 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则
七、建造者模式
	1. 盖房项目需求
		① 需求
			A. 需要建房子：这一过程为打桩、砌墙、封顶
			B. 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的
		② 实现
			A. UML类图
								+--------------------+
								| C AbstractHouse	 |
								+--------------------+
								| buildBasic(): void |
								| buildWall(): void  |
								| roofed(): void	 |
								| build(): void	     |
								+--------------------+
										   △
										   |
							+--------------+------------+
							|							|
				+---------------------+			+--------------------+
				|  C CommonHouse	  |			| C HighBuilding	 |
				+---------------------+			+--------------------+
				| buildBasic(): void  |			| buildBasic(): void |
				| buildWall(): void	  |			| buildWall(): void  |
				| roofed(): void	  |			| roofed(): void	 |
				+---------------------+			+--------------------+
							↑							↑
							+---------------+-----------+
											|
										+----------+
										| C Client |
										+----------+
			B. 代码实现
				public abstract class AbstractHouse {

					/**
					 * 打地基
					 */
					public abstract void buildBasic();

					/**
					 * 砌墙
					 */
					public abstract void buildWall();

					/**
					 * 封顶
					 */
					public abstract void roofed();

					public void build() {
						buildBasic();
						buildWall();
						roofed();
					}
				}

				package com.li.builder.house;

				public class CommonHouse extends AbstractHouse {
					@Override
					public void buildBasic() {
						System.out.println("给普通房子打地基");
					}

					@Override
					public void buildWall() {
						System.out.println("给普通房子打砌墙");
					}

					@Override
					public void roofed() {
						System.out.println("给普通房子打封顶");
					}
				}
				package com.li.builder.house;

				public class HighBuilding extends AbstractHouse {
					@Override
					public void buildBasic() {
						System.out.println("给高级建筑打地基");
					}

					@Override
					public void buildWall() {
						System.out.println("给高级建筑打砌墙");
					}

					@Override
					public void roofed() {
						System.out.println("给高级建筑打封顶");
					}
				}
				public class Demo {

					public static void main(String[] args) {
						CommonHouse commonHouse = new CommonHouse();
						commonHouse.build();
					}
				}
		③ 传统方式解决盖房需求问题分析
			A. 优点是比较好理解，简单易操作。
			B. 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 
			和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。
			C. 解决方案：将产品和产品建造过程解耦（建造者模式）
	2. 建造者模式基本介绍
		① 基本介绍
			A. 建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），
			使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
			B. 建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内
			部的具体构建细节。
		② 建造者模式的四个角色
			A. Product（产品角色）： 一个具体的产品对象。
			B. Builder（抽象建造者）： 创建一个Product对象的各个部件指定的 接口/抽象类
			C. ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。
			D. Director（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了
		客户与对象的生产过程，二是：负责控制产品对象的生产过程。
	3. 建造者模式案例
		① 需求：
			A. 分步制造汽车，生成器模式允许你分步骤地制造不同型号的汽车。
			B . 使用相同的生产过程制造不同类型的产品 （汽车和汽车手册）
			C. 主管控制着构造顺序。 它知道制造各种汽车型号需要调用的生产步骤。 它仅与汽车的通用接口进行交互。 这样就能将不同类型的生成器传递给主管了。
		② 实现
			A. URL 类图
																								 +--------+
																								 | C Demo |
																								 +--------+
																									  |
					+-------------------------------------------------------+-------------------------+-----------------------------+---------------------------+
					|														↓														↓							|
					|							+---------------------------------------------------+		  +--------------------------------------------+	|
					|							| 					I Builder 						|		  | 					C Director			   |	|
					|							+---------------------------------------------------+ <------ +--------------------------------------------+	|
					|							| setCarType(type: CarType): void					|		  | constructSportsCar(builder: Builder): void |	|
					|							| setSeats(seats: int): void						|		  | constructCityCar(builder: Builder): void   |	|
					|							| setEngine(engine: Engine): void					|		  | constructSUV(builder: Builder): void	   |	|
					|							| setTransmission(transmission: Transmission): void |		  +--------------------------------------------+	|
					|							| setTripComputer(tripComputer: TripComputer): void |															|
					|							| setGPSNavigator(gpsNavigator: GPSNavigator): void |															|
					|							+---------------------------------------------------+															|
					|													△																						|
					|													.																						|
					|							+.......................+...........................+						+-----------------------------------+
					↓							.													.						↓
				+---------------------------------------------------+		+---------------------------------------------------+
				| 					C CarBuilder 					|		| 					C CarManualBuilder 				|
				+---------------------------------------------------+		+---------------------------------------------------+
				| type: CarType										|		| type: CarType										|
				| seats: int										|		| seats: int										|
				| engine: Engine									|		| engine: Engine									|
				| transmission: Transmission						|		| transmission: Transmission						|
				| tripComputer: TripComputer						|		| tripComputer: TripComputer						|
				| gpsNavigator: GPSNavigator						|		| gpsNavigator: GPSNavigator						|
				+---------------------------------------------------+		+---------------------------------------------------+
				| setCarType(type: CarType): void					|		| print(): String									|
				| setSeats(seats: int): void						|		+---------------------------------------------------+
				| setEngine(engine: Engine): void					|								|
				| setTransmission(transmission: Transmission): void |								↓
				| setTripComputer(tripComputer: TripComputer): void |							+----------+
				| setGPSNavigator(gpsNavigator: GPSNavigator): void |							| C Manual |
				| getResult(): Car									|							+----------+
				+---------------------------------------------------+
										|
										↓
									+-------+
									| C Car |
									+-------+
			B. 代码实现
				a. builder
					/**
					 * 通用生成器接口
					 */
					public interface Builder {

					    /**
					     * 设置汽车类型
					     */
					    void setCarType(CarType type);

					    /**
					     * 设置汽车座位
					     */
					    void setSeats(int seats);

					    /**
					     * 设置汽车动力
					     */
					    void setEngine(Engine engine);

					    /**
					     * 挂档
					     */
					    void setTransmission(Transmission transmission);

					    /**
					     * 控制系统
					     */
					    void setTripComputer(TripComputer tripComputer);

					    /**
					     * GPS导航
					     */
					    void setGPSNavigator(GPSNavigator gpsNavigator);
					}
					
					/**
					 * 汽车生成器
					 */
					public class CarBuilder implements Builder {

					    private CarType type;
					    private int seats;
					    private Engine engine;
					    private Transmission transmission;
					    private TripComputer tripComputer;
					    private GPSNavigator gpsNavigator;

					    @Override
					    public void setCarType(CarType type) {
					        this.type = type;
					    }

					    @Override
					    public void setSeats(int seats) {
					        this.seats = seats;
					    }

					    @Override
					    public void setEngine(Engine engine) {
					        this.engine = engine;
					    }

					    @Override
					    public void setTransmission(Transmission transmission) {
					        this.transmission = transmission;
					    }

					    @Override
					    public void setTripComputer(TripComputer tripComputer) {
					        this.tripComputer = tripComputer;
					    }

					    @Override
					    public void setGPSNavigator(GPSNavigator gpsNavigator) {
					        this.gpsNavigator = gpsNavigator;
					    }

					    public Car getResult() {
					        return new Car(type, seats, engine, transmission, tripComputer, gpsNavigator);
					    }
					}	
					/**
					 * 汽车手册生成器
					 */
					public class Manual {

					    private final CarType carType;
					    private final int seats;
					    private final Engine engine;
					    private final Transmission transmission;
					    private final TripComputer tripComputer;
					    private final GPSNavigator gpsNavigator;

					    public Manual(CarType carType, int seats, Engine engine, Transmission transmission, TripComputer tripComputer, GPSNavigator gpsNavigator) {
					        this.carType = carType;
					        this.seats = seats;
					        this.engine = engine;
					        this.transmission = transmission;
					        this.tripComputer = tripComputer;
					        this.gpsNavigator = gpsNavigator;
					    }

					    public String print() {
					        String info = "";
					        info += "Type of car: " + carType + "\n";
					        info += "Count of seats: " + seats + "\n";
					        info += "Engine: volume - " + engine.getVolume() + "; mileage - " + engine.getMileage() + "\n";
					        info += "Transmission: " + transmission + "\n";
					        if (this.tripComputer != null) {
					            info += "Trip Computer: Functional" + "\n";
					        } else {
					            info += "Trip Computer: N/A" + "\n";
					        }
					        if (this.gpsNavigator != null) {
					            info += "GPS Navigator: Functional" + "\n";
					        } else {
					            info += "GPS Navigator: N/A" + "\n";
					        }
					        return info;
					    }
					}
				b. car
					/**
					 * 汽车产品
					 */
					public class Car {
						private final CarType carType;
						private final int seats;
						private final Engine engine;
						private final Transmission transmission;
						private final TripComputer tripComputer;
						private final GPSNavigator gpsNavigator;
						private double fuel = 0;

						public Car(CarType carType, int seats, Engine engine, Transmission transmission, TripComputer tripComputer, GPSNavigator gpsNavigator) {
							this.carType = carType;
							this.seats = seats;
							this.engine = engine;
							this.transmission = transmission;
							this.tripComputer = tripComputer;
							this.gpsNavigator = gpsNavigator;
						}

						public CarType getCarType() {
							return carType;
						}

						public int getSeats() {
							return seats;
						}

						public Engine getEngine() {
							return engine;
						}

						public Transmission getTransmission() {
							return transmission;
						}

						public TripComputer getTripComputer() {
							return tripComputer;
						}

						public GPSNavigator getGpsNavigator() {
							return gpsNavigator;
						}

						public double getFuel() {
							return fuel;
						}

						public void setFuel(double fuel) {
							this.fuel = fuel;
						}
					}
					/**
					 * 汽车手册生成器
					 */
					public class Manual {

						private final CarType carType;
						private final int seats;
						private final Engine engine;
						private final Transmission transmission;
						private final TripComputer tripComputer;
						private final GPSNavigator gpsNavigator;

						public Manual(CarType carType, int seats, Engine engine, Transmission transmission, TripComputer tripComputer, GPSNavigator gpsNavigator) {
							this.carType = carType;
							this.seats = seats;
							this.engine = engine;
							this.transmission = transmission;
							this.tripComputer = tripComputer;
							this.gpsNavigator = gpsNavigator;
						}

						public String print() {
							String info = "";
							info += "Type of car: " + carType + "\n";
							info += "Count of seats: " + seats + "\n";
							info += "Engine: volume - " + engine.getVolume() + "; mileage - " + engine.getMileage() + "\n";
							info += "Transmission: " + transmission + "\n";
							if (this.tripComputer != null) {
								info += "Trip Computer: Functional" + "\n";
							} else {
								info += "Trip Computer: N/A" + "\n";
							}
							if (this.gpsNavigator != null) {
								info += "GPS Navigator: Functional" + "\n";
							} else {
								info += "GPS Navigator: N/A" + "\n";
							}
							return info;
						}
					}
					public enum CarType {
						CITY_CAR, SPORTS_CAR, SUV
					}
				c. component
					/**
					 *  产品特征：动力
					 */
					public class Engine {

						/**
						 * 体积
						 */
						private final double volume;
						/**
						 * 行驶里程
						 */
						private double mileage;
						/**
						 * 是否启动
						 */
						private boolean started;

						public Engine(double volume, double mileage) {
							this.volume = volume;
							this.mileage = mileage;
						}

						public void on() {
							started = true;
						}

						public void off() {
							started = false;
						}

						public boolean isStarted() {
							return started;
						}

						public void go(double mileage) {
							if (started) {
								this.mileage += mileage;
							} else {
								System.err.println("Cannot go(), you must start engine first!");
							}
						}

						public double getVolume() {
							return volume;
						}

						public double getMileage() {
							return mileage;
						}
					}
					/**
					 *  产品特征：GPS导航
					 */
					public class GPSNavigator {
						private String route;

						public GPSNavigator() {
							this.route = "221b, Baker Street, London  to Scotland Yard, 8-10 Broadway, London";
						}

						public GPSNavigator(String manualRoute) {
							this.route = manualRoute;
						}

						public String getRoute() {
							return route;
						}
					}
					/**
					 * 产品特征：挂档
					 */
					public enum Transmission {

						SINGLE_SPEED, MANUAL, AUTOMATIC, SEMI_AUTOMATIC
					}
					/**
					 * 产品特征：控制系统
					 */
					public class TripComputer {

						private Car car;

						public void setCar(Car car) {
							this.car = car;
						}

						/**
						 * 剩余油量
						 */
						public void showFuelLevel() {
							System.out.println("Fuel level: " + car.getFuel());
						}

						/**
						 * 启动状态
						 */
						public void showStatus() {
							if (this.car.getEngine().isStarted()) {
								System.out.println("Car is started");
							} else {
								System.out.println("Car isn't started");
							}
						}
					}
				d. director
					public class Director {

					public void constructSportsCar(Builder builder) {
						builder.setCarType(CarType.SPORTS_CAR);
						builder.setSeats(2);
						builder.setEngine(new Engine(3.0, 0));
						builder.setTransmission(Transmission.SEMI_AUTOMATIC);
						builder.setTripComputer(new TripComputer());
						builder.setGPSNavigator(new GPSNavigator());
					}

					public void constructCityCar(Builder builder) {
						builder.setCarType(CarType.CITY_CAR);
						builder.setSeats(2);
						builder.setEngine(new Engine(1.2, 0));
						builder.setTransmission(Transmission.AUTOMATIC);
						builder.setTripComputer(new TripComputer());
						builder.setGPSNavigator(new GPSNavigator());
					}

					public void constructSUV(Builder builder) {
						builder.setCarType(CarType.SUV);
						builder.setSeats(4);
						builder.setEngine(new Engine(2.5, 0));
						builder.setTransmission(Transmission.MANUAL);
						builder.setGPSNavigator(new GPSNavigator());
					}
				}
				e. client
					public class Demo {

						public static void main(String[] args) {

							Director director = new Director();
							CarBuilder carBuilder = new CarBuilder();
							director.constructSportsCar(carBuilder);
							Car car = carBuilder.getResult();
							System.out.println("Car built:\n" + car.getCarType());

							CarManualBuilder manualBuilder = new CarManualBuilder();
							director.constructSportsCar(manualBuilder);
							Manual carManual = manualBuilder.getResult();
							System.out.println("Car manual built:\n" + carManual.print());
						}
					}
	4. 建造者模式在JDK的应用和源码分析
		① java.lang.StringBuilder中的建造者模式
		② 代码说明
			public class StringBuilderTest {

				public static void main(String[] args) {

					StringBuilder stringBuilder = new StringBuilder("hello");
					System.out.println(stringBuilder);
				}
			}
			abstract class AbstractStringBuilder implements Appendable, CharSequence {
				// ...
				public AbstractStringBuilder append(String str) {
					if (str == null)
						return appendNull();
					int len = str.length();
					ensureCapacityInternal(count + len);
					str.getChars(0, len, value, count);
					count += len;
					return this;
				}
				// ...
			}
			public final class StringBuilder
				extends AbstractStringBuilder
				implements java.io.Serializable, CharSequence
			{
				// ...
				@Override
				public StringBuilder append(String str) {
					super.append(str);
					return this;
				}
				// ...
		③ 源码中建造者模式角色分析
			A. Appendable 接口定义了多个append方法(抽象方法)，即Appendable 为抽象建造者，定义了抽象方法
			B. AbstractStringBuilder 实现了 Appendable 接口方法，这里的AbstractStringBuilder 已经是建造者，只是不能实例化
			C. StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了
			AbstractStringBuilder
	5. 建造者模式的注意事项和细节
		① 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
		② 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即
		可得到不同的产品对象
		③ 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程
		④ 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”
		⑤ 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定
		的限制。
		⑥ 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式
		⑦ 抽象工厂模式VS建造者模式：抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式
		不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新
		产品

△▽▷◁▼▶◀
◄►▲▲◅▻◁▷▽△