Object类：（所有类的根父类）
==：
   1. 基本数据类型，根据基本数据类型的值判断是否相等，相等返回true，否则返回false
      注：两端数据类型可以不同，在不同的情况下，也可以返回true
   2. 引用数据类型，比较引用数据类型的变量地址是否相同
equals：
   1. ①只能处理引用类型变量 ②在Object类，发现equals()仍然比较的是两个引用类型变量的地址值是否相等
   2. java.lang.Object类，是所有类的根父类
      注：String类、File类、Date类重写了Object的equals()方法

关于String类：
   String str1 = "AA";
   String str2 = "AA";
   String str3 = new String("AA");
   System.out.println(str1 == str2);//true
   System.out.println(str1 equals(str2));//true
   System.out.println(str1 == str3);//false
   System.out.println(str1 equals(str3));//true
   Person p1 = new Person("AA");
   Person p2 = new Person("AA");
   System.out.println(p1.name == p2.name);//true

toString()方法：
   1. 当我们打印一个对象的引用时，实际上默认调用的是这个对象的toString()方法
   2. 当我们打印的对象所在的类没有重写Object中的toString()方法时，那么调用的就是Object中定义的toString类
      返回对象所在的类及对象的堆空间对象实体的首地址值
   3. 当我们打印的对象所在的类重写了toSting()方法时，调用的是自己重写的toSting()，重写方式是将对象的属性信息返回
   4. 像String类、包装类、File类、Date类等，以及实现了Object中的toSting()重写;

关于包装类：针对八种数据类型相应的引用类型-包装类（封装类）
	    有了类的特点就可以调用类中的方法
            基本数据类型、包装类、String之间的转换：
                  基本数据类型->对应的包装类，调用包装类的构造器：Integer inte = new Integer(int 类型的变量)
                  包装类->对应的基本数据类型，调用的是包装类的方法：int i = inte.intValue()
		  对于Boolean来讲，当形参是"true"返回true,除此之外返回false。
		  jdk5.0以后，实现自动装箱和自动拆箱
			自动装箱：Integer inte = 基本数据类型
			自动拆箱：int i = inte;
		  基本数据类型、包装类->String：调用的String类的静态重载valueOf()方法
                  基本数据类型->String：String str = inte + "";
		  包装类->String：String str = String.valueOf(inte);
                  String->基本数据类型、包装类：调用的是包装类中的parseInt(String str)方法
		  int i = Integer.parseInt(str);
JUnit单元测试类：
    1. 当前工程下->右键build path->add libraries->JUnit4
    2. 在主类中，创建一个空参的无返回方法，方法上声明@Test
    3. 导入import org.junit.Test
    4. 在方法中进行代码的编写
    5. 测试：双击方法名，右键选择run as->JUnit Test即可
static：静态的，可以用来修饰属性、方法、*代码块（或初始化）、*内部类
        static修饰属性（类变量）：
             ①由类创建的所有对象，都公有这个属性
	     ②当其中一个对象对此属性进行修改，会导致其他对象对此属性调用
	     ③类变量随着类的加载而加载
	     ④类变量可以直接通过类调用（格式：类.类变量）
             ⑤类变量的加载要早于对象，所以当有了对象以后，可以通过“对象.类变量”调用类变量。
	     ⑥类变量存在于静态域中
        static修饰方法（类方法）：
	     ①随着类的加载而加载，在内存中也是独一份
             ②可以直接通过“类.类方法”的形式调用
	     ③在静态方法内部，可以调用静态的属性与静态的方法，但是不能调用非静态的属性或者方法
               但是在非静态的方法内部，可以调用静态的属性和静态的方法
	       总结的方法里面是不可以有this或super关键字
               注：静态的结果（static的属性、方法、代码块、内部类）要早于非静态的结构，同时被回收也晚于非静态的结构
       static的一个应用：可以用来记录创建类的对象的次数，因为静态属性与方法在类中独一份。



设计模式：设计模式是在大量的实践中总结和理论之后优选的代码结构、编程风格、以及解决问题的思考方式
          23种设计模式。
          单例的设计模式1（饿汉式）：1. 解决的问题，使得一个类只能创建一个对象。  
                                     2. 如何实现？
			         	①私有化构造器类，使得在类的外部不能调用此构造器
                                        ②在类的内部创建一个对象
	                                ③私有化此对象，提供公共的方法来调用
			         	④此公共的方法，只能通过类来调用，因此设置为静态的，同时类的实例也必须设为静态的
          单例的设计模式1（懒汉式）：   ①私有化构造器类，使得在类的外部不能调用此构造器
                                        ②在类的内部创建一个对象，该对象先不初始化
	                                ③私有化此对象，提供公共的方法来调用，判断对象是否初始化，如果没有初始化，则进行初始化，否则返回对象
			         	④此公共的方法，只能通过类来调用，因此设置为静态的，同时类的实例也必须设为静态的
				        注：懒汉式可能出现线程安全问题
模板方法设计模式：抽象类体现的是模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式
          解决的问题：当功能内部一部分实现是确定，一部分实现是不确定的，这个时候可以把不确定的部分暴露出去，让子类去实现
                      编写一个抽象类，父类提供多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式

main：不仅可以当作main方法使用，还可以当作一般方法使用

关于属性赋值的操作：①默认初始化②显示初始化或代码块初始化（此处两个结构按照顺序执行）③构造器中④通过方法针对对象的相应属性进行修改 
初始化块（代码块）：如果有修饰的话只能是static
        1. 静态代码块：
		        ①静态代码里面可以有输出语句
				②随着类的加载而加载，而且只加载一次
				③多个静态代码块按照顺序结构执行
				④静态代码块的执行要早于非静态代码块
				⑤静态代码块只能执行静态是结构（类属性、类方法）
		2. 非静态代码块：
		        ①可以对类的属性（静态的&非静态的）进行初始化操作，同时也可以调用本类声明的方法（静态的&非静态的）
				②可以有输出语句
				③一个类中可以有多个非静态的代码块，多个代码块之间按照顺序执行
				④每创建一个类的对象，非静态代码块执行一次
				⑤非静态代码块的执行要早于构造器
final：在java中声明类、属性和方法时，可以使用关键字final来修饰，表示“最终”
        1. final修饰类，则该类不能被继承，如String类、StringBuffer类、System类。
	    2. final修饰方法，则该方法不能被重写，如：Object类中的getClass()方法
		3. final修饰属性，此属性就是一个常量，一旦初始化就不可被修改
		   注：①此常量不能使用默认初始化
		       ②可以显示修改、代码块、构造器
        4. static final修饰变量，则是全局常量。

抽象类（abstract class）：随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。
                          类的设计应该保证父类和子类能够共享特征。有时候将一个父类设计得非常抽象，
                          以至于它没有具体的实例，这样的类叫做抽象类
abstract：抽象的，可以用来修饰类、方法
          1. 修饰类：抽象类 
                     A. 不可实例化（创建对象）
                     B. 抽象类有构造器（类一定有构造器）
                     注：由于没有实体，故不能调用方法，因此不需要保留方法的功能，但仍需保留方法，让子类重写，否则不能使用多态
          2. 修饰方法：抽象方法
                     A. 格式：没有方法体，包括{} 
                     B. 抽象方法只保留方法的功能，而具体的执行，交给继承抽象类的子类，由子类重写此抽象方法
                     注：抽象方法所在的类一定是抽象类
                         抽象类不一定需要抽象方法
                         若子类继承抽象类，并重写了所有的抽象方法，则此类是一个“实体类”，可以实例化
                         若子类继承自抽象类，却没有重写抽象类的抽象方法，意味着此类仍有抽象方法，必须声明此类为抽象类，或者重写父类中的抽象方法
          注：abstract 不能用来修饰属性、构造器、private、final、static
              abstract不能修饰属性：因为子类无法对抽象属性进行覆盖
              abstract不能修饰构造器：因为构造器无法被重写，并且自身的类无法创建对象
              abstract不能修饰私有方法：因为私有的方法不能被子类重写
              abstract不能与final共存：因为final修饰的方法不能被重写，因此abstract修饰的方法无法被重写
              abstract不能与static共存：抽象类无法调用抽象方法，当static修饰的方法又可以直接被类调用，矛盾

接口：是抽象方法和常量值定义的集合，与类并行的概念
      从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现
      实现接口类：class SubClass implements InterfA{}
      一个类可以实现多个接口，接口也可以继承接口
      1. 接口可以看作是一个特殊的抽象类，是常量与抽象方法的集合，不能包含变量和一般的方法，
      2. 接口没有构造器
      3. 接口定义的是一种功能，这个功能可以被类所实现（implements ）
      4. 实现接口的类，必须重写其中所有的抽象方法，方可实例化，若没有重写所有的抽象方法，此类仍为抽象类，不可实例化
      5. 类可以实现多个接口，而java中的继承是单继承的
      6. 接口与接口之间也是继承的关系，可以实现多继承
      7. 接口与具体的实现类之间也存在多态性
      接口的用法总结：通过接口可以实现不相关类的相同行为，而不需要考虑这些类之间的层次关系
                      通过接口可以指明多个类需要实现的方法，一般用于定义对象的扩张功能
                      接口主要用来定义规范，解除耦合关系
工厂方法（FactoryMethod）：
      概述：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
      适用性：1. 当一个类不知道它所必须创建的对象的类的时候
              2. 当一个类希望由它的子类来指定它所创建的对象的时候
              3. 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理这一信息局部化的时候
工厂方法的设计模式：创建对象的时机是根据哪个需求来决定的
                    它的模式是通过返回一个接口，再通过接口去调用具体的实现类里面的方法
代理模式（Proxy）：程序创建一个接口Object，声明两个具体去实现接口，一个声明为被代理类，执行的是接口的功能，
                   一个是代理类，执行的是被代理类的职责。  
面试题：java中类的继承有什么特性？
        答：java中的类是单继承的，java中还有接口，定义接口是一个功能，可以让类去实现接口，而且实现接口可以多实现
            同时接口跟接口之间是继承关系，并且可以多继承
类的成员：内部类：1. 在java中，允许一个类的定义位于一个类的内部，前者称为内部类，后者称为外部类
                  2. 定义：inner class一般用在定义它的类或者语句块之内，在外部引用它的时候必须给出完整的名称。
                      注：Inner class的名字不能与包含它的类名相同
                  3. inner class可以使用外部类的私有数据，因为他是外部类的成员，同一个类的成员之间相互访问。而外部类
                     要访问内部类中的成员需要：内部类.成员或者内部类对象。成员
                  4. 分类：成员内部类（static成员内部类和非static内部类）局部内部类（不谈修饰符）、匿名内部类
                           成员内部类：是外部类的一个成员：可以有修饰符、static、final、可以调用外部类的成员属性方法
                                       具体类的特点：abstract、还可以在其内部定义属性、方法、构造器
                           局部内部类：
                  5. 关于内部类，需要掌握三点：
                     A. 创建成员内部类的对象
                           创建静态内部类的对象：可以直接通过外部类调用静态内部类的构造器
                                           格式：Person.Dog d = new Person.Dog();
                           创建非静态内部类的对象：必须先创建外部类的对象，通过外部类的对象调用内部类的构造器
                                             格式：Person p = new Person();p.Bird b = p.new Bird();
                                                                           Person.Bird b = p.new Bird();
                     B. 如何区分调用外部类、内部类的属性
                           不同明属性：内部类作为外部类的成员，因此可以直接使用外部类的属性，而外部类使用内部类的成员需要通过“内部类.成员”
                           同名属性：直接调用局部变量，使用this.成员调用内部类成员，使用外部类.this.成员
                     C. 局部内部类的使用
                           1. public void method(){
	                  	class InnerClass{}
                	      }
                           2. 常常使用一个方法，使其返回值为某个类或接口的对象，而这个类或接口需要在方法内创建
			      public Comparable getComparable(){
				class MyComparable implements Comparable{

				   @Override
				   public int compareTo(Object arg0) {
					return 0;
				   }
				 }
				return new MyComparable();
			       }
                            3. 返回一个匿名内部类的接口或者类的对象
                               public Comparable getComparable1(){
				    return new Comparable() {
					@Override
					public int compareTo(Object arg0) {
			       		      return 0;
			                }
		                    };
	                        }





