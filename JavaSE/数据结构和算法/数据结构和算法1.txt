一、数据结构和算法内容介绍
	1. 经典的算法面试题
		① 字符串匹配问题：
			A. 有一个字符串 str1 = "abcdefghijklmn"，和一个字串 str2 = "defg"，现在要判断 str1 是否含有 str2，如果存在，就返回第一次出现的位置，
			如果没有，则返回 -1。要求用最快的速度来完成匹配，思路是什么
			B. 使用 KMP 算法
		② 汉诺塔游戏
			A. 请完成汉诺塔游戏的代码，要求：将 A 塔的所有圆盘移动到 C 塔。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘
			B. 使用分治算法 
		③ 八皇后问题
			A. 在 8 x 8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法
			B. 使用回溯算法
		④ 马踏棋盘算法
			A. 马踏棋盘算法也被称为骑士周游问题，将马随机放在国际象棋的 8 x 8 棋盘 Board[0-7][0-7] 的某个方格中，马按走棋规则（马走日字）进行移
			动，要求每个方格只进入一次，走遍棋盘上全部 64 个方格
			B. 使用带图的深度优先遍历算法（DFS）+贪心算法优先
	2. 数据结构和算法的重要性
		① 算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高速计算
		② 一般来讲 程序会使用了内存计算框架(比如Spark)和缓存技术(比如Redis等)来优化程序,再深入的思考一下，这些计算框架和缓存技术，它的核心功能是
		哪个部分呢？
		③ 目前程序员面试的门槛越来越高，很多一线IT公司(大厂)，都会有数据结构和算法面试题
二、数据结构和算法概述
	1. 数据结构和算法的关系
		① 数据data结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构。学好数据结构可以编写出更加漂亮，更加有效率的代码。
		② 要学习好数据结构就要多多考虑如何将生活中遇到的问题，用程序去实现解决。
		③ 程序 = 数据结构 + 算法
		④ 数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。
	2. 几个实际编程中遇到的问题
		① 问题一
			A. Java代码:
				public static void main(String[] args) {
					String str = "Java,Java, hello,world!";
					String newStr = str.replaceAll("Java", "尚硅谷~"); //算法
					System.out.println("newStr=" + newStr);
				}
			B. 问：试写出用单链表表示的字符串类及字符串结点类的定义，并依次实现它的构造函数、以及计算串长度、串赋值、判断两串相等、求子串、两串连接、
			求子串在串中位置等7个成员函数。
		② 一个五子棋程序
			A. 如何判断游戏的输赢，并可以完成存盘退出和继续上局的功能
			B. 提示
				a. 棋盘（二维数组）=>（稀疏数组）=> 写入文件（存档功能）
				b. 读取文件 => 稀疏数组 => 二维数组 => 棋盘 【接上局】
		③ 约瑟夫(Josephu)问题(丢手帕问题)
			A. Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 
			开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
			B. 提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表（单向环形链表），然后由 k 结点起从 1 开始计数，
			计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。
		④ 其它常见算法问题:
			A. 修路问题  => 最小生成树（加权值）【数据结构】+ 普利姆算法
			B. 最短路径问题  => 图+弗洛伊德算法
			C. 汉诺塔 => 分支算法 
			D. 八皇后问题 => 回溯法
	3. 线性结构和非线性结构
		① 数据结构包括：线性结构和非线性结构。
		② 线性结构
			A. 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系
			B. 线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的
			C. 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
			D. 线性结构常见的有：数组、队列、链表和栈，后面我们会详细讲解
		③ 非线性结构：非线性结构包括：二维数组，多维数组，广义表，树结构，图结构
三、稀疏数组和队列
	1. 稀疏（sparsearray）数组
		① 先看一个实际的需求
			A. 编写的五子棋程序中，有存盘退出和续上盘的功能
			B. 分析问题: 因为该二维数组的很多值是默认值0，因此记录了很多没有意义的数据，可以转换为稀疏数组进行保存。
		② 基本介绍
			A. 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。
			B. 稀疏数组的处理方法是:
				a. 记录数组一共有几行几列，有多少个不同的值
				b. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模
			C. 稀疏数组举例说明
				| 0  | 0  | 0  | 22 | 0  | 0  | 15 |		 	|	行  |  列   |   值	  |
				| 0  | 11 | 0  | 0  | 0  | 17 | 0  |	  	 	|（row）|（col）|（value）|
				| 0  | 0  | 0  | -6 | 0  | 0  | 0  |			+-------+-------+---------+
				| 0  | 0  | 0  | 0  | 0  | 39 | 0  |		[0] |   6   |   7   |    8    |
				| 91 | 0  | 0  | 0  | 0  | 0  | 0  |		[1] |   0   |   3   |    22   |
				| 0  | 0  | 28 | 0  | 0  | 0  | 0  |		[2] |   0   |   6   |    15   |
															[3] |   1   |   1   |    11   |
															[4] |   1   |   5   |    17   |
															[5] |   2   |   3   |    -6   |
															[6] |   3   |   5   |    39   |
															[7] |   4   |   0   |    91   |
															[8] |   5   |   2   |    28   |
		③ 应用实例
			A. 将上面的二维数组与稀疏数组进行相互转换
			B. 二维数组转系数数组的思路
				a. 遍历原始的二维数组，得到有效数据的个数
				b. 根据 sum 就可以创建稀疏数组 sparseArr[sum + 1][3]
				c. 将二维数组的有效数据存入到稀疏数组
			C. 稀疏数组转二维数组的思路
				a. 先读取稀疏数组的第一行，根据第一行的数据，创建二维数组 chessArr[6][7]
				b. 再读取稀疏数组后几行的数据，并赋值给原始的二维数组即可
			D. 示例代码参考 SparseArrayDemo.java
	2. 队列
		① 队列介绍
			A. 队列是一个有序列表，可以用数组或是链表来实现。
			B. 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出
			C. 示意图：(使用数组模拟队列示意图)
					  +----+					+----+						+----+
			maxSize-1 |    |		  maxSize-1 |    |			  maxSize-1 |    |
					  +----+		  		    +----+					  	+----+
					. |    |				  . |    |					  . |    |
					  +----+				    +----+						+----+
					3 |    |				  3 |    | <- rear=3		  3 |    | <- rear=3
					  +----+					+----+						+----+
					2 |    |				  2 |    |					  2 |    | <- front=2
					  +----+				    +----+						+----+
					1 |    |				  1 |    |					  1 |    |
					  +----+				    +----+						+----+
					0 |    |				  0 |    |					  0 |    |
					  +----+ <- rear=-1		    +----+ 						+----+
					   Queue <- front=-1		 Queue <- front=-1			Queue 
		② 数组模拟队列
			A. 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。
			B. 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear 分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear
			则是随着数据输入而改变
			C. 我们将数据存入队列时称为 addQueue，addQueue 的处理需要有两个步骤：思路分析
				a. 当 front == rear，队列空
				b. 将尾指针往后移：rear+1
				c. 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据
				d. 当 rear  == maxSize - 1，队列满
			D. 示例代码参考 ArrayQueueDemo.java
		③ 数组模拟环形队列
			A. 对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的式来实现即可)
			B. 分析说明：
				a. 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意：(rear + 1) % maxSize == front 
				b. rear == front
			C. 思路如下：
				a. front 变量的含义是指向队列的第一个元素，也就是说 arr[front] 就是队列的第一个元素，front 的初始值为 0
				b. rear 变量的含义是指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，rear 的初始值为 0
				c. 当队列满时，条件是 (rear + 1) % maxSize == front，此时会空出一个位置
				d. 当队列空时，条件是 rear == front
				e. 队列中的有效数据的个数为 (rear - front + maxSize) % maxSize，即当队列的长度为 5 时，如果此时队列已经满了，那么队列中的有效个数为 4
			D. 示例代码参考 CircleArrayQueueDemo.java
四、链表
	1. 链表(Linked List)介绍
		① 链表是有序的列表，但是它在内存中是存储如下
				 头指针		地址	data域 next域
				 +-----+			+-----+-----+
			head | 150 |	110		| a2  | 180 |
				 +-----+			+-----+-----+
									|	  |		|
									+-----+-----+
									| a4  |	170	|
									+-----+-----+
									| a6  |	NULL|
									+-----+-----+
									| a1  |	110 |
									+-----+-----+
									|	  |		|
									+-----+-----+
									| a5  |	140	|
									+-----+-----+
									| a3  |	130 |
									+-----+-----+
		② 小结
			A. 链表是以节点的方式来存储,是链式存储
			B. 每个节点包含 data 域， next 域：指向下一个节点
			C. 链表的各个节点不一定是连续存储
			D. 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定
	2. 单链表介绍
		① 单链表(带头结点) 逻辑结构示意图如下
					+----+----+	   +----+----+	  +----+----+	 			+----+----+
			head -> | 头 |    | -> | a1 |    | -> | a2 |    | -> ...... ->	| an |    |
					+----+----+	   +----+----+	  +----+----+	 			+----+----+
		② 单链表的应用实例
			A. 使用带head头的单向链表实现水浒英雄排行榜管理
			B. 完成对英雄人物的增删改查操作
			C. 第一种方法在添加英雄时，直接添加到链表的尾部
				a. 先创建一个 head 头节点，作用就是表示单链表的头
				b. 后面每添加一个节点，就直接加入到链表的最后
			D. 第二种方式在添加英雄时，根据排名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示）
				a. 首先找到新添加的节点的位置，是通过辅助变量（指针），通过遍历来搞定
				b. 新的节点 .next = temp.next
				c. 将 temp.next = 新的节点
			E. 遍历：通过一个辅助遍历，帮助遍历整个链表
			F. 修改：根据 no 编号来修改
			G. 删除一个节点
				a. 先找到需要删除的这个节点的前一个节点 temp
				b. 比较时，使用 temp.next.no 和需要删除的节点的 no 比较
				c. 删除节点时，使 temp.next = temp.next.next
				d. 被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收
			H. 示例代码见 SingleLinkedListDemo.java
		③ 单链表面试题(新浪、百度、腾讯)
			A. 求单链表中有效节点的个数
			B. 查找单链表中的倒数第k个结点（新浪面试题），思路：倒数第 k 个节点 = size - k;
			C. 单链表的反转（腾讯面试题），思路：
				a. 先定义一个节点，代表新的头节点 reverseHead
				b. 从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表 reverseHead 的最前端
				c. 原来的链表 head.next = reverseHead.next
			D. 从尾到头打印单链表 （百度，方式1：反转遍历；方式2：Stack 栈）
			E. 合并两个有序的单链表，合并之后的链表依然有序
	3. 双向链表应用实例
		① 单向链表的缺点分析
			A. 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找
			B. 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除
		② 双向列表的遍历、添加、修改、删除的操作思路
			A. 遍历和单链表一样，只是可以向前，也可以向后查找
			B. 添加（默认添加到双向链表的最后）
				a. 先找到双向链表的最后这个节点
				b. temp.next = newHeroNode
				c. newHeroNode.pre = temp;
			C. 修改思路、原理和单向链表一样
			D. 删除
				a. 因为是双向链表，因此，可以实现自我删除某个节点
				b. 直接找到要删除的这个节点，比如 temp
				c. temp.pre.next = temp.next
				d. temp.next.pre = temp.pre，需要判断删除的节点是否为最后一个节点
			E. 按照指定顺序添加节点
				a. 找到新节点的添加位置
				b. 加入节点时，先处理当前位置的下一个节点，再处理当前位置的节点
				c. temp.next.pre = node; 需要判断当前位置是否为最后一个节点
				d. node.next = temp.next;
				e. node.pre = temp;
				f. temp.next = node;
		③ 示例代码见 DoubleLinkedListDemo.java
	4. 单向环形链表应用场景
		① Josephu(约瑟夫、约瑟夫环) 问题
			A. Josephu 问题为：设编号为1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，
			数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
			B. 提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链
			表中删除，删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。
		② 约瑟夫问题示意图
			+------+	   +------+	   	  +------+
			|  1   |	   |  2   |	   	  |  3   |
			| next | ----> | next | ----> | next |
			+------+	   +------+		  +------+
				↑							 |
				|							 ↓
			+------+					  +------+
			|  5   |					  |  4   |
			| next | <------------------- | next |
			+------+					  +------+
			A. 假设 n = 5，既有五个人
			B. k = 1，从第一个人开始报数
			C. m = 2，数两下
			D. 出队的顺序：2 -> 4 -> 1 -> 5 -> 3
		③ 单向环形链表构建和遍历思路
			A 构建
				a. 先创建第一个节点，让 first 指向该节点，并形成环形
				b. 后面每当创建一个新的节点，就把该节点加入到已有的环形链表即可，并让当前指针指向该节点
			B. 遍历
				a. 先让一个辅助指针 curr，指向 first 节点
				b. 然后通过一个 while 循环遍历该环形链表即可，当 curr.next == first 结束。
			C. 单向环形链表出圈顺序思路
				a. 需要创建一个辅助指针（变量）helper，事先应该指向环形链表的最后这个节点
				b. 报数前，先让 first 和 helper 移动 k-1 次
				c. 报数时，让 first 和 helper 移动 m-1 次
				d. 这时就可以将 first 指向的节点出列
					first = first.next;
					help.next = first;
				e. 当链表只剩下一个节点时，退出循环
		④ 示例代码见 JosephuDemo.java
五、栈
	1. 栈的一个实际需求
		① 请输入一个表达式：7*2*2-5+1-5+3-3
		② : 计算机底层是如何运算得到结果的？注意不是简单的把算式列出运算，因为我们看这个算式 7 * 2 * 2 - 5，但是计算机怎么理解这个算式的（对计算机而言，它接
		收到的就是一个字符串)，我们讨论的是这个问题。
	2. 栈的介绍
		① 栈的英文为 stack，栈是一个先入后出（FILO-First In Last Out）的有序列表。
		② 栈（stack）是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（Top），另一端为固
		定的一端，称为栈底（Bottom）。
		③ 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除
	3. 栈的应用场景
		A. 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 	
		B. 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
		C. 表达式的转换[中缀表达式转后缀表达式]与求值（实际解决）。
		D. 二叉树的遍历。
		E. 图形的深度优先(depth一first)搜索法。
	4. 栈的快速入门
		① 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。
		② 示例代码见 ArrayStackDemo.java
	5. 栈实现综合计算器思路
		① 通过一个 index 值（索引），来遍历表达式
		② 如果扫描的是一个数字，就直接入数栈
		③ 如果扫描的是一个符号，有以下情况
			A. 如果当前符号栈为空，就直接入栈
			B. 如果符号栈有操作符，就进行比较，如果当前操作符的优先级小于或者等于栈中的操作符，就从数栈中 pop 出两个数，再从符号栈中 pop 出一个符号，进行运算
			将得到的结果重新入数栈，然后将当前的操作符入符号栈。如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
		④ 当表达式扫描完毕，就顺序的从数栈和符号栈中 pop 出相应的数值和符号，进行运算
		⑤ 最后在数栈中只有一个数字，就是表达式的结果
		⑦ 示例代码见 Calculator.java
	6. 前缀、中缀、后缀表达式(逆波兰表达式)
		① 前缀表达式(波兰表达式)
			A. 前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前
			B. 举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6
		② 前缀表达式的计算机求值
			A. 从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入
			栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果
			B. 例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:
				a. 从右至左扫描，将6、5、4、3压入堆栈
				b. 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈
				c. 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈
				d. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果
		③ 中缀表达式
			A. 中缀表达式就是常见的运算表达式，如(3+4)×5-6
			B. 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作（一般转成后缀表达式）
		④ 后缀表达式
			A. 后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后
			B. 举例说明：(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –
			C. 再比如:
				正常表达式	逆波兰表达式
				a+b			a b +
				a+(b-c)		a b c - +
				a+(b-c)*d	a b c - d * +
				a+d*(b-c)	a d b c - * +
				a=1+3		a 1 3 + =
	7. 逆波兰计算器
		① 后缀表达式的计算机求值
			A. 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素和栈顶元素），并将结果入
			栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果
			B. 例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:
				a. 从左至右扫描，将3和4压入堆栈；
				b. 遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；
				c. 将 5 入栈；
				d. 接下来是×运算符，因此弹出5和7，计算出 7×5=35，将 35 入栈；
				e. 将 6 入栈；
				f. 最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
		② 逆波兰计算器
			A. 输入一个逆波兰表达式（后缀表达式），使用栈（Stack）, 计算其结果
			B. 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。
			思路分析
			代码完成
		③ 中缀表达式转换为后缀表达式
			A. 后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将 中缀表达式转成后缀表达式。
			B. 具体步骤如下
				a. 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2；
				b. 从左至右扫描中缀表达式；
				c. 遇到操作数时，将其压 s2；
				d. 遇到运算符时，比较其与 s1 栈顶运算符的优先级：
					(1) 如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
					(2) 否则，若优先级比栈顶运算符的高，也将运算符压入 s1；
					(3) 否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到 4.1 与 s1 中新的栈顶运算符相比较；
				e. 遇到括号时：
					(1) 如果是左括号“(”，则直接压入 s1
					(2) 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃
				f. 重复步骤 2 至 5，直到表达式的最右边
				g. 将 s1 中剩余的运算符依次弹出并压入 s2
				h. 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式
			C. 举例说明：将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的结果为“1 2 3 + 4 × + 5 –”，过程如下：
				+--------------+-------------------+-----------------+-------------------------------------+
				| 扫描到的元素 | s2（栈底->栈顶）  | s1（栈底->栈顶）| 说明								   |
				+--------------+-------------------+-----------------+-------------------------------------+
				| 1			   | 1				   | 空			     | 数字，直接入栈					   |
				| +			   | 1				   | +			     | s1 为空，运算符直接入栈			   |
				| (			   | 1				   | + (		     | 左括号，直接入栈					   |
				| (			   | 1				   | + ( (		     | 左括号，直接入栈					   |
				| 2			   | 1 2			   | + ( (		     | 数字，直接入栈					   |
				| +			   | 1 2			   | + ( ( +	     | s1 栈顶为左括号，运算符直接入栈	   |
				| 3			   | 1 2 3			   | + ( ( +	     | 数字，直接入栈					   |
				| )			   | 1 2 3 +		   | + (		     | 右括号，s1 弹出运算符直至遇到左括号 |
				| *			   | 1 2 3 +		   | + ( *		     | s1 栈顶为左括号，运算符直接入栈	   |
				| 4			   | 1 2 3 + 4		   | + ( *		     | 数字，直接入栈					   |
				| )			   | 1 2 3 + 4 *	   | +			     | 右括号，s1 弹出运算符直至遇到左括号 |
				| -			   | 1 2 3 + 4 * +	   | -			     | - 与 + 优先级相同，弹出+，在入栈 -  |
				| 5			   | 1 2 3 + 4 * + 5   | -			     | 数字，直接入栈					   |
				| 到达最右端   | 1 2 3 + 4 * + 5 - | 空			     | s1 中剩余的运算符				   |
				+--------------+-------------------+-----------------+-------------------------------------+
		④ 逆波兰计算器完整版，功能包括
			A. 支持 + - * / ( ) 
			B. 多位数，支持小数,
			C. 兼容处理, 过滤任何空白字符，包括空格、制表符、换页符
		⑤ 示例代码见 PolishNotationDemo.java
六、递归
	1. 递归应用场景：迷宫问题(回溯)， 递归(Recursion)
	2. 递归的概念
		① 简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。
	3. 递归调用机制
		① 打印问题
			public static void test(int n) {
				if (n > 2) {
					test(n - 1);
				}
				System.out.println("n=" + n);
			}
		② 阶乘问题
			public static int factorial(int n) {
				if (n == 1) {
					return 1;
				} else {
					return factorial(n - 1) * n;
				}
			}
	3. 递归能解决什么样的问题
		① 各种数学问题如: 8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题（google编程大赛）
		② 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等
		③ 将用栈解决的问题替换为使用递归，使得代码比较简洁
	4. 递归需要遵守的重要规则
		① 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
		② 方法的局部变量是独立的，不会相互影响, 比如 n 变量
		③ 如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据
		④ 递归必须向退出递归的条件逼近，否则就是无限递归，出现 StackOverflowError（栈溢出）
		⑤ 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。
	5. 递归-迷宫问题
		① 说明：
			A. 小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右的顺序相关
			B. 再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化
			C. 测试回溯现象
			D. 思考: 如何求出最短路径? 
		② 思路分析
			A. 使用二维数组 map 表示地图
			B. i，j 表示从地图的哪个位置开始出发（1,1）
			C. 如果小球能到 map[6][5] 的位置，则说明通路找到了
			D. 约定：当 map[i][j] 为 0 时表示该点没有走过，当为 1 时表示墙，为 2 时表示通路可以走，为 3 时表示该点已经走过，但是走不通
			E. 在走迷宫时，需要确定一个策略（方法），从下右上左的顺序进行尝试，如果该点走不通，再回溯
		③ 示例代码：RecursionMazeDemo.java
	6. 递归-八皇后问题(回溯算法)
		① 八皇后问题介绍
			A. 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8 × 8 格
			的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。
			B. 八皇后问题算法思路分析
				a. 第一个皇后先放第一行第一列
				b. 第二个皇后放在第二行第一列、然后判断是否 OK，如果不 OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
				c. 继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确解
				d. 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到
				e. 然后回头继续第一个皇后放第二列，后面继续循环执行 1，2，3，4 的步骤 






















































































































