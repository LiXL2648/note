一、排序算法
	1. 排序算法的介绍
		① 排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。
		② 排序的分类
			A. 内部排序法：指将需要处理的所有数据都加载到内部存储器中进行排序
			B. 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序
			C. 常见的排序算法分类：
															   +---- 直接插入排序
															   |
											+---- 插入排序 ----+
											|				   |
											|				   +---- 希尔排序
											|
											|				   +---- 简单选择排序
											|				   |
											+---- 选择排序 ----+
											|				   |
											|				   +---- 堆排序
											|
						 +---- 内部排序 ----+
						 |					|
						 |					|				   +---- 冒泡排序
						 |					|				   |
						 |					+---- 交换排序 ----+
						 |					|				   |
						 |					|				   +---- 快速排序
				排序 ----+					|
						 |					+---- 归并排序
						 |					|
						 |					+---- 基数排序
						 |
						 |
						 +---- 外部排序
	2. 算法的时间复杂度
		① 度量一个程序（算法）执行时间的两种方法
			A. 事后统计的方法：这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机
			的硬件、软件等环境因素，这种方式，要在同一台计算机的相同状态下运行，才能比较哪个算法速度更快
			B. 事前估算的方法：通过分析某个算法的时间复杂度来判断哪个算法更优
		② 时间频度
			A. 基本介绍：一个算法花费的时间与算法中语句的执行次数成正比，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或
			时间频度，记为 T(n)
			B. 举例说明
				a. 基本案例：比如计算1-100所有数字之和，设计两种算法：
					int total = 0;
					int end = 100;
					// 使用 for 循环计算
					for(int i = 1; i <= end; i++) {
						total += i;
					}
					// T(n) = n + 1
					
					// 直接计算
					total = (1 + end) * end / 2;
					// T(n) = 1
				b. 忽略常数项
					+-----+----------------+-----------+----------------+-----------+
					|	  | T(n) = 2n + 20 | T(n) = 2n | T(n) = 3n + 10 | T(n) = 3n |
					+-----+----------------+-----------+----------------+-----------+
					|  1  |		  22	   |	 2	   |		13		|	  3		|
					+-----+----------------+-----------+----------------+-----------+
					|  2  |		  24	   |	 4	   |		16		|	  6		|
					+-----+----------------+-----------+----------------+-----------+
					|  5  |		  30	   |	 10	   |		25		|	  15    |
					+-----+----------------+-----------+----------------+-----------+
					|  8  |		  36	   |	 16	   |		34		|	  24	|
					+-----+----------------+-----------+----------------+-----------+
					| 15  |		  50	   |	 30	   |		55		|	  45	|
					+-----+----------------+-----------+----------------+-----------+
					| 30  |		  80	   |	 60	   |		100		|	  90	|
					+-----+----------------+-----------+----------------+-----------+
					| 100 |		  220	   |	 200   |		310		|	  300	|
					+-----+----------------+-----------+----------------+-----------+
					| 300 |		  620	   |	 600   |		910		|	  900	|
					+-----+----------------+-----------+----------------+-----------+
					结论：
					(1) 2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略
					(2) 3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略
				c. 忽略低次项
					+-----+-----------------------+-------------+----------------------+------------+
					|	  | T(n) = 2n^2 + 3n + 10 | T(n) = 2n^2 | T(n) = n^2 + 5n + 20 | T(n) = n^2 |
					+-----+-----------------------+-------------+----------------------+------------+
					|  1  |			 15			  |		2		|			26		   |	 1		|
					+-----+-----------------------+-------------+----------------------+------------+
					|  2  |			 24			  |		8		|			34		   |	 4		|
					+-----+-----------------------+-------------+----------------------+------------+
					|  5  |			 75			  |		50		|			70		   |	 25		|
					+-----+-----------------------+-------------+----------------------+------------+
					|  8  |			 162		  |		128		|			124		   |	 64		|
					+-----+-----------------------+-------------+----------------------+------------+
					| 15  |			 505		  |		450		|			320		   |	 225	|
					+-----+-----------------------+-------------+----------------------+------------+
					| 30  |			 1900		  |		1800	|			1070	   |	 900	|
					+-----+-----------------------+-------------+----------------------+------------+
					| 100 |			 20310		  |		20000	|			10520	   |	 10000	|
					+-----+-----------------------+-------------+----------------------+------------+
					结论:
					(1) 2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10
					(2) n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20
				d. 忽略系数
					+-----+------------------+------------------+-----------------+------------------+
					|	  | T(n) = 3n^2 + 3n | T(n) = 5n^2 + 7n | T(n) = n^3 + 5n | T(n) = 6n^3 + 4n |
					+-----+------------------+------------------+-----------------+------------------+
					|  1  |		  5			 |		12			|		6		  |		 10			 |
					+-----+------------------+------------------+-----------------+------------------+
					|  2  |		  16		 |		34			|		18		  |		 56			 |
					+-----+------------------+------------------+-----------------+------------------+
					|  5  |		  85		 |		160			|		150		  |		 770		 |
					+-----+------------------+------------------+-----------------+------------------+
					|  8  |		  208		 |		376			|		552		  |		 3104		 |
					+-----+------------------+------------------+-----------------+------------------+
					| 15  |		  705		 |		1230		|		3450	  |		 20310		 |
					+-----+------------------+------------------+-----------------+------------------+
					| 30  |		  2760		 |		4710		|		27150	  |		 162120		 |
					+-----+------------------+------------------+-----------------+------------------+
					| 100 |		  30200		 |		50700		|		1000500	  |		 6000400	 |
					+-----+------------------+------------------+-----------------+------------------+
					结论:
					(1) 随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。
					(2) 而n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方式关键
		③ 时间复杂度
			A. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n) 表示，若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，
			T(n)/f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数。记作 T(n) = O(f(n))，称 O(f(n)) 为算法的渐进时间复杂度，简称时间
			复杂度
			B. T(n) 不同，但时间复杂度可能相同。如：T(n) = n^2 + 7n + 6 与 T(n) = 3n^2 + 2n + 2 它们的 T(n) 不同，但时间复杂度相同，都为 O(n^2)。
			C. 计算时间复杂度的方法
				a. 用常数 1 代表运行时间中的所有加法常数 T(n) = 3n^2 + 7n + 6 => T(n) = 3n^2 + 7n + 1
				b. 修改后的运行次数函数中，只保留最高阶项 T(n) = 3n^2 + 7n + 1 => T(n) = 3n^2
				c. 去除最高阶项的系数 T(n) = 3n^2 => T(n) = n^2 => O(n^2)
		④ 常见的时间复杂度
			A. 常数阶 O(1)
				a. 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)
				b. 举例：
					int i = 1;
					int j = 2;
					++i;
					j++;
					int m = i + j;
				c. 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用 O(1) 来表示它
				的时间复杂度。
			B. 对数阶 O(log2n)
				a. 举例：
					int i = 1;
					while(i < n) {
						i *= 2;
					}
				b. 说明：在 while 循环里，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近。假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也
				就是说 2 的 x 次方等于 n，那么 x = log2n 也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为 O(log2n)。O(log2n)
				的这个 2 实际上是根据代码变化的， i *= 3，则是 O(log3n)
			C. 线性阶O(n)
				a. 举例：
					for(int i = 0; i < n; i++) {
						j = i;
						j++;
					}
				b. 说明：这段代码，for 循环里面的代码会执行 n 遍，因此它消耗时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n) 来表示它的时间复杂度。
			D. 线性对数阶 O(nlog2n)
				a. 举例：
					for(i = 0;i < n; i++) {
						int j = 1;
						while(j < n) {
							j *= 2;
						}
					}
				b. 说明：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)
			E. 平方阶 O(n^2)
				a. 举例：
					for(i = 0;i < n; i++) {
						for(j = 0;i < n; i++) {
							j = i;
							j++;
						}
					}
				b. 说明：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复
				杂度就是 O(n*n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n)
			F. 立方阶 O(n^3)
				a. 说明：参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似
			G. k次方阶 O(n^k)
			H. 指数阶O(2^n)
			I. 常见的算法时间复杂度由小到大依次为：O(1) < O(log2n) < O(n) < O(nlog2n) < O(n^2) < O(n^3) < O(n^k) < O(2^n)
			J. 我们应该尽可能避免使用指数阶的算法
		⑤ 平均时间复杂度和最坏时间复杂度
			A. 平均时间复杂度是指所有可能额输入实例均以等概率出现的情况下，该算法的运行时间
			B. 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入
			实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况长
			C. 平均时间复杂度和最坏时间复杂度是否一致，和算法有关
				+----------+----------+--------------+--------+----------+------------------------------------+
				| 排序法   | 平均时间 | 最差情形	 | 稳定度 | 额外空间 | 备注								  |
				| 冒泡排序 | O(n^2)	  | O(n^2)		 | 稳定	  | O(1)	 | n 小时较好						  |
				} 交换排序 | O(n^2)	  | O(n^2)		 | 不稳定 | O(1)	 | n 小时较好						  |
				| 选择排序 | O(n^2)	  | O(n^2)		 | 不稳定 | O(1)	 | n 小时较好						  |
				| 插入排序 | O(n^2)	  | O(n^2)		 | 稳定	  | O(1)	 | 大部分已排序时较好				  |
				| 基数排序 | O(logRB) | O(logRB)	 | 稳定	  | O(n)	 | B 是真数（0-9），R是基数（个十百） |
				| 希尔排序 | O(nlogn) | O(n^s 1<s<2) | 不稳定 | O(1)	 | s 是所选分组						  |
				| 快速排序 | O(nlogn) | O(n^2)		 | 不稳定 | O(nlogn) | n 大时较好						  |
				| 归并排序 | O(nlogn) | O(nlogn)	 | 稳定	  | O(1)	 | n 大时较好						  |
				| 堆排序   | O(nlogn) | O(nlogn)	 | 不稳定 | O(1)	 | n 大时较好						  |
				+----------+----------+--------------+--------+----------+------------------------------------+
	3. 算法的空间复杂度简介
		① 基本介绍
			A. 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。
			B. 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着
			n 的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况
			C. 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空
			间换时间。
	4. 冒泡排序
		① 基本介绍
			A. 冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元
			素逐渐从前向后移动，就像水底下的气泡一样逐渐向上冒。
			B. 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进
			行过交换，从而减少不必要额比较。（这里说的优化，可以在冒泡排序写好后，再进行）
		② 冒泡排序应用实例
			A. 我们将五个无序的数：3, 9, -1, 10, -2 使用冒泡排序法将其排成一个从小到大的有序数列。
			B. 冒泡排序算法代码实现
				public class BubbleSortDemo {

					public static void main(String[] args) {
						// int[] arr = {3, 9, -1, 10, -2};
						int max = 1000000;
						int[] arr = new int[max];
						for (int i = 0; i < max; i++) {
							arr[i] = (int) (Math.random() * max);
						}
						// System.out.println("排序前：" + Arrays.toString(arr));
						long start = System.currentTimeMillis();
						bubbleSort(arr);
						long end = System.currentTimeMillis();
						System.out.println("总共花费时间：" + (end - start));
						// System.out.println("排序后：" + Arrays.toString(arr));
					}
					
					public static void bubbleSort(int[] arr) {

						int temp;
						boolean flag = true;
						for (int i = 0; i < arr.length - 1; i++) {
							for (int j = 0; j < arr.length - i - 1; j++) {
								if (arr[j] > arr[j + 1]) {
									flag = false;
									temp = arr[j];
									arr[j] = arr[j + 1];
									arr[j + 1] = temp;
								}
							}
							// System.out.printf("第%d次排序后的数组：", i + 1);
							// System.out.println(Arrays.toString(arr));
							if (flag) {
								break;
							} else {
								flag = true;
							}
						}
					}
				}
	5. 选择排序
		① 基本介绍：选择排序也属于内部排序，是从待排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的
		② 基本思想：选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0] 到 arr[arr.length - 1] 中选取最小值，与 arr[0] 交换，
		第二次从 arr[1] 到 arr[arr.length - 1] 中选取最小值，与 arr[1] 交换，第 i 次从 arr[i - 1] 到 arr[arr.length - 1] 中选取最小值，与 arr[i - 1] 交换,
		第 n - 1 次从 arr[n - 2] 到 arr[arr.length - 1] 中选取最小值，与 arr[n - 2] 交换，总共通过 n - 1 次，得到一个升序序列。
		③ 选择排序应用实例
			A. 有一群牛 , 颜值分别是 101, 34, 119, 1 请使用选择排序从低到高进行排序 [101, 34, 119, 1]
			B. 选择排序算法代码实现
				public class SelectSortDemo {

					public static void main(String[] args) {
						// int[] arr = {101, 34, 119, 1};
						int max = 1000000;
						int[] arr = new int[max];
						for (int i = 0; i < max; i++) {
							arr[i] = (int) (Math.random() * max);
						}
						// System.out.println("排序前：" + Arrays.toString(arr));
						long start = System.currentTimeMillis();
						selectSort(arr);
						long end = System.currentTimeMillis();
						System.out.println("总共花费时间：" + (end - start));
						// System.out.println("排序后：" + Arrays.toString(arr));
					}

					public static void selectSort(int[] arr) {

						int temp, index;
						for (int i = 0; i < arr.length - 1; i++) {
							temp = arr[i];
							index = i;
							for (int j = i + 1; j < arr.length; j++) {
								if (temp > arr[j]) {
									temp = arr[j];
									index = j;
								}
							}
							if (i != index) {
								arr[index] = arr[i];
								arr[i] = temp;
							}
						}
					}
				}
	6. 插入排序
		① 基本介绍：插入排序属于内部排序，是对于待排序的元素以插入的方式寻找元素适当位置，以达到排序的目的
		② 基本思想：插入排序（insertion Sorting）的基本思想是：把 n 个待排序的元素看成为一个有序和一个无序列表，开始时有序列表中只包含一个元素，无序表中包含
		有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使其成为新的有序表
		③ 插入排序法应用实例
			A. 有一群小牛, 考试成绩分别是 101, 34, 119, 1  请从小到大排序
			B. 插入排序算法代码实现
				public class InsertSortDemo {

					public static void main(String[] args) {
						// int[] arr = {101, 34, 119, 1};
						int max = 10000000;
						int[] arr = new int[max];
						for (int i = 0; i < max; i++) {
							arr[i] = (int) (Math.random() * max);
						}
						// System.out.println("排序前：" + Arrays.toString(arr));
						long start = System.currentTimeMillis();
						insertSort(arr);
						long end = System.currentTimeMillis();
						System.out.println("总共花费时间：" + (end - start));
						// System.out.println("排序后：" + Arrays.toString(arr));
					}

					public static void insertSort(int[] arr) {
						// 有序序列的最后一个元素下标
						int index;
						// 无序序列的第一个元素
						int temp;
						for (int i = 1; i < arr.length; i++) {
							index = i - 1;
							temp = arr[i];
							while (index >= 0 && temp < arr[index]) {
								// 如果没找到位置，则元素向后移动
								arr[index + 1] = arr[index];
								index--;
							}
							if (index != i) {
								arr[index + 1] = temp;
							}
						}
					}
				}
	7. 希尔排序
		① 简单插入排序存在的问题：需要插入的数是较小的数时，后移的次数明显增多，对效率有影响
		② 基本介绍：希尔排序是希尔（Donall Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效版本，也称为
		缩小增量排序
		③ 基本思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件
		被分成一组，算法便终止。
		④ 希尔排序示意图
			A. 原始数组
				8 9 1 7 2 3 5 4 6 0
			B. 初始增量 gap = leng / 2 = 5，意味着整个数组被分成 5 组，[8, 3][9, 5][1, 7][2, 6][3, 0]
								+-------------------+
								|					|
							+---+---------------+	|
							|	|				|	|
						+---+---+-----------+	|	|
						|	|	|			|	|	|
					+---+---+---+-------+	|	|	|
					|	|	|	|		|	|	|	|
				+---+---+---+---+---+	|	|	|	|
				|	|	|	|	|	|	|	|	|	|
				↓	↓	↓	↓	↓	↓	↓	↓	↓	↓
				8   9   1   7   2   3   5   4   6   0  
			C. 对这 5 组分别进行直接插入排序，结果如下，可以看到，像 3, 5, 6 这些小元素都被调到前面了，然后缩小增量 gap = 5 / 2 = 2，数组被分成 2 组 [3, 1, 0, 9, 7]
			[5, 6, 8, 4, 2]
					+-------+-------+-------+-------+
					|		|		|		|		|
					|		|		|		|		|
				+---+---+---+---+---+---+---+---+---+
				|	|	|	|	|	|	|	|	|	|
				↓	↓	↓	↓	↓	↓	↓	↓	↓	↓
				3   5   1   6   0   8   9   4   7   2
			D. 对以上 2 组再分别进行直接插入排序，结果如下，可以看到，此时整个数组的有序更进一步。再缩小增量 gap = 2 / 2 = 1，此时数组为 1 组 [0, 2, 1, 4, 3, 5, 7, 6, 9, 8]
				+---+---+---+---+---+---+---+---+---+
				|	|	|	|	|	|	|	|	|	|
				↓	↓	↓	↓	↓	↓	↓	↓	↓	↓	
				0   2   1   4   3   5   7   6   9   8
			E. 此时，仅仅需要对以上数列简单微调，无需大量移动操作即可完成整个数组的排序
		⑤ 希尔排序法应用实例
			A. 有一群小牛, 考试成绩分别是 {8,9,1,7,2,3,5,4,6,0} 请从小到大排序。
			B. 希尔排序（交换法）算法代码实现
				public class ShellSortDemo {

					public static void main(String[] args) {
						// int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0};
						int max = 10000000;
						int[] arr = new int[max];
						for (int i = 0; i < max; i++) {
							arr[i] = (int) (Math.random() * max);
						}
						// System.out.println("排序前：" + Arrays.toString(arr));
						long start = System.currentTimeMillis();
						// shellSortExchange(arr);
						shellSortInsert(arr);
						long end = System.currentTimeMillis();
						System.out.println("总共花费时间：" + (end - start));
						// System.out.println("排序后：" + Arrays.toString(arr));
					}

					public static void shellSortExchange(int[] arr) {
						int temp;
						for (int gap = arr.length / 2; gap > 0; gap /= 2) {
							for (int i = gap; i < arr.length; i++) {
								if (arr[i] < arr[i - gap]) {
									for (int j = i - gap; j >= 0; j -= gap) {
										if (arr[j] > arr[j + gap]) {
											temp = arr[j];
											arr[j] = arr[j + gap];
											arr[j + gap] = temp;
										}
									}
								}
							}
						}
					}
				}
			C. 希尔排序（移动法）算法代码实现
				public static void shellSortInsert(int[] arr) {
					int index, temp;
					for (int gap = arr.length / 2; gap > 0; gap /= 2) {
						for (int i = gap; i < arr.length; i++) {
							if (arr[i] < arr[i - gap]) {
								index = i - gap;
								temp = arr[i];
								while (index >= 0 && temp < arr[index]) {
									arr[index + gap] = arr[index];
									index -= gap;
								}
								arr[index + gap] = temp;
							}
						}
					}
				}
	8. 快速排序
		① 基本介绍：快速排序（QuickSort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分
		额所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以使用递归进行，以此达到整个数据变成有序序列
		② 快速排序示意图
			+-------------------------------------------------------------------------------------------------------------------+
			|										2, 10, 8, 22, 34, 5, 12, 28, 21, 11											|
			+-------------------------------------------------------------------------------------------------------------------+
																| 以 11 为基准，分解问题
								+-------------------------------+-----------------------------------+
								|								|									|
			+-------------------------------------------+	+---+---+	+-------------------------------------------------------+
			|				2, 10, 8, 5					| 	|	11	|	| 					22, 34, 12, 28, 21					|
			+-------------------------------------------+	+-------+	+-------------------------------------------------------+
								| 以 5 为基准					|									| 以 21 为基准
				+-----------+---+-----------+					|			+-----------+-----------+-----------+
				|			|				|					|			|			|						|
			+-------+	+-------+	+-------------------+		|		+-------+	+-------+	+-------------------------------+
			|   2	|	|	5	|	| 		10, 8		|		|		|	12	|	|	21	|	|			22, 28, 34 			|
			+-------+	+-------+	+-------------------+		|		+-------+	+-------+	+-------------------------------+
				|			|				| 以 8 为基准		|			|			|						| 以 34 为基准
				|			|			+---+-------+			|			|			|				+-------+-----------+
				|			|			|			|			|			|			|				|					|
				|			|		+-------+	+-------+		|			|			|		+-------------------+	+-------+
				|			|		| 	8	|	|	10	|		|			|			|		|		22, 28		|	|	34	|
				|			|		+-------+	+-------+		|			|			|		+-------------------+	+-------+
				|			|			|			|			|			|			|				| 以 28 为基准		|
				|			|			|			|			|			|			|			+---+-------+			|
				|			|			|			|			|			|			|			|			|			|
				|			|			|			|			|			|			|		+-------+	+-------+		|
				|			|			|			|			|			|			|		|	22	|	|	28	|		|
				|			|			|			|			|			|			|		+-------+	+-------+		|
				|			|			|			|			|			|			|			|			|			|
			+-------------------------------------------------------------------------------------------------------------------+
			|										2, 5, 8, 10, 11, 12, 21, 22, 28, 34											|
			+-------------------------------------------------------------------------------------------------------------------+
		③ 快速排序法应用实例
			A. 要求: 对 [-9, 78, 0, 23, -567, 70] 进行从小到大的排序，要求使用快速排序法。
				a. 如果取消左右递归，结果是  -9 -567 0 23 78 70
				b. 如果取消右递归,结果是  -567 -9 0 23 78 70
				c. 如果取消左递归,结果是  -9 -567 0 23 70 78
			B. 快速排序算法代码实现
				public class QuickSortDemo {

					public static void main(String[] args) {
						// int[] arr = {-9, 78, 0, 23, -567, 70};
						int max = 10000000;
						int[] arr = new int[max];
						for (int i = 0; i < max; i++) {
							arr[i] = (int) (Math.random() * max);
						}
						// System.out.println("排序前：" + Arrays.toString(arr));
						long start = System.currentTimeMillis();
						quickSort(arr, 0, arr.length - 1);
						long end = System.currentTimeMillis();
						System.out.println("总共花费时间：" + (end - start));
						// System.out.println("排序后：" + Arrays.toString(arr));
					}

					public static void quickSort(int[] arr, int left, int right) {
						int l = left, r = right, pivot = arr[(l + r) / 2], temp;
						// while 循环是让小于 pivot 的值放在 pivot 左边，大于 pivot 的值放在 pivot 右边
						while (l < r) {
							// 在 pivot 左边一直找，直到找到大于等于 pivot 的值为止
							while (arr[l] < pivot) {
								l++;
							}
							// 在 pivot 右边一直找，直到找到小于等于 pivot 的值为止
							while (arr[r] > pivot) {
								r--;
							}
							// 如果 l >= r，则数组 arr 已经是 pivot 的左边都小于 pivot，pivot 的右边都大于 pivot
							if (l >= r) {
								break;
							}
							temp = arr[l];
							arr[l] = arr[r];
							arr[r] = temp;

							// 如果交换后，arr[l] == pivot。则 r 前移
							if (arr[l] == pivot) {
								r--;
							}
							// 如果交换后，arr[r] == pivot。则 l 前移
							if (arr[r] == pivot) {
								l++;
							}
						}

						// 如果 l == r，必须 l++，r--
						if (l == r) {
							l++;
							r--;
						}

						// 向左递归
						if (left < r) {
							quickSort(arr, left, r);
						}

						// 向右递归
						if (right > l) {
							quickSort(arr, l, right);
						}
					}
				}
	9. 归并排序
		① 基本介绍：归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分（divide）成一些小的
		问题然后递归求解，而治（conquer）的阶段则将分的阶段得到的各个答案“修补”在一起，即分而治之）
		② 归并排序思想示意图1-基本思想：可以看到这种结构很像一颗完全二叉树，归并排序采用递归实现（也可以采用迭代的方式去实现）。分阶段可以理解为就是递归拆分
		子序列的过程
					+-------------------------------------------------------+
					|				8, 4, 5, 7, 1, 3, 6, 2					|
					+-------------------------------------------------------+
												|
								+---------------+---------------+
								|						 		|
					+-----------------------+		+-----------------------+
					|		8, 4, 5, 7		|		|		1, 3, 6, 2		|
					+-----------------------+		+-----------------------+
			分					|								|
						+-------+-------+				+-------+-------+
						|			 	|				|			 	|
					+--------+	  +---------+		+--------+	  +---------+
					|  8, 4  |	  |   5, 7  |		|  1, 3  |	  |   6, 2  |
					+--------+	  +---------+		+--------+	  +---------+
						|				|				|				|
					 +--+--+		 +--+--+		 +--+--+		 +--+--+		
					 |	   |		 |	   |		 |	   |		 |	   |
					+---++---+	  +---+ +---+		+---++---+	  +---+ +---+	  				
					| 8 || 4 |	  | 5 | | 7 |		| 1 || 3 |	  | 6 | | 2 |
					+---++---+	  +---+ +---+		+---++---+	  +---+ +---+
					 |	   |		 |	   |		 |	   |		 |	   |
					 +--+--+		 +--+--+		 +--+--+		 +--+--+
						|				|				|				|
					+--------+	  +---------+		+--------+	  +---------+
					|  4, 8  |	  |   5, 7  |		|  1, 3  |	  |   2, 6  |
					+--------+	  +---------+		+--------+	  +---------+
						|			 	|				|			 	|
						+-------+-------+				+-------+-------+
			治					|								|
					+-----------------------+		+-----------------------+
					|		4, 5, 7, 8		|		|		1, 2, 3, 6		|
					+-----------------------+		+-----------------------+
								|						 		|
								+---------------+---------------+
												|
					+-------------------------------------------------------+
					|				1, 2, 3, 4, 5, 6, 7, 8					|
					+-------------------------------------------------------+
		③ 归并排序思想示意图2-合并相邻有序子序列：治的阶段，需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4, 5, 7, 8] 和
		[1, 2, 3, 6] 两个已经有序的子序列，合并为最终序列 [1, 2, 3, 4, 5, 6, 7, 8]
			1 < 4，将 1 填入 temp 数组，右移 j
									+-----------------------+
									|						↓
			+---------------+	+---------------+		+-----------------------------------+
			|	4, 5, 7, 8	|	|	1, 2, 3, 6	|		|	1								|
			+---------------+	+---------------+		+-----------------------------------+
				↑					↑  ↑
				| 					|  |
				i					j 右移
			2 < 4，将 2 填入 temp 数组，右移 j
									   +-----------------------+
									   |					   ↓
			+---------------+	+---------------+		+-----------------------------------+
			|	4, 5, 7, 8	|	|	1, 2, 3, 6	|		|	1, 2							|
			+---------------+	+---------------+		+-----------------------------------+
				↑					   ↑  ↑
				| 					   |  |
				i					   j 右移
		④ 归并排序的应用实例:
			A. 一个数组，[8, 4, 5, 7, 1, 3, 6, 2]，使用归并排序完成排序
			B. 归并排序算法代码实现
				public class MergeSortDemo {

					public static void main(String[] args) {
						// int[] arr = {8, 4, 5, 7, 1, 3, 6, 2};
						int max = 10000000;
						int[] arr = new int[max];
						for (int i = 0; i < max; i++) {
							arr[i] = (int) (Math.random() * max);
						}
						// System.out.println("排序前：" + Arrays.toString(arr));
						long start = System.currentTimeMillis();
						mergeSort(arr, 0, arr.length - 1, new int[arr.length]);
						long end = System.currentTimeMillis();
						System.out.println("总共花费时间：" + (end - start));
						// System.out.println("排序后：" + Arrays.toString(arr));
					}

					public static void mergeSort(int[] arr, int left, int right, int[] temp) {
						if (left < right) {
							int mid = (left + right) / 2;
							// 向左递归分
							mergeSort(arr, left, mid, temp);
							// 向右递归分
							mergeSort(arr, mid + 1, right, temp);
							merge(arr, left, mid, right, temp);
						}
					}

					public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
						// i：左边有序序列的初始索引，j：右边有序序列的初始索引
						// 指向 temp 数组的当前索引
						int i = left, j = mid + 1, t = 0;
						// 先把左右两边（有序）的数据按照规则填充到 temp 数组，直到有一边处理完毕为止
						while (i <= mid && j <= right) {
							if (arr[i] <= arr[j]) {
								temp[t++] = arr[i++];
							} else {
								temp[t++] = arr[j++];
							}
						}

						// 把剩余一边的数据依次全部填充到 temp
						while (i <= mid) {
							temp[t++] = arr[i++];
						}
						while (j <= right) {
							temp[t++] = arr[j++];
						}

						// 将 temp 数组的元素拷贝到 arr，注意，并不是每次都拷贝所有
						t = 0;
						int tempLeft = left;
						while (tempLeft <= right) {
							arr[tempLeft++] = temp[t++];
						}
					}
				}
	10. 基数排序（桶排序）
		① 基本介绍
			A. 基数排序（radix sort）属于“分配式排序”（distribution sort），又称为“桶子法”（bucket sort 或 bin sort），顾名思义，它是通过键值的各个位的
			值，将要排序的元素分配至某些“桶”中，达到排序的作用
			B. 基数排序法是属于稳定性的排序，基数排序法是效率高的稳定性排序法
			C. 基数排序（Radix Sort）是桶排序的扩展
			D. 基数排序是 1887 年赫尔曼.何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较
		② 基本思想
			A. 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，
			数列就变成一个有序序列。
			B. 基数排序思想示意图
				a. 将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序。
				b. 第 1 轮排序（按照个位排序）
					(1) 说明：事先准备 10 个数组（10 个桶），0-9 分别对应位数的 0-9
					(2) 将各个数，按照个位大小放入到对应的各个数组中
					(3) 然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出
					(4) 第1轮排序后：542 53 3 14 214 748
					  0		  1		  2		  3		  4		  5		  6		  7		  8		  9
					+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+			
					|	|	|	|	|524|	|53 |	|14	|	|	|	|	|	|	|	|748|	|	|
					|	|	|	|	|	|	|3	|	|214|	|	|	|	|	|	|	|	|	|	|
					|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|
					+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+
				c. 第 2 轮排序（按照十位排序）
					(1) 将各个数，按照十位大小 放入到对应的各个数组中 
					(2) 然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出
					(3) 第2轮排序后： 3 14 214 542 748 53
					  0		  1		  2		  3		  4		  5		  6		  7		  8		  9
					+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+			
					| 3	|	|14	|	|   |	|   |	|542|	|53	|	|	|	|	|	|   |	|	|
					|	|	|214|	|	|	|	|	|748|	|	|	|	|	|	|	|	|	|	|
					|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|
					+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+
				d. 第 3 轮排序（按照百位排序）
					(1) 将各个数，按照百位大小放入到对应的各个数组中 
					(2) 然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出
					(3) 第3轮排序后：3 14 53 214 542 748  
					0		  1		  2		  3		  4		  5		  6		  7		  8		  9
					+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+			
					|3	|	|	|	|214|	|   |	|   |	|542|	|	|	|748|	|   |	|	|
					|14	|	|   |	|	|	|	|	|   |	|	|	|	|	|	|	|	|	|	|
					|53	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|
					+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+	+---+
		③ 基数排序的应用实例
			A. 要求：将数组 {53, 3, 542, 748, 14, 214 } 使用基数排序, 进行升序排序
			B. 基数排序算法代码实现
				public class RadixSortDemo {

					public static void main(String[] args) {
						// int[] arr = {53, 3, 542, 748, 14, 214};

						int max = 10000000;
						int[] arr = new int[max];
						for (int i = 0; i < max; i++) {
							arr[i] = (int) (Math.random() * max);
						}
						// System.out.println("排序前：" + Arrays.toString(arr));
						long start = System.currentTimeMillis();
						radixSort(arr);
						long end = System.currentTimeMillis();
						System.out.println("总共花费时间：" + (end - start));
						// System.out.println("排序后：" + Arrays.toString(arr));
					}

					public static void radixSort(int[] arr) {
						// 定义一个二位数组，表示有 10 个桶，为了防止数组溢出，每个一维数组大小需要定义为 arr.length
						int[][] buckets = new int[10][arr.length];
						// 定义一个一维数组记录各个桶中每次放入数据的个数
						int[] bucketEleCount = new int[10];
						int digitOfEle, index, max = arr[0];
						// 得到数组中最大的数的位数
						for (int i = 1; i < arr.length; i++) {
							max = Math.max(arr[i], max);
						}
						int maxLen = String.valueOf(max).length();
						for (int k = 0, n = 1; k < maxLen; k++, n *= 10) {
							for (int value : arr) {
								// 计算每个元素的位数
								digitOfEle = (value / n) % 10;
								// 将元素放入对应的桶中
								buckets[digitOfEle][bucketEleCount[digitOfEle]] = value;
								bucketEleCount[digitOfEle]++;
							}
							index = 0;
							for (int i = 0; i < bucketEleCount.length; i++) {
								for (int j = 0; j < bucketEleCount[i]; j++) {
									// 顺序将每个桶中的元素放回原数组中
									arr[index++] = buckets[i][j];
								}
								bucketEleCount[i] = 0;
							}
						}
					}
				}
		④ 基数排序的说明：
			A. 基数排序是对传统桶排序的扩展，速度很快
			B. 基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成 OutOfMemoryError
			C. 基数排序是稳定的（注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，
			r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的）
			D. 有负数的数组，不用基数排序来进行排序, 如果要支持负数，参考: https://code.i-harness.com/zh-CN/q/e98fa9
	11. 堆排序--参考数据结构篇堆排序
	13. 常用排序算法总结和对比
		① 常用排序算法对比
			+----------+----------------+-----------+-----------+------------+-----------+--------+
			| 排序算法 | 平均时间复杂度 | 最好情况	| 最坏情况	| 空间复杂度 | 排序方式	 | 稳定性 |
			| 冒泡排序 | O(n^2)			| O(n)		| O(n^2)	| O(1)		 | In-place	 | 稳定	  |
			| 选择排序 | O(n^2)			| O(n^2)	| O(n^2)	| O(1)		 | In-place	 | 不稳定 |
			| 插入排序 | O(n^2)			| O(n)		| O(n^2)	| O(1)		 | In-place	 | 稳定	  |
			| 希尔排序 | O(nlogn)		| O(nlog2n)	| O(nlog2n)	| O(1)		 | In-place	 | 不稳定 |
			| 归并排序 | O(nlogn)		| O(nlogn)	| O(nlogn)	| O(n)		 | Out-place | 稳定	  |
			| 快速排序 | O(nlogn)		| O(nlogn)	| O(n^2)	| O(logn)	 | In-place	 | 不稳定 |
			| 堆排序   | O(nlogn)		| O(nlogn)	| O(nlogn)	| O(1)		 | In-place	 | 不稳定 |
			| 计数排序 | O(n + k)		| O(n + k)	| O(n + k)	| O(k)		 | Out-place | 稳定	  |
			| 桶排序   | O(n + k)		| O(n + k)	| O(n^2)	| O(n + k)	 | Out-place | 稳定	  |
			| 基数排序 | O(n * k)		| O(n * k)	| O(n * k)	| O(n + k)	 | Out-place | 稳定	  |
			+----------+----------------+-----------+-----------+------------+-----------+--------+
		② 相关术语解释：
			A. 稳定：如果 a 原本在 b 前面，而 a = b，排序之后 a 仍然在 b 的前面
			B. 不稳定：如果 a 原本在 b 前面，而 a = b，排序之后 a 可能会出现在 b 的后面
			C. 内排序：所有排序操作都在内存中完成
			D. 外排序：由于数据量太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
			E. 时间复杂度：一个算法执行所耗费的时间
			F. 空间复杂度：运行完一个程序所需内存的大小
			G. n：数据规模
			H. k：“桶”的个数
			I：In-place：不占用额外内存
			G. Out-place：占用额外内存
		③ 常用排序算法处理不同数据量花费时间对比
			+--------------------+----------+-----------+-----------+-----------+
			| 数据量（万）		 | 1		| 10		| 100		| 1000		|
			+--------------------+----------+-----------+-----------+-----------+
			| 冒泡排序			 | 45		| 9992		| ...		| ...		|
			| 选择排序			 | 26		| 2365		| 236758	| ...		|
			| 插入排序			 | 11		| 536		| 51419		| ...		|
			| 希尔排序（交换法） | 80		| 5959		| ...		| ...		|
			| 希尔排序（移动法） | 0		| 16		| 138		| 1690		|
			| 快速排序			 | 1		| 16		| 102		| 992		|
			| 归并排序			 | 0		| 12		| 105		| 1173		|
			| 基数排序（桶排序） | 0		| 16		| 44		| 326		|
			| 堆排序			 | 3		| 12		| 88		| 1696		|
			+--------------------+----------+-----------+-----------+-----------+
二、查找算法
	1. 查找算法介绍
		① 在 Java 中，常用的查找算法有四种
			A. 顺序（线性）查找
			B. 二分查找/折半查找
			C. 插值查找
			D. 斐波那契查找
	2. 线性查找算法
		① 有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此名称顺序查找，要求: 如果找到了，就提示找到，并给出下标值。
		② 代码实现
			public class OrderSearchDemo {

				public static void main(String[] args) {
					int[] arr = {1, 8, 10, 89, 1000, 1234};
					System.out.println(orderSearch(arr, 1));
				}

				public static int orderSearch(int[] arr, int value) {
					for (int i = 0; i < arr.length; i++) {
						if (arr[i] == value) {
							return i;
						}
					}
					return -1;
				}
			}
	3. 二分查找算法
		① 应用实例：请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标
		② 代码实现
			public class BinarySearchDemo {

				public static void main(String[] args) {
					int[] arr = {1, 8, 10, 89, 1000, 1000, 1234};
					int index = binarySearch(arr, 0, arr.length - 1, 1);
					System.out.println(index);
				}

				public static int binarySearch(int[] arr, int left, int right, int value) {
					if (left > right) {
						return -1;
					}
					int mid = left + (right - left) / 2;
					if (value == arr[mid]) {
						return mid;
					} else if (value < arr[mid]) {
						return binarySearch(arr, left, mid - 1, value);
					} else {
						return binarySearch(arr, mid + 1, right, value);
					}
				}
			}
		③ 课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000
		④ 代码实现
			public static int[] binarySearchAll(int[] arr, int left, int right, int value) {
				if (left > right) {
					return null;
				}
				int mid = left + (right - left) / 2;
				if (value == arr[mid]) {
					int[] indexes = new int[arr.length];
					int temp = mid - 1, index = 0;
					while (temp > 0 && arr[temp] == value) {
						indexes[index++] = temp--;
					}
					indexes[index++] = mid;
					temp = mid + 1;
					while (temp < arr.length && arr[temp] == value) {
						indexes[index++] = temp++;
					}
					return Arrays.copyOfRange(indexes, 0, index);
				} else if (value < arr[mid]) {
					return binarySearchAll(arr, left, mid - 1, value);
				} else {
					return binarySearchAll(arr, mid + 1, right, value);
				}
			}
	4. 插值查找算法
		① 原理介绍
			A. 插值查找算法类似于二分查找，不同的是插值查找每次自适应 mid 处开始查找
			B. 将折半查找中的求 mid 索引的公式，low 表示左边索引 left，high 表示右边索引 right，key 代表要查找的值
						low + high				high - low		  改成						key - a[low]
				mid = --------------- = low + -------------- 	=======> 	mid = low + --------------------(high - low)
							2						2									  a[high] - a[low]
			C. int midIndex = low + (high - low) * (key - a[low]) / a[high] - a[low]
			D. 举例说明插值查找算法 1-100 的数组
		② 代码实现
			public class InsertValueSearchDemo {

				public static void main(String[] args) {
					int[] arr = new int[100];
					for (int i = 1; i <= 100; i++) {
						arr[i - 1] = i;
					}

					int index = insertValueSearch(arr, 0, arr.length - 1, 26);
					System.out.println(index);
				}

				public static int insertValueSearch(int[] arr, int left, int right, int value) {
					System.out.println("hello");
					if (left > right || value < arr[left] || value > arr[right]) {
						return -1;
					}

					int mid = left + (right - left) * (value - arr[left]) / (arr[right] - arr[left]);
					if (value == arr[mid]) {
						return mid;
					} else if (value < arr[mid]) {
						return insertValueSearch(arr, left, mid - 1, value);
					} else {
						return insertValueSearch(arr, mid + 1, right, value);
					}
				}
			}
		③ 插值查找算法注意事项
			A. 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快
			B. 关键字分布不均匀，该方法不一定比折半查找要好
	5. 斐波那契（黄金分割法）查找算法
		① 基本介绍
			A. 黄金分割点是指把一条线段分割成为两部分，使其中一部分与全长之比等于另外一部分与这部分之比。取其前三位数字的近似值是 0.618。由于按此比例设计
			的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意想不到的效果
			B. 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55} 发现斐波那契数列的两个相邻的比例，无限接近黄金分割值 0.618
		② 斐波那契（黄金分割法）原理：
			A. 斐波那契查找原理与前两种相似，仅仅改变了中间节点（mid）的位置，mid 不再是中间或者插值得到，而是位于黄金分割点附近，
			即 mid = low + F(k - 1) - 1（F 代表斐波那契数列），如下图所示
								 F(k) - 1
				+--------------------+----------------------+
				↓											↓										
				+-----+-------------+-----+----------+------+
				| low |				| mid |			 | high |
				+-----+-------------+-----+----------+------+
				↑					↑	  ↑					↑
				+---------+---------+	  +--------+--------+
					F(k - 1) - 1			  F(k - 2) - 1
			B. 对 F(k - 1) - 1 的理解
				a. 由斐波那契数列 F(k) = F(k - 1) + F(k - 2) 的性质，可以得到 F(k - 1) - 1 = (F(k) - 1) + (F(k - 2) - 1) + 1。该式说明：只要顺序表的长度
				为 F(k) - 1，则可以将该表分成长度为 F(k - 1) - 1 和 F(k - 2) - 1 的两段，即如上图所示。从而中间位置为 mid = low + F(k - 1) - 1
				b. 类似的，每一子段也可以用相同的方式分割
				c. 但顺序表长度 n 不一定刚好等于 F(k) - 1，所以需要将原来的顺序表长度 n 增加至 F(k) - 1。这里的 k 值只要能使得 F(k) - 1 恰好大于或等于 n 
				即可，由以下代码得到，顺序表长度增加后，新增的位置（从 n + 1 到 F(k) - 1位置），都赋为 n 位置的值即可
			C. 斐波那契查找应用案例
				a. 对一个有序数组进行斐波那契查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标
				b. 代码实现
					public class FibonacciSearchDemo {

						public static void main(String[] args) {
							int[] arr = {1, 8, 10, 89, 1000, 1234};
							System.out.println(fibonacciSearch(arr, 1234));
						}

						public static int[] fibonacci(int len) {
							int[] fibonacci = new int[len];
							fibonacci[0] = 1;
							fibonacci[1] = 1;
							int i;
							for (i = 2; i < len; i++) {
								fibonacci[i] = fibonacci[i - 2] + fibonacci[i - 1];
								if (fibonacci[i] >= len) {
									break;
								}
							}
							return Arrays.copyOfRange(fibonacci, 0, i + 1);
						}

						public static int fibonacciSearch(int[] arr, int value) {
							int[] fibonacci = fibonacci(arr.length);
							int low = 0, high = arr.length - 1, k = fibonacci.length - 1, mid;
							int[] temp = Arrays.copyOf(arr, fibonacci[k]);
							for (int i = high + 1; i < fibonacci[k]; i++) {
								temp[i] = arr[high];
							}

							while (low <= high) {
								mid = fibonacci[k - 1] - 1 + low;
								if (value == temp[mid]) {
									return Math.min(mid, high);
								} else if (value < temp[mid]) {
									high = mid - 1;
									k -= 1;
								} else {
									low = mid + 1;
									k -= 2;
								}
							}

							return -1;
						}
					}
三、常用10种算法
	1. 二分查找算法(非递归)
		① 二分查找算法(非递归)介绍
			A. 前面的二分查找算法，是使用递归的方式，下面的二分查找算法是非递归方式
			B. 二分查找法只适用于从有序的数列中进行查找（比如数字和字母等），将数列排序后再进行查找
			C. 二分查找法的运行时间为对数时间 O(㏒₂n) ，即查找到需要的目标位置最多只需要 ㏒₂n 步，假设从 [0,99] 的队列（100 个数，即 n=100）中寻到目标数 30，
			则需要查找步数为 ㏒₂100 , 即最多需要查找 7 次（2^6 < 100 < 2^7）
		② 二分查找算法（非递归）代码实现
			A. 数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找，要求使用非递归的方式完成
			B. 代码实现
				public class BinarySearchNoRecursionDemo {
					public static void main(String[] args) {
						int[] arr = {1, 3, 8, 10, 11, 67, 100};
						int index = search(arr, 67);
						System.out.println(index);
					}

					public static int search(int[] arr, int value) {
						int l = 0, r = arr.length - 1, mid;
						while (l <= r) {
							mid = (l + r) / 2;
							if (value == arr[mid]) {
								return mid;
							} else if (value < arr[mid]) {
								r = mid - 1;
							} else {
								l = mid + 1;
							}
						}

						return -1;
					}
				}
	2. 分治算法
		① 分治算法介绍
			A. 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……
			直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换（
			快速傅立叶变换）……
			B. 分治算法可以求解的一些经典问题
				a. 二分搜索
				b. 大整数乘法
				c. 棋盘覆盖
				d. 合并排序
				e. 快速排序
				f. 线性时间选择
				g. 最接近点对问题
				h. 循环赛日程表
				i. 汉诺塔
		② 分治算法的基本步骤：分治法在每一层递归上都有三个步骤
			A. 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
			B. 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
			C. 合并：将各个子问题的解合并为原问题的解。
		③ 分治（Divide-and-Conquer(P)）算法设计模式如下
			if |P|≤n0
			   then return(ADHOC(P))
			//将P分解为较小的子问题 P1 ,P2 ,…,Pk
			for i←1 to k
			do yi ← Divide-and-Conquer(Pi)   递归解决Pi
			T ← MERGE(y1,y2,…,yk)   合并子问题
			return(T)
			其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，
			用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1,
			P2,…,Pk的相应的解y1,y2,…,yk合并为P的解。
		④ 分治算法最佳实践-汉诺塔
			A. 汉诺塔游戏的思路分析:
				a. 如果是有一个盘， A->C
				b. 如果我们有 n >= 2 情况，可以看做是两个盘，最下边的盘和上面的盘
					(1) 先把 最上面的盘 A->B
					(2) 把最下边的盘 A->C
					(3) 把B塔的所有盘 从 B->C   
			B. 代码实现
				public class HanoitowerDemo {

					public static void main(String[] args) {
						hanoitower(64, 'A', 'B', 'C');
					}

					public static void hanoitower(int num, char a, char b, char c) {
						if (num == 1) {
							System.out.println(a + "->" + c);
						} else {
							// 把a上面所有的盘从 a 移动到 b 借助 c
							hanoitower(num - 1, a, c, b);
							// 把最下面的盘从 a 移动到 c
							System.out.println(a + "->" + c);
							// 把b所有的盘从 b 移动到 c 借助 a
							hanoitower(num - 1, b, a, c);
						}
					}
				}
	3. 动态规划算法
		① 应用场景-背包问题
			A. 背包问题：有一个背包，容量为4磅，现有如下物品
				+-----------+------+------+
				| 物品		| 重量 | 价格 |
				+-----------+------+------+
				| 吉他（G） | 1	   | 1500 |
				| 音响（S） | 4	   | 3000 |
				| 电脑（L） | 3	   | 2000 |
				+-----------+------+------+
			B. 要求
				a. 达到的目标为装入的背包的总价值最大，并且重量不超出
				b. 要求装入的物品不能重复
		② 动态规划算法介绍
			A. 动态规划（Dynamic Programming）算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法
			B. 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。
			C. 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。（即下一个子阶段的求解是建立在上一个子阶段
			的解的基础上，进行进一步的求解）
			D. 动态规划可以通过填表的方式来逐步推进，得到最优解
		③ 动态规划算法最佳实践-背包问题
			A. 思路分析和图解
				a. 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和
				完全背包（完全背包指的是：每种物品都有无限件可用）
				b. 这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。
				c. 算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的 n
				个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。
				则我们有下面的结果：
					(1) v[i][0]=v[0][j]=0，表示填入表的第一行和第一列是 0
					(2) 当 w[i] > j 时：v[i][j]=v[i-1][j]，当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略
					(3) 当j >= w[i] 时：v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}：当 准备加入的新增的商品的容量小于等于当前背包的容量，装入
					的方式：v[i-1][j]：当前商品没装进背包的最大值，v[i]：表示当前商品的价值，装入i-1商品，到剩余空间j-w[i]的最大值
					+---------------+---+-----------+-----------+-----------+-----------------------+
					| 物品|背包容量 | 0 | 1 		| 2			| 3			| 4						|
					+---------------+---+-----------+-----------+-----------+-----------------------+
					|				| 0 | 0			| 0			| 0			| 0						|
					| 吉他（G）		| 0 | 1500（G）	| 1500（G）	| 1500（G）	| 1500（G）				|
					| 音响（S）		| 0 | 1500（G）	| 1500（G）	| 1500（G）	| 3000（S）				|
					| 电脑（L）		| 0 | 1500（G）	| 1500（G）	| 2000（L）	| 1500（G）+ 2000（L）	|
					+---------------+---+-----------+-----------+-----------+-----------------------+
			B. 代码实现
				public class KnapsackProblemDemo {

					public static void main(String[] args) {
						// 物品的重量
						int[] w = {1, 4, 3};
						// 物品的价值
						int[] val = {1500, 3000, 2000};
						// 物品的个数
						int n = w.length;
						// 背包的容量
						int m = 4;
						// 保存物品的存放记录
						int[][] path = new int[n + 1][m + 1];
						// 创建二维数组，横坐标表示放置的物品，纵坐标表示背包的容量
						int[][] v = new int[n + 1][m + 1];
						
						// 初始化第一行
						for (int i = 0; i <= m; i++) {
							v[0][i] = 0;
						}
						// 初始化第一列
						for (int i = 0; i <= n; i++) {
							v[i][0] = 0;
						}

						// 动态规划
						for (int i = 1; i <= n; i++) {
							// 不处理第一行
							for (int j = 1; j <= m; j++) {
								// 不处理第一列
								if (w[i - 1] > j) {
									v[i][j] = v[i - 1][j];
								} else {
									// v[i][j] = Math.max(v[i - 1][j], val[i -1 ] + v[i - 1][j - w[i - 1]]);
									if (v[i - 1][j] > val[i -1 ] + v[i - 1][j - w[i - 1]]) {
										v[i][j] = v[i - 1][j];
									} else {
										v[i][j] = val[i -1 ] + v[i - 1][j - w[i - 1]];
										path[i][j] = 1;
									}
								}
							}
						}

						// 打印数组
						for (int i = 0; i <= n; i++) {
							System.out.println(Arrays.toString(v[i]));
						}

						int i = n, j = m;
						while (i > 0 && j > 0) {
							if (path[i][j] > 0) {
								System.out.printf("第%d个产品放入背包\n", i);
								j = j - w[i - 1];
							}
							i--;
						}
					}
				}
	4. KMP算法
		① 暴力匹配算法
			A. 如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有:
			B. 如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符
			C. 如果失配（即 str1[i]! = str2[j]），令 i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0。
			D. 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。（不可行!）
			E. 暴力匹配算法实现
				public class KMPDemo {

					public static void main(String[] args) {
						String str1 = "BBC ABCDAB ABCDABCDABDE";
						String str2 = "ABCDABD";
						int index = violenceMatch(str1, str2);
						System.out.println(index);
					}

					/**
					 * 暴力匹配
					 */
					public static int violenceMatch(String str1, String str2) {
						char[] c1 = str1.toCharArray();
						char[] c2 = str2.toCharArray();
						int len1 = c1.length;
						int len2 = c2.length;
						int i = 0, j = 0;
						while (i < len1 && j < len2) {
							if (c1[i] == c2[j]) {
								i++;
								j++;
							} else {
								i = i - (j - 1);
								j = 0;
							}
						}

						if (j == len2) {
							return i - j;
						} else {
							return -1;
						}
					}
				}
		② KMP算法介绍
			A. KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法
			B. Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、
			Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法
			C. KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的
			位置，省去了大量的计算时间
			D. 参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html 
		③ KMP算法最佳应用-字符串匹配问题
			A. 字符串匹配问题：
				a. 有一个字符串 str1 = "BBC ABCDAB ABCDABCDABDE"，和一个子串 str2="ABCDABD"
				b. 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回 -1
				c. 要求：使用KMP算法完成判断，不能使用简单的暴力匹配算法
			B. 思路分析图解
				a. 举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”？ 
				b. 首先，用Str1的第一个字符和Str2的第一个字符去比较，不符合，关键词向后移动一位
					+-+
					|B|BC ABCDAB ABCDABCDABDE
					|A|BCDABD
					+-+
				c. 重复第一步，还是不符合，再后移
					 +-+
					B|B|C ABCDAB ABCDABCDABDE
					 |A|BCDABD
					 +-+
				d. 一直重复，直到Str1有一个字符与Str2的第一个字符符合为止
						+-+
					BBC |A|BCDAB ABCDABCDABDE
					    |A|BCDABD
						+-+
				e. 接着比较字符串和搜索词的下一个字符，还是符合
						 +-+
					BBC A|B|CDAB ABCDABCDABDE
					    A|B|CDABD
						 +-+
				f. 遇到Str1有一个字符与Str2对应的字符不符合。
							  +-+
					BBC ABCDAB| |ABCDABCDABDE
					    ABCDAB|D|
							  +-+
				g. 这时候，想到的是继续遍历Str1的下一个字符，重复第1步。(其实是很不明智的，因为此时BCD已经比较过了，没有必要再做重复的工作，一个基本事
				实是，当空格与D不匹配时，实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，
				继续把它向后移，这样就提高了效率。)
						 +-+
					BBC A|B|CDAB ABCDABCDABDE
					     |A|CDABD
						 +-+
				h. 怎么做到把刚刚重复的步骤省略掉？可以对Str2计算出一张《部分匹配表》
					+------------+---+---+---+---+---+---+---+
					| 搜索词	 | A | B | C | D | A | B | D |
					+------------+---+---+---+---+---+---+---+
					| 部分匹配值 | 0 | 0 | 0 | 0 | 1 | 2 | 0 |
					+------------+---+---+---+---+---+---+---+
				i. 已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动
				的位数：移动位数 = 已匹配的字符数 - 对应的部分匹配值。因为 6 - 2 等于4，所以将搜索词向后移动 4 位。
				j. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，
				于是将搜索词向后移 2 位。
							  +-+
					BBC ABCDAB| |ABCDABCDABDE
							AB|C|DABD
							  +-+
				k. 因为空格与A不匹配，继续后移一位。
							  +-+
					BBC ABCDAB| |ABCDABCDABDE
					          |A|BCDABD
							  +-+
				l. 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。
									 +-+
					BBC ABCDAB ABCDAB|C|DABDE
							   ABCDAB|D|
									 +-+
				m. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动 7 位
										 +-+
					BBC ABCDAB ABCDABCDAB|D|E
					               ABCDAB|D|
										 +-+
				n. 《部分匹配表》介绍
					(1) 前缀，后缀介绍
						字符串：“bread”
						前缀：b br bre brea
						后缀：read ead ad d
					(2) “部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，
						”A”的前缀和后缀都为空集，共有元素的长度为0；
						”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；
						”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；
						”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；
						”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；
						”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； 
						ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。
				o. ”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，
				第一个”AB”向后移动 4 位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。字符串长度-部分匹配值），就可以来到第二个”AB”的位置。
			C. 代码实现
				public class KMPDemo {

					public static void main(String[] args) {
						String str1 = "BBC ABCDAB ABCDABCDABDE";
						String str2 =                "ABCDABD";
						
						// ...

						int[] next = knpNext(str2);
						System.out.println(Arrays.toString(next));
						int inddex2 = kmpSearch(str1, str2, next);
						System.out.println(inddex2);
					}
					
					// ...

					public static int kmpSearch(String str1, String str2, int[] next) {
						for (int i = 0, j = 0; i < str1.length(); i++) {
							while (j > 0 && str1.charAt(i) != str2.charAt(j)) {
								j = next[j - 1];
							}

							if (str1.charAt(i) == str2.charAt(j)) {
								j++;
							}

							if (j == str2.length()) {
								return i - j + 1;
							}
						}

						return -1;
					}

					public static int[] knpNext(String dest) {
						int[] next = new int[dest.length()];

						for (int i = 1, j = 0; i < dest.length(); i++) {
							while (j > 0 && dest.charAt(i) != dest.charAt(j)) {
								j = next[j - 1];
							}
							if (dest.charAt(i) == dest.charAt(j)) {
								j++;
							}
							next[i] = j;
						}

						return next;
					}
	5. 贪心算法
		① 应用场景-集合覆盖问题
			假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号
			广播台		覆盖地区
			K1			北京、上海、天津
			K2			广州、北京、深圳
			K3			成都、上海、杭州
			K4			上海、天津
			K5			杭州、大连 
		② 贪心算法介绍
			A. 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法
			B. 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果
		③ 思路分析
			A. 穷举法实现
			B. 使用贪婪算法，效率高：目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要
			覆盖全部地区的最小集合:
				a. 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） 
				b. 将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。
				c. 重复第1步直到覆盖了全部的地区
		④ 代码实现
			public class GreedyDemo {

				public static void main(String[] args) {
					Map<String, Set<String>> broadCasts = new HashMap<>();

					Set<String> set1 = new HashSet<>();
					set1.add("北京");
					set1.add("上海");
					set1.add("天津");

					Set<String> set2 = new HashSet<>();
					set2.add("广州");
					set2.add("北京");
					set2.add("深圳");

					Set<String> set3 = new HashSet<>();
					set3.add("成都");
					set3.add("上海");
					set3.add("杭州");

					Set<String> set4 = new HashSet<>();
					set4.add("上海");
					set4.add("天津");

					Set<String> set5 = new HashSet<>();
					set5.add("杭州");
					set5.add("大连");

					broadCasts.put("k1", set1);
					broadCasts.put("k2", set2);
					broadCasts.put("k3", set3);
					broadCasts.put("k4", set4);
					broadCasts.put("k5", set5);

					List<String> select = greedy(broadCasts);
					System.out.println(select);
				}

				public static List<String> greedy(Map<String, Set<String>> broadCasts) {
					// 获取所有地区
					Set<String> allAreas = broadCasts.entrySet().stream().flatMap(entry -> entry.getValue().stream()).collect(Collectors.toSet());
					// 存储电台
					List<String> select = new ArrayList<>();
					// 指向最多未覆盖地区的电台
					String maxKey;
					// 存放未覆盖地区
					Set<String> maxSet;
					// 临时集合，存放电台覆盖地区和还没有覆盖地区的交集
					Set<String> tempSet;
					while (!allAreas.isEmpty()) {
						maxKey = null;
						maxSet = null;
						for (Map.Entry<String, Set<String>> entry : broadCasts.entrySet()) {
							// 当前电台能覆盖的地区
							tempSet = new HashSet<>(entry.getValue());
							// 求 tempSet 和 allAreas 的交集，并赋给 tempSet
							tempSet.retainAll(allAreas);
							// 如果当前电台对应未覆盖地区，比 maxKey 对应的未覆盖地区多，则重置 maxKey 和 maxSet
							if (tempSet.size() > 0 && (maxKey == null || tempSet.size() > maxSet.size())) {
								maxKey = entry.getKey();
								maxSet = tempSet;
							}
						}
						if (maxKey != null) {
							select.add(maxKey);
							// 将 maxKey 对应的电台覆盖的地区，从 allAreas 中去除
							allAreas.removeAll(broadCasts.get(maxKey));
						}
					}

					return select;
				}
			}
	6. 普里姆算法
		① 应用场景-修路问题
			+---+	7	+---+	5	+---+
			| C |-------| A |-------| B |-------+
			+---+		+---+		+---+		|
			  |			  |			  |			|
			  |			  |			  |			|
			8 |			  |	2		  |	3		| 9
			  |			  |			  |			|
			+---+	4	+---+		  |			|
			| E |-------| G |---------+			|
			+---+		+---+					|
			  |			  |						|
			  |			  |						|
			5 |			  |	6					|
			  |			  |						|
			  |			+---+		 +---+		|
			  +---------| F |--------| D |------+
						+---+	4	 +---+
			A. 有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通
			B. 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
			C. 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短
			D. 思路: 将10条边，连接即可，但是总的里程数不是最小
			E. 正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少
		② 最小生成树
			A. 修路问题本质就是就是最小生成树问题，最小生成树(Minimum Cost Spanning Tree)，简称MST。
			B. 给定一个带权的无向连通图,如何选取一棵生成树，使树上所有边上权的总和为最小,这叫最小生成树 
			C. N个顶点，一定有N-1条边
			D. 包含全部顶点
			E. N-1条边都在图中
			F. 举例说明(如图)
													+---+
													| A |
													+---+
													  |
											+---------+---------+
											|		  |			|
										  +---+		  |		  +---+
										  | B |-------+-------| C |
										  +---+		  |		  +---+
											|		  |			|
											+---------+---------+
													  |
													+---+
													| D |
													+---+
				+---+			  +---+		+---+			  +---+					+---+
				| A |-------------| B |		| A |-------------| B |					| A |
				+---+			  +---+		+---+			  +---+					+---+
				  |					|							|				  	  |
				+---+			  +---+		+---+			  +---+			+---------+---------+
				| C |			  |D |		| C |-------------| D |			|		  |			|
				+---+			  +---+		+---+			  +---+	  	  +---+		+---+	  +---+
																		  | B |		| C |	  | B |
																		  +---+		+---+	  +---+
			G. 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法
		③ 普里姆算法介绍
			A. 普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图
			B. 普利姆的算法如下
				a. 设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 
				b. 若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点u的visited[u]=1
				c. 若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，
				标记visited[vj]=1
				d. 重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边
			C. 图解
				a. 从<A>顶点开始处理，<A,B>=5 <A,C>=7 <A,G>=2，得到边<A,G>=2，顶点<A,G>
				b. 从<A,G>顶点开始，将A和G顶点和他们相邻还没有访问的顶点进行处理 <A,B>=5 <A,C>=7 <G,B>=3 <G,E>=4 <G,F>=6，得到边<G,B>=3，顶点<A,G,B>
				c. 从<A,G,B>顶点开始，<A,C>=7 <G,E>=4 <G,F>=6 <B,D>=9，得到边<G,E>=4，顶点 <A,G,B,E>
				d. 从<A,G,B,E>顶点开始，<A,C>=7 <G,F>=6 <B,D>=9 <E,C>=8 <E,F>=5，得到边<E,F>=5，顶点 <A,G,B,E,F>
				E. 从<A,G,B,E,F>顶点开始，<A,C>=7 <B,D>=9 <E,C>=8 <F,D>=4，得到边<F,D>=4，顶点 <A,G,B,E,F,D>
				F. 从<A,G,B,E,F,D>顶点开始，<A,C>=7 <E,C>=8，得到边<A,C>=7，顶点 <A,G,B,E,F,D,C>
		④ 代码实现
			public class Graph {

				private final char[] vertexes;

				private final int[][] edges;

				private Integer numOfVertex;

				private Integer numOfEdge;

				public Graph(int n) {
					this.vertexes = new char[n];
					this.edges = new int[n][n];
					for (int i = 0; i < n; i++) {
						for (int j = 0; j < n; j++) {
							edges[i][j] = 10000;
						}
					}
					numOfVertex = 0;
					numOfEdge = 0;
				}

				public void show() {
					for (int i = 0; i < this.numOfVertex; i++) {
						System.out.println(Arrays.toString(this.edges[i]));
					}
				}

				public void addVertex(char c) {
					this.vertexes[this.numOfVertex++] = c;
				}

				public void addEdge(int v1, int v2, int weight) {
					edges[v1][v2] = weight;
					edges[v2][v1] = weight;
					if (v1 != v2) {
						this.numOfEdge++;
					}
				}

				public char[] getVertexes() {
					return this.vertexes;
				}

				public int[][] getEdges() {
					return this.edges;
				}

				public Integer getNumOfVertex() {
					return this.numOfVertex;
				}
				
				public Integer getNumOfEdge() {
					return this.numOfEdge;
				}
			}
			
			public class PrimDemo {

				public static void main(String[] args) {
					char[] data = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
					Graph graph = new Graph(data.length);
					for (char c : data) {
						graph.addVertex(c);
					}

					graph.addEdge(0, 1, 5);
					graph.addEdge(0, 2, 7);
					graph.addEdge(0, 6, 2);
					graph.addEdge(1, 3, 9);
					graph.addEdge(1, 6, 3);
					graph.addEdge(2, 4, 8);
					graph.addEdge(3, 5, 4);
					graph.addEdge(4, 5, 5);
					graph.addEdge(4, 6, 4);
					graph.addEdge(5, 6, 6);

					graph.show();
					prim(graph, 0);
				}

				public static void prim(Graph graph, int v) {
					int[][] edges = graph.getEdges();
					char[] vertexes = graph.getVertexes();
					int numOfVertex = graph.getNumOfVertex();
					// 记录顶点是否已经被访问过
					int[] isVisited = new int[numOfVertex];
					// 将当前顶点设置为已访问
					isVisited[v] = 1;
					// 记录最小边的两个顶点
					int h1 = -1, h2 = -1, minWeight;
					for (int k = 1; k < numOfVertex; k++) {
						// prim 算法结束后，会产生 numOfVertex - 1 条边
						minWeight = Integer.MAX_VALUE;
						for (int i = 0; i < numOfVertex; i++) {
							// 遍历已经访问过的顶点
							for (int j = 0; j < numOfVertex; j++) {
								// 遍历还没有访问过的顶点
								if (isVisited[i] == 1 && isVisited[j] == 0 && minWeight > edges[i][j]) {
									// 如果还没有访问过的边的权值小于 minWeight，则替换 minWeight
									h1 = i;
									h2 = j;
									minWeight = edges[i][j];
								}
							}
						}
						System.out.println("边<" + vertexes[h1] + ", " + vertexes[h2] + ">=" + minWeight);
						isVisited[h2] = 1;
					}
				}
			}
	7. 克鲁斯卡尔算法
		① 应用场景-公交站问题
														  +-----------------+
														  |					|
						+---+	  12	+---+	 10		+---+				|
				+-------| A |-----------| B |-----------| C |-------+		|
				|		+---+			+---+			+---+		|		|
				|		  |				7 |				  |			|		|
				|		  |				  |				  |			|		|
			 14	|	   16 |				+---+			6 |		  3	|	  5	|
				|		  +-----+-------| F |-------------+			|		|
				|				|		+---+						|		|
				|		  +-----+		  |							|		|
				|		9 |				2 |							|		|
				|		+---+	 8		+---+	 4		+---+		|		|
				+-------| G |-----------| E |-----------| D |-------+		|
						+---+			+---+			+---+				|
										  |									|
										  +---------------------------------+
			A. 某城市新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通
			B. 各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里
			C. 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短
		② 克鲁斯卡尔算法介绍
			A. 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法
			B. 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路
			C. 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止
		③ 图解说明
			A. 图解
				a. 将边<E,F>加入R中。边<E,F>的权值最小，因此将它加入到最小生成树结果R中
					+---+			+---+			+---+
					| A |			| B |			| C |
					+---+			+---+			+---+
					
					
									+---+
									| F |
									+---+
									  |
									  | 2
					+---+			+---+			+---+
					| G |			| E |			| D |
					+---+			+---+			+---+
				b. 将边<C,D>加入R中。上一步操作之后，边<C,D>的权值最小，因此将它加入到最小生成树结果R
					+---+			+---+			+---+
					| A |			| B |			| C |
					+---+			+---+			+---+
													  |
													  |
									+---+			  |
									| F |			  | 3
									+---+			  |
									  | 2			  |
									  |				  |
					+---+			+---+			+---+
					| G |			| E |			| D |
					+---+			+---+			+---+
				c. 将边<D,E>加入R中
					+---+			+---+			+---+
					| A |			| B |			| C |
					+---+			+---+			+---+
													  |
													  |
									+---+			  |
									| F |			  | 3
									+---+			  |
									  | 2			  |
									  |				  |
					+---+			+---+	  4		+---+
					| G |			| E |-----------| D |
					+---+			+---+			+---+
				d. 将边<B,F>加入R中
					+---+			+---+			+---+
					| A |			| B |			| C |
					+---+			+---+			+---+
									  |	7			  |
									  |				  |
									+---+			  |
									| F |			  | 3
									+---+			  |
									  | 2			  |
									  |				  |
					+---+			+---+	  4		+---+
					| G |			| E |-----------| D |
					+---+			+---+			+---+
				e. 将边<E,G>加入R中
					+---+			+---+			+---+
					| A |			| B |			| C |
					+---+			+---+			+---+
									  |	7			  |
									  |				  |
									+---+			  |
									| F |			  | 3
									+---+			  |
									  | 2			  |
									  |				  |
					+---+	  8		+---+	  4		+---+
					| G |-----------| E |-----------| D |
					+---+			+---+			+---+
				f. 将边<A,B>加入R中，上一步操作之后，边<F,G>的权值最小，但<F,G>会和已有的边构成回路；因此，跳过边<F,G>。同理，跳过边<B,C>。
				将边<A,B>加入到最小生成树结果R中。
					+---+	 12		+---+			+---+
					| A |-----------| B |			| C |
					+---+			+---+			+---+
									  |	7			  |
									  |				  |
									+---+			  |
									| F |			  | 3
									+---+			  |
									  | 2			  |
									  |				  |
					+---+	  8		+---+	  4		+---+
					| G |-----------| E |-----------| D |
					+---+			+---+			+---+
			B. 分析
				a. 根据前面介绍的克鲁斯卡尔算法的基本思想和做法，能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：
					(1) 问题一：对图的所有边按照权值大小进行排序。
					(2) 问题二：将边添加到最小生成树中时，怎么样判断是否形成了回路
				b. 问题一，采用排序算法进行排序即可
				c. 问题二，处理方式是：记录顶点在"最小生成树"中的终点，顶点的终点是"在最小生成树中与它连通的最大顶点"。然后每次需要将一条边添加到最小生存树时，
				判断该边的两个顶点的终点是否重合，重合的话则会构成回路
			C. 如何判断是否构成回路-举例说明
				+---+			+---+			+---+
				| A |			| B |			| C |-------+
				+---+			+---+			+---+		|
												  |			|
												  |			|
								+---+			  |			|
								| F |			  | 3		|
								+---+			  |			|
								  | 2			  |			|
								  |				  |			|
				+---+			+---+	  4		+---+		|
				| G |			| E |-----------| D |		|
				+---+			+---+			+---+		|
								  |							|
								  +-------------------------+
				a. 在将<E,F> <C,D> <D,E>加入到最小生成树R中之后，这几条边的顶点就都有了终点：
					(1) C的终点是F
					(2) D的终点是F
					(3) E的终点是F
					(4) F的终点是F
				b. 关于终点的说明
					(1) 就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是"与它连通的最大顶点"
					(2) 因此，接下来，虽然<C,E>是权值最小的边。但是C和E的终点都是F，即它们的终点相同，因此，将<C,E>加入最小生成树的话，会形成回路。
					这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。
		④ 代码实现
			public class Edge {

				private final char start;

				private final char end;

				private final int weight;

				public Edge(char start, char end, int weight) {
					this.start = start;
					this.end = end;
					this.weight = weight;
				}

				public char getStart() {
					return start;
				}

				public char getEnd() {
					return end;
				}

				public int getWeight() {
					return weight;
				}

				@Override
				public String toString() {
					return "Edge{" +
							"start=" + start +
							", end=" + end +
							", weight=" + weight +
							'}';
				}
			}
			
			public class KruskalDemo {

				private static final int INF = 10000;
				public static void main(String[] args) {
					//                  0    1    2    3    4    5    6
					char[] vertexes = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
					Graph graph = new Graph(vertexes.length);
					for (char vertex : vertexes) {
						graph.addVertex(vertex);
					}

					graph.addEdge(0, 0, 0);
					graph.addEdge(0, 1, 12);
					graph.addEdge(0, 5, 16);
					graph.addEdge(0, 6, 14);
					graph.addEdge(1, 1, 0);
					graph.addEdge(1, 2, 10);
					graph.addEdge(1, 5, 7);
					graph.addEdge(2, 2, 0);
					graph.addEdge(2, 3, 3);
					graph.addEdge(2, 4, 5);
					graph.addEdge(2, 5, 6);
					graph.addEdge(3, 3, 0);
					graph.addEdge(3, 4, 4);
					graph.addEdge(4, 4, 0);
					graph.addEdge(4, 5, 2);
					graph.addEdge(4, 6, 8);
					graph.addEdge(5, 5, 0);
					graph.addEdge(5, 6, 9);
					graph.addEdge(6, 6, 0);

					graph.show();
					Edge[] edges = kruskal(graph);
					System.out.println(Arrays.toString(edges));
				}

				private static Edge[] kruskal(Graph graph) {
					int[][] matrix = graph.getEdges();
					char[] vertexes = graph.getVertexes();
					Integer numOfEdge = graph.getNumOfEdge();
					// 获取图中所有边的集合
					Edge[] edges = getEdges(matrix, vertexes, numOfEdge);
					// 按照边的权值大小进行排序
					sortEdges(edges);
					// 保存”已有最小生成树每个顶点“中每个顶点在最小生成树中的终点
					int[] ends = new int[numOfEdge];
					// 保存最小生成树
					Edge[] ret = new Edge[vertexes.length - 1];
					int index = 0;
					for (Edge edge : edges) {
						// 获取边起点的下标
						int p1 = getVertexIndex(edge.getStart(), vertexes);
						// 获取边终点的下标
						int p2 = getVertexIndex(edge.getEnd(), vertexes);
						// 获取p1这个顶点在已有最小生成树中的终点
						int m = getEnd(ends, p1);
						// 获取p2这个顶点在已有最小生成树中的终点
						int n = getEnd(ends, p2);
						// 是否构成回路
						if (m != n) {
							ends[m] = n;
							ret[index++] = edge;
						}
					}
					return ret;
				}

				/**
				 * 获取顶点对应的下标
				 */
				private static int getVertexIndex(char vertex, char[] vertexes) {
					for (int i = 0; i < vertexes.length; i++) {
						if (vertex == vertexes[i]) {
							return i;
						}
					}
					return -1;
				}

				/**
				 * 获取图中所有的边
				 */
				private static Edge[] getEdges(int[][] matrix, char[] vertexes, int numOfEdge) {
					Edge[] edges = new Edge[numOfEdge];
					int numOfVertex = vertexes.length, index = 0;
					for (int i = 0; i < numOfVertex; i++) {
						for (int j = i + 1; j < numOfVertex; j++) {
							if (INF != matrix[i][j]) {
								edges[index++] = new Edge(vertexes[i], vertexes[j], matrix[i][j]);
							}
						}
					}
					return edges;
				}

				/**
				 * 对图中的所有边进行冒泡排序
				 */
				private static void sortEdges(Edge[] edges) {
					int edgeNum = edges.length;
					Edge temp;
					for (int i = 0; i < edgeNum - 1; i++) {
						for (int j = i + 1; j < edgeNum; j++) {
							if (edges[i].getWeight() > edges[j].getWeight()) {
								temp = edges[i];
								edges[i] = edges[j];
								edges[j] = temp;
							}
						}
					}
				}

				/**
				 * 获取下标为 i 的顶点的终点，用于后面判断两个顶点的终点是否相同
				 * @param ends 数组为了记录各个顶点对应的终点是哪个，end 是在遍历的过程中，逐步形成的
				 * @param i 表示传入的顶点对应的下标
				 * @return 返回下标为 i 的顶点对应的终点
				 */
				private static int getEnd(int[] ends, int i) {
					while (ends[i] != 0) {
						i = ends[i];
					}
					return i;
				}
			}
	8. 迪杰斯特拉算法
		① 应用场景和问题
			+---+	7	+---+	5	+---+
			| C |-------| A |-------| B |-------+
			+---+		+---+		+---+		|
			  |			  |			  |			|
			  |			  |			  |			|
			8 |			  |	2		  |	3		| 9
			  |			  |			  |			|
			+---+	4	+---+		  |			|
			| E |-------| G |---------+			|
			+---+		+---+					|
			  |			  |						|
			  |			  |						|
			5 |			  |	6					|
			  |			  |						|
			  |			+---+		 +---+		|
			  +---------| F |--------| D |------+
						+---+	4	 +---+
			A. 战争时期，胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄
			B. 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
			C. 问：如何计算出G村庄到 其它各个村庄的最短距离? 
			D. 如果从其它点出发到各个点的最短距离又是多少?
		② 算法介绍：迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层
		扩展(广度优先搜索思想)，直到扩展到终点为止。
		③ 算法过程
			A. 设置出发顶点为v，顶点集合V{v1,v2,vi...}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di...}，Dis集合记录着v到图中各顶点的距离（
			到自身可以看作0，v到vi距离对应为di）
			B. 从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径
			C. 更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节
			点为vi，表明是通过vi到达的)
			D. 重复执行两步骤，直到最短路径顶点为目标顶点即可结束
		④ 代码实现
			public class VisitedVertex {

				// 记录各个顶点是否已经访问过
				private final int[] alreadyArr;

				// 每个下标对应的值为前一个顶点的下标
				private final int[] preVisited;

				// 记录出发顶点到各个顶点的最短距离
				private final int[] dis;

				private static final int INF = 10000;

				public VisitedVertex(int numOfVertex, int index) {
					this.alreadyArr = new int[numOfVertex];
					this.preVisited = new int[numOfVertex];
					this.dis = new int[numOfVertex];
					Arrays.fill(dis, INF);
					dis[index] = 0;
					alreadyArr[index] = 1;
				}

				/**
				 * 判断顶点是否已经访问过
				 */
				public boolean isVisited(int index) {
					return this.alreadyArr[index] == 1;
				}

				/**
				 * 更新出发顶点到index顶点的距离
				 */
				public void updateDis(int index, int dis) {
					this.dis[index] = dis;
				}

				/**
				 * 更新pre顶点的前驱顶点为index顶点
				 */
				public void updatePreVisited(int pre, int index) {
					this.preVisited[pre] = index;
				}

				/**
				 * 继续选择并返回新的访问顶点
				 */
				public int updateAlreadyArr() {
					int min = INF, index = 0;
					for (int i = 0; i < alreadyArr.length; i++) {
						// 找到距离出发顶点最小距离的顶点
						if (alreadyArr[i] == 0 && getDis(i) < min) {
							min = getDis(i);
							index = i;
						}
					}
					alreadyArr[index] = 1;
					return index;
				}

				/**
				 * 获取出发顶点到index顶点的距离
				 */
				public int getDis(int index) {
					return this.dis[index];
				}

				public void show() {
					System.out.println(Arrays.toString(alreadyArr));
					System.out.println(Arrays.toString(preVisited));
					System.out.println(Arrays.toString(dis));
				}
			}
			
			public class DijkstraDemo {

				public static void main(String[] args) {
					// 0    1    2    3    4    5    6
					char[] vertexes = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
					Graph graph = new Graph(vertexes.length);
					for (char vertex : vertexes) {
						graph.addVertex(vertex);
					}

					graph.addEdge(0, 1, 5);
					graph.addEdge(0, 2, 7);
					graph.addEdge(0, 6, 2);
					graph.addEdge(1, 3, 9);
					graph.addEdge(1, 6, 3);
					graph.addEdge(2, 4, 8);
					graph.addEdge(3, 5, 4);
					graph.addEdge(4, 5, 5);
					graph.addEdge(4, 6, 4);
					graph.addEdge(5, 6, 6);
					graph.show();
					dijkstra(graph, 6);
				}

				public static void dijkstra(Graph graph, int index) {
					int numOfVertex = graph.getNumOfVertex();
					VisitedVertex visitedVertex = new VisitedVertex(numOfVertex, index);
					update(visitedVertex, graph, index);
					for (int i = 1; i < numOfVertex; i++) {
						index = visitedVertex.updateAlreadyArr();
						update(visitedVertex, graph, index);
					}
					visitedVertex.show();
				}

				/**
				 * 更新index顶点到周围顶点的距离和周围顶点的前驱顶点
				 */
				public static void update(VisitedVertex visitedVertex, Graph graph, int index) {
					int[][] matrix = graph.getEdges();
					int len;
					for (int i = 0; i < graph.getNumOfVertex(); i++) {
						// 出发顶点到index顶点的距离+从index顶点到i顶点的距离之和
						len = visitedVertex.getDis(index) + matrix[index][i];
						// 如果 i 顶点没有被访问过，并且 len 小于出发顶点到 i 顶点的距离
						if (!visitedVertex.isVisited(i) && visitedVertex.getDis(i) > len) {
							// 更新出发顶点到 i 顶点的距离
							visitedVertex.updateDis(i, len);
							// 更新 i 顶点的前驱顶点为index
							visitedVertex.updatePreVisited(i, index);
						}
					}
				}
			}
	9. 弗洛伊德算法
		① 弗洛伊德(Floyd)算法介绍
			A. 和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、
			斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名
			B. 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径
			C. 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。
			D. 弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都
			是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。
		② 弗洛伊德(Floyd)算法最佳应用-最短路径
			+---+	7	+---+	5	+---+
			| C |-------| A |-------| B |-------+
			+---+		+---+		+---+		|
			  |			  |			  |			|
			  |			  |			  |			|
			8 |			  |	2		  |	3		| 9
			  |			  |			  |			|
			+---+	4	+---+		  |			|
			| E |-------| G |---------+			|
			+---+		+---+					|
			  |			  |						|
			  |			  |						|
			5 |			  |	6					|
			  |			  |						|
			  |			+---+		 +---+		|
			  +---------| F |--------| D |------+
						+---+	4	 +---+
			A. 胜利乡有7个村庄(A, B, C, D, E, F, G)
			B. 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
			C. 问：如何计算出各村庄到 其它各村庄的最短距离? 
		③ 弗洛伊德(Floyd)算法分析
			A. 设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，
			vk的取值为图中所有顶点，则可获得vi到vj的最短路径
			B. 至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得
		④ 弗洛伊德(Floyd)算法图解分析
			A. 初始各顶点之间的距离和前驱关系
						A	B	C	D	E	F	G					A	B	C	D	E	F	G
						0	1	2	3	4	5	6					0	1	2	3	4	5	6
					  +--------------------------	  			  +--------------------------	
				A	0 |	0	5	7	N	N	N	2			A	0 |	A	A	A	A	A	A	A
				B	1 |	5	0	N	9	N	N	3			B	1 |	B	B	B	B	B	B	B
				C	2 |	7	N	0	N	8	N	N			C	2 |	C	C	C	C	C	C	C
				D	3 |	N	9	N	0	N	4	N			D	3 |	D	D	D	D	D	D	D
				E	4 |	N	N	8	N	0	5	4			E	4 |	E	E	E	E	E	E	E
				F	5 |	N	N	N	4	5	0	6			F	5 |	F	F	F	F	F	F	F
				G	6 |	2	3	N	N	4	6	0			G	6 |	G	G	G	G	G	G	G
						初始各顶点的距离表								初始顶点前驱关系
			B. 第一轮循环中，以A(下标为：0)作为中间顶点，距离表和前驱关系更新为：
						A	B	C	D	E	F	G					A	B	C	D	E	F	G
						0	1	2	3	4	5	6					0	1	2	3	4	5	6
					  +--------------------------	  			  +--------------------------	
				A	0 |	0	5	7	N	N	N	2			A	0 |	A	A	A	A	A	A	A
				B	1 |	5	0  |12|	9	N	N	3			B	1 |	B	B  |A|	B	B	B	B
				C	2 |	7  |12|	0	N	8	N  |9|			C	2 |	C  |A|	C	C	C	C  |A|
				D	3 |	N	9	N	0	N	4	N			D	3 |	D	D	D	D	D	D	D
				E	4 |	N	N	8	N	0	5	4			E	4 |	E	E	E	E	E	E	E
				F	5 |	N	N	N	4	5	0	6			F	5 |	F	F	F	F	F	F	F
				G	6 |	2	3  |9|	N	4	6	0			G	6 |	G	G  |A|	G	G	G	G
						初始各顶点的距离表								初始顶点前驱关系
			C. 以A顶点作为中间顶点是，B->A->C的距离由N->9，同理C到B；C->A->G的距离由N->12，同理G到C
			D. 更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束
		⑤ 代码实现
			public class FloydDemo {

				// 记录各出发顶点到各顶点的距离
				private int[][] dis;

				// 记录各顶点的前驱顶点
				private int[][] pre;

				public static void main(String[] args) {
					char[] vertexes = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
					Graph graph = new Graph(vertexes.length);
					for (char vertex : vertexes) {
						graph.addVertex(vertex);
					}

					graph.addEdge(0, 0, 0);
					graph.addEdge(0, 1, 5);
					graph.addEdge(0, 2, 7);
					graph.addEdge(0, 6, 2);
					graph.addEdge(1, 1, 0);
					graph.addEdge(1, 3, 9);
					graph.addEdge(1, 6, 3);
					graph.addEdge(2, 2, 0);
					graph.addEdge(2, 4, 8);
					graph.addEdge(3, 3, 0);
					graph.addEdge(3, 5, 4);
					graph.addEdge(4, 4, 0);
					graph.addEdge(4, 5, 5);
					graph.addEdge(4, 6, 4);
					graph.addEdge(5, 5, 0);
					graph.addEdge(5, 6, 6);
					graph.addEdge(6, 6, 0);

					FloydDemo floydDemo = new FloydDemo(graph.getEdges());
					floydDemo.floyd();
					floydDemo.show(graph.getVertexes());
				}

				public FloydDemo(int[][] matrix) {
					int length = matrix.length;
					this.dis = new int[length][length];
					for (int i = 0; i < length; i++) {
						System.arraycopy(matrix[i], 0, dis[i], 0, matrix[i].length);
						this.pre = new int[length][length];
						Arrays.fill(pre[i], i);
					}
				}

				public void floyd() {
					int length = dis.length, len;
					// 遍历中间顶点
					for (int k = 0; k < length; k++) {
						// 遍历出发顶点
						for (int i = 0; i < length; i++) {
							// 遍历达到顶点
							for (int j = 0; j < length; j++) {
								// 求从i顶点出发，经过k中间顶点，到达j顶点的距离
								len = dis[i][k] + dis[k][j];
								if (len < dis[i][j]) {
									dis[i][j] = len;
									pre[i][j] = pre[k][j];
								}
							}
						}
					}
				}

				public void show(char[] vertexes) {
					for (int i = 0; i < dis.length; i++) {
						for (int j = 0; j < dis.length; j++) {
							System.out.print(vertexes[pre[i][j]] + " ");
						}
						System.out.println();

						for (int j = 0; j < dis.length; j++) {
							System.out.print("(" + vertexes[i] + "到" + vertexes[j] + "的距离为" + dis[i][j] + ")");
						}
						System.out.println();
					}
				}
			}
	10. 马踏棋盘算法
		① 马踏棋盘算法介绍
			A. 马踏棋盘算法也被称为骑士周游问题
			B. 将马随机放在国际象棋的8×8棋盘Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格
			C. 游戏演示: http://www.4399.com/flash/146267_2.htm 
		② 马踏棋盘算法分析
			A. 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。
			B. 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了53个点，走到了第53个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的
			路径，就在棋盘上不停的回溯…… ，
		③ 马踏棋盘算法思路
			A. 创建棋盘 chessboard，是一个二维数组
			B. 将当前位置设置为已访问，然后根据当前位置，计算马儿还能走哪些位置，并放入到一个集合 List 中，最多有八个位置，每走一步，就使 step + 1
			C. 遍历 List 集合中存放的所有位置，看看哪个位置可以走通，如果走通，就继续，走不通，就回溯
			D. 判断马儿是否完成任务，使用 step 和应该走的步数进行比较，如果没有达到数据，则表示没有完成任务，需要将整个棋盘置为 0
			E. 注意：马儿不同的走法（策略），会得到不同的结果，效率也会有影响
			F. 使用贪心算法优化：对下一步要走的位置集合进行非递减排序，排序的规则是，按照下一步要走的位置的下一步的位置集合元素个数进行排序
				+---+---+---+---+---+---+---+---+
				|	|	|	|	|	|	|	|	|
				+---+---+---+---+---+---+---+---+
				|	|	|	|	|	|	|	|	|
				+---+---+---+---+---+---+---+---+
				|	|	|	| 6	|	| 7	|	|	|
				+---+---+---+---+---+---+---+---+
				|	|	| 5	|	|	|	| 0	|	|
				+---+---+---+---+---+---+---+---+
				|	|	|	|	|马 |	|	|	|
				+---+---+---+---+---+---+---+---+
				|	|	| 4	|	|	|	| 1	|	|
				+---+---+---+---+---+---+---+---+
				|	|	|	| 3	|	| 2	|	|	|
				+---+---+---+---+---+---+---+---+
				|	|	|	|	|	|	|	|	|
				+---+---+---+---+---+---+---+---+
		④ 代码实现
			public class HorseChessboard {

				// 棋盘行
				private final int X;
				// 棋盘列
				private final int Y;
				// 棋盘
				private final int[][] chessboard;
				// 棋盘相应的位置是否已经访问
				private final boolean[] isVisited;

				private boolean isFinished;

				public HorseChessboard(int x, int y) {
					this.X = x;
					this.Y = y;
					this.chessboard = new int[this.X][this.Y];
					this.isVisited = new boolean[this.X * this.Y];
					this.isFinished = false;
				}

				public static void main(String[] args) {
					HorseChessboard horseChessboard = new HorseChessboard(8, 8);
					long start = System.currentTimeMillis();
					horseChessboard.traversalChessboard(0, 0, 1);
					long end = System.currentTimeMillis();
					System.out.println("耗时：" + (end - start));
					System.out.println();
					horseChessboard.show();
				}

				private void traversalChessboard(int row, int col, int step) {
					// 记录当前位置的步数
					chessboard[row][col] = step;
					// 记录当前位置为已访问
					isVisited[row * X + col] = true;
					// 获取当前位置的马儿可以走的位置集合
					List<Point> nextPoints = nextPoints(new Point(col, row));
					// 对下一步要走的位置集合进行非递减排序，排序的规则是，按照下一步要走的位置的下一步的位置集合元素个数进行排序
					// 贪心算法优化
					nextPoints.sort((p1, p2) -> nextPoints(p1).size() - nextPoints(p2).size());
					while (!nextPoints.isEmpty()) {
						Point point = nextPoints.remove(0);
						// 判断下一个位置是否已访问
						if (!isVisited[point.y * X + point.x]) {
							traversalChessboard(point.y, point.x, step + 1);
						}
					}
					// 判断马儿是否已完成任务，使用 step 和应该走的步数比较
					// 如果没有达到，则表示没有完成任务，进行回溯
					// step < X * Y 成立的情况有两种：
					// 1. 棋盘到目前位置仍然未走完
					// 2. 棋盘已经结束，但未完成，需要进行回溯
					if (step < X * Y && !isFinished) {
						// 将当前位置的步数设置为 0
						chessboard[row][col] = 0;
						// 将当前位置设置为未访问
						isVisited[row * X + col] = false;
					} else {
						isFinished = true;
					}
				}

				private List<Point> nextPoints(Point point) {
					List<Point> nextPoints = new ArrayList<>();
					Point next = new Point();
					// 判断马儿是否能走5的位置
					if ((next.x = point.x - 2) >= 0 && (next.y = point.y - 1) >= 0) {
						nextPoints.add(new Point(next));
					}
					// 判断马儿是否能走6的位置
					if ((next.x = point.x - 1) >= 0 && (next.y = point.y - 2) >= 0) {
						nextPoints.add(new Point(next));
					}
					// 判断马儿是否能走7的位置
					if ((next.x = point.x + 1) < X && (next.y = point.y - 2) >= 0) {
						nextPoints.add(new Point(next));
					}
					// 判断马儿是否能走0的位置
					if ((next.x = point.x + 2) < X && (next.y = point.y - 1) >= 0) {
						nextPoints.add(new Point(next));
					}
					// 判断马儿是否能走1的位置
					if ((next.x = point.x + 2) < X && (next.y = point.y + 1) < Y) {
						nextPoints.add(new Point(next));
					}
					// 判断马儿是否能走2的位置
					if ((next.x = point.x + 1) < X && (next.y = point.y + 2) < Y) {
						nextPoints.add(new Point(next));
					}
					// 判断马儿是否能走3的位置
					if ((next.x = point.x - 1) >= 0 && (next.y = point.y + 2) < Y) {
						nextPoints.add(new Point(next));
					}
					// 判断马儿是否能走4的位置
					if ((next.x = point.x - 2) >= 0 && (next.y = point.y + 1) < Y) {
						nextPoints.add(new Point(next));
					}
					return nextPoints;
				}

				public void show() {
					for (int[] rows : chessboard) {
						System.out.println(Arrays.toString(rows));
					}
				}
			}