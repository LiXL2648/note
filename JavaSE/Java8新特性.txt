一. Java 8 新特性
	1. 主要内容
		① Lambda 表达式
		② 函数式接口
		③ 方法引用与构造器引用
		④ Stream API
		⑤ 接口中的默认方法与静态方法
		⑥ 新时间日期API
		⑦ 其他新特性
	2. 简介
		① 速度更快
			A. Hashmap 底层结构/原理
			B. 并发hashmap
			C. Java虚拟机
			D. Java内存模型
		② 代码更少（增加新语法Lambda表达式）
		③ 强大的 Steam API
		④ 便于并行
		⑤ 最大化减少空指针异常 OPtional
	3. 其中最核心的是Lambda表达式与 Stream API
二. Lambda表达式
	1. 为什么使用 Lambda 表达式
		① Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁，更灵活的代码。
		作为一种更为紧凑的代码风格，使Java的语言表达能力得到提升
			A. 匿名内部类
				Comparator<Integer> comparator = new Comparator<Integer>() {
					@Override
					public int compare(Integer o1, Integer o2) {
						return Integer.compare(o1, 02);
					}
				};
			B. Lambda表达式
				Comparator<Integer> comparator1 = (o1, o2) -> Integer.compare(o1, o2);
			C. 获取当前公司员工年龄小于18的员工信息
				a. 传统方式
					List<Employee> list = Arrays.asList(
						new Employee(1, "LiXL", 1, 18, 8000.00),
						new Employee(2, "YuCX", 0, 19, 9000.00),
						new Employee(3, "LinK", 1, 17, 7000.00),
						new Employee(4, "LinZH", 1, 18, 8000.00),
						new Employee(4, "LiLX", 0, 16, 9000.00)
					);
					private List<Employee> filterEmployee(List<Employee> list) {
						List<Employee> newList = new ArrayList<>();

						for (Employee employee: list) {
							if (employee.getAge() < 18) {
								newList.add(employee);
							}
						}

						return newList;
					}
				b. 优化方式一：策略设计模式，每多一个策略，则需要重新实现MyPredicate接口
					public interface MyPredicate<T> {

						boolean test(T t);
					}
					
					public class FilterEmployeeByAge implements MyPredicate<Employee> {

						@Override
						public boolean test(Employee employee) {
							return employee.getAge() < 18;
						}
					}
					
					private List<Employee> filterEmployeeByAge1(List<Employee> list, MyPredicate<Employee> myPredicate) {
						List<Employee> emps = new ArrayList<>();

						for (Employee employee: list) {
							if (myPredicate.test(employee)) {
								emps.add(employee);
							}
						}
						return  emps;
					}
				c. 优化方式二：匿名内部类，每增加一个策略，不需要实现MyPredicate接口，而是提供一个匿名内部类
					filterEmployeeByAge1(list, new MyPredicate<Employee>() {
						@Override
						public boolean test(Employee employee) {
							return employee.getSalary() > 8000;
						}
					})
				d. 优化方式三：lambda表达式
					List<Employee> emps = filterEmployeeByAge1(list, employee -> employee.getGender() == 0);
					emps.forEach(System.out::println);
				e. 优化方式四：Stream API
					list.stream().filter(employee -> employee.getGender() == 1).forEach(System.out::println);
		② Lambda表达式被称为语法糖或者糖衣语法。
	2. 基础语法：
		① Java 8 中引入了一个新的操作符 “->”，该操作符称为箭头操作符或者Lambda操作符，箭头操作符将 Lambda 表达式拆分为两部分
			A. 左侧：Lambda 表达式中的参数列表
			B. 右侧：Lambda 表达式中所需要执行的功能，即 Lambda 体
		② 语法格式：
			A. 无参数，无返回值：
				a. 语法：() -> {}，如果Lambda体中只有一条语句，则大括号可以省略
				b. 对应的函数式接口：Runnable
				c. 举例：
					Runnable runnable = new Runnable() {
						@Override
						public void run() {
							System.out.println("hello");
						}
					};
					runnable.run();
					
					Runnable runnable = () -> System.out.println("Hello");
					runnable.run();
				d. 注意：在局部内部类中使用了同级的局部变量时，需要声明该变量为 final，但是在 Java8 中，会隐式默认该变量为final修饰，不需要显示
				修饰，在Java 8 或者 Java 7中的局部内部类中，都不允许修改该变量。
			B. 有参数，无返回值：
				a. 语法：(T t) -> {}，如果只有一个参数，小括号可以省略，一般默认带上小括号
				b. 对应的函数式接口：Consumer
				c. 举例：
					Consumer<String> consumer = new Consumer<String>() {
						@Override
						public void accept(String str) {
							System.out.println(str);
						}
					};
					consumer.accept("Hello");

					Consumer<String> consumer1 = str -> System.out.println(str);
					consumer1.accept("World");
			C. 有两个以上的参数，并且有返回值，并且Lambda表达式中有多条语句
				a. 语法：(T t1, T t2) -> {} ，有多条语句时，大括号不能省略；只有一条语句时，return 可以省略不写；参数列表有多个时，小括号不能省略。
				b. 对应的函数式接口为：
				c. 举例：
					Comparator<Integer> comparator = new Comparator<Integer>() {
						@Override
						public int compare(Integer o1, Integer o2) {
							return Integer.compare(o1, o2);
						}
					};

					Comparator<Double> comparator1 = (d1, d2) -> {
						System.out.println("Comparator函数式接口");
						return Double.compare(d1, d2);
					};
			D. Lambda表达式参数列表的数据类型可以省略不写，因为Java 的 JVM编译器通过上下文可以推断出参数列表的数据类型，即“类型推断”，当接口中的泛型
			指明了参数列表中的数据类型时，此时Lambda表达式中参数列表的数据类型就可以省略不写
		③ Lambda表达式需要“函数式接口”的支持
			A. 函数式接口：接口中有只有一个抽象方法，则称为“函数式接口”
			B. 可以使用@FunctionalInterface注解检查其标注的接口是否为“函数式接口”
		④ 练习：
			A. 对一个数进行数学运算
				public interface MyFunction<T> {

					T operator(T t);
				}
		
				MyFunction<Integer> myFunction = x -> x * x;
				System.out.println( myFunction.operator(10));
			B. 调用Collections.sort()方法，通过定制排序比较两个Employee（先按照年龄比，年龄相同按姓名比），使用Lambda作为参数传递
				@Test
				public void test5() {
					Collections.sort(list, (e1, e2) -> {
						if (e1.getAge() == e2.getAge()) {
							return e1.getEmpName().compareTo(e2.getEmpName());
						} else {
							return Integer.compare(e1.getAge(), e2.getAge());
						}
					});
					list.forEach(System.out::println);
				}
			C.  声明函数式接口，接口中声明抽象方法，在测试类中，编写方法使用接口作为参数，将一个字符串转成大写，并作为返回值。再将该字符串进行截取
				@Test
				public void test6() {
					String value = getValue("LiXL&YuCX", str -> str.toUpperCase());
					value = getValue(value, str -> str.substring(0, 4));
					System.out.println(value);
				}

				
				private <T> T getValue(T t, MyFunction<T, T> myFunction) {
					return myFunction.operator(t);
				}
				
				public interface MyFunction<T, R> {

					R operator(T ... t);
				}
			D.  声明一个带两个泛型的函数式接口，泛型类型为<T, R>，T为参数，R为返回值，接口中声明抽象方法，在测试类中，使用该接口作为参数，计算两个long类型的和，
			再计算两个long类型的乘积
				public void test7() {
					Integer sum = getValue(args -> args[0] + args[1], 26, 48);
					System.out.println(sum);
					Integer mul = getValue(args -> args[0] * args[1], 26, 48);
					System.out.println(mul);
				}
				
				private <T> T getValue(MyFunction<T, T> myFunction, T ... t) {
					return myFunction.operator(t);
				}
				
				public interface MyFunction<T, R> {

					R operator(T ... t);
				}
二. 函数式接口
	1. 四大内置的核心函数式接口：
		① Consumer<T>：
			A. 消费型接口
			B. 抽象方法：void accept(T t);
			C. 举例：
				public void testConsumer() {
					consume(100D, menoy -> System.out.println("其次消费总共花费 " + menoy + " 元"));
				}

				public void consume(Double money, Consumer<Double> consumer) {
					consumer.accept(money);
				}
		② Supplier<T> ：
			A. 供给型接口
			B. 抽象方法：T get();
			C. 举例：
				@Test
				public void testSupplier() {
					List<Integer> list = supplie(10, () -> (int) (Math.random() * 100));
					list.forEach(System.out::println);
				}

				private List<Integer> supplie(int num, Supplier<Integer> supplier) {
					List<Integer> list = new ArrayList<>();
					for (int i = 0; i < num; i++) {
						Integer value = supplier.get();
						list.add(value);
					}
					return list;
				}
		③ Function<T, R>：
			A. 函数型接口
			B. 抽象方法：R apply(T t);
			C. 举例：
				@Test
				public void testFunction() {
					String result = strHandler("LiXL", str -> str.toUpperCase());
					System.out.println(result);
				}

				public String strHandler(String str, Function<String, String> function) {
					return function.apply(str);
				}
		④ Predicate<T>：
			A. 断言型接口
			B. 抽象方法：boolean test(T t);
			C. 举例：
				@Test
				public void testPredicate() {
					List<String> list = Arrays.asList("LiXL", "LiXC", "LiXY", "LiLX", "YuCX");
					List<String> newList = filter(list, str -> str.startsWith("Li"));
					System.out.println(newList);
				}

				private List<String> filter(List<String> list, Predicate<String> predicate) {
					List<String> newList = new ArrayList<>();
					list.forEach(str -> {
						if (predicate.test(str)) {
							newList.add(str);
						}
					});
					return newList;
				}
	2. 其他接口
		① BiFunction<T, U, R>：
			A. 参数类型：T,U
			B. 返回值类型：R
			C. 用途：对类型为 T，U 参数应用操作，返回 R 类型的结果。包含方法 R apply(T t, U u)
		② UnaryOperator<T>（Function<T, R> 的子接口）
			A. 参数类型：T
			B. 返回值类型：T
			C. 对类型为 T 的对象进行一元运算，并返回类型为 T 的结果，包含方法为 T apply(T t)
		③ BinaryOperator<T>（BiFunction<T, U, R>的子接口）：
			A. 参数类型：T，T
			B. 返回值类型：T
			C. 对类型为 T 的对象进行二元运算，并返回类型为 T 的结果，包含方法为 T apply(T t1, T t2)
		④ BiConsumer<T, U>
			A. 参数类型：T，U
			B. 返回值类型：void
			C. 对类型为 T，U 的参数进行操作，包含方法为 void accept(T t, U u);
		⑤ ToIntFunction<T>，ToLongFunction<T>，ToDoubleFunction<T>
			A. 参数类型：T，T
			B. 返回值类型：分别为 int，long，double
			C. 分别计算 int，long，double，值的函数
		⑥ IntFunction<R>，LongFunction<R>，DoubleFunction<R>
			A. 参数类型：分别为 int，long，double
			B. 返回值类型：R
			C. 参数分别为 int，long，double的函数
		⑦ BiPredicate<T, U>
			A. 参数类型：T，U
			B. 返回值类型为boolean
三. 方法引用和构造器引用
	1. 方法引用
		① 若Lambda体中的内容有方法已经实现，我们可以使用“方法引用”（可以理解为方法引用是Lambda表达式的另一种变现形式）
		② 主要有三种语法格式：
			A. 对象::实例方法名
				Consumer<String> consumer = x -> System.out.println(x);
				consumer.accept("Hello");

				Consumer<String> consumer1 = System.out::println;
				consumer1.accept("Hello World!");
				
				Employee employee = list.get(0);
				Supplier<String> supplier = employee::getEmpName;
				System.out.println(supplier.get());
			B. 类::静态方法名
				Comparator<Integer> com = (x, y) -> Integer.compare(x, y);
				int compare = com.compare(48, 26);
			   
				Comparator<Double> com1 = Double::compare;
				int compare1 = com1.compare(26D, 48D);
			C. 类::实例方法名
				BiPredicate<String, String> bp = (x, y) -> x.equalsIgnoreCase(y);
				System.out.println(bp.test("LiXL", "lixl"));

				BiPredicate<String, String> bp1 = String::equals;
				System.out.println(bp1.test("LiXL", "LiLX"));
		③ 注意：
			A. 进行方法引用时，Lambda体中调用方法的参数列表与返回值类型，需要与函数型接口中的抽象方法的参数列表和返回值保持一致
			B. 若Lambda的参数列表列表的第一个参数是方法的调用者，而第二个参数是实例方法的参数时，可以使用类名::实例方法。
	2. 构造器引用
		① 语法：类名::new
		② 举例：
			Supplier<Employee> supplier = () -> new Employee();
			System.out.println(supplier.get());

			Supplier<Employee> supplier1 = Employee::new;
			System.out.println(supplier1.get());
			
			Function<String, Employee> fun = x -> new Employee(x);
			System.out.println(fun.apply("LiXL"));

			Function<String, Employee> fun1 = Employee::new;
			System.out.println(fun1.apply("LiLX"));
		② 注意: 进行构造器引用时，Lambda体中调用构造器的参数列表与返回值类型，需要与函数型接口中的抽象方法的参数列表和返回值保持一致
	3. 数组引用：
		① 语法：Tyep::new
		② 举例：
			Function<Integer, String[]> fun = x -> new String[x];
			System.out.println(fun.apply(10).length);

			Function<Integer, String[]> fun1 = String[]::new;
			System.out.println(fun1.apply(20).length);
四.	强大的 Stream API
	1. 了解Stream
		① Java8 中有两大最为重要的改变，第一个就是 Lambda 表达式；另外一个则是 Steam API（java.util.stream.*）
		② Steam 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作。可以执行非常复杂的查找，过滤和映射数据等操作。
		③ 使用Stream API 对集合进行操作，就类似于使用SQL执行的数据查询。也可以使用 Stream API来并行执行操作。简而言之 Stream API 
		提供了一种高效且易于使用的处理数据的方式
	2. 什么是Stream
		① 流（Stream）：是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。“集合讲的是数据，流讲的是计算”
		② 注意：
			A. Stream 自己不会存储元素
			B. Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。
			C. Stream 操作是延迟执行的，这意味着他们会等到需要结果的时候才执行，
	3. Stream 的三个操作步骤
		① 创建Stream：一个数据源（如：集合，数组），获取一个流
		② 中间操作：一个中间操作链，对数据源的数据进行处理
		③ 中止操作（终端操作）：一个终止操作，执行中间操作链，并产生结果
	4. 创建Stream
		① Java 8 中的Collection接口被扩展，提供了两个获取流的方法
			A. default Stream<E> stream()：返回一个顺序流
			B. default Stream<E> parallelStream()：返回一个并行流
			C. 举例：
				List<Employee> emps = new ArrayList<>();
				Stream<Employee> stream = emps.stream();
				Stream<Employee> parallelStream = emps.parallelStream();
		② 由数组创建流
			A. Java 8 中的 Arrays的静态方法 stream()可以获取数组流
				static <T> Stream<T> stream(T[] array)：返回一个流
			B. 重载形式，能够处理对应基本类型的数组
				a. public static IntStream stream(int[] array)
				b. public static LongStream stream(long[] array)
				c. public static DoubleStream stream(double[] array)
			C. 举例
				Employee[] employees = new Employee[10];
				Stream<Employee> stream1 = Arrays.stream(employees);
		③ 通过Stream类中的静态方法of()
			A. static<T> Stream<T> of(T... values)
			B. 举例
				Stream<String> stream2 = Stream.of("LiXL", "LiLX");
		④ 创建无限流
			A. 迭代：
				a. static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)
				b. 举例
					Stream<Integer> stream3 = Stream.iterate(0, x -> x + 2);
					stream3.limit(10).forEach(System.out::println);
			B. 生成：
				a. static<T> Stream<T> generate(Supplier<T> s)
				b. 举例
					Stream<Integer> stream4 = Stream.generate(() -> (int) (Math.random() * 10000));
					stream4.limit(10).forEach(System.out::println);
	5. 中间操作
		① 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何处理！而在终止操作时一次性全部处理，
		称为“惰性求值”或则“延迟加载”
		② 筛选与切片
			A. Stream<T> filter(Predicate<? super T> predicate);
				a. 接收Lambda，从流中排除某些元素
				b. 举例：
					list.stream().filter(e -> e.getGender() == 1)
							.forEach(System.out::println);
				c. 过滤后会产生一个新流，但是不会执行任何操作，终止操作时会一次性执行全部内容
				d. 内部迭代：迭代操作由Stream API 完成
				e. 外部迭代：
					Iterator<Employee> iterator = list.iterator();
					while (iterator.hasNext()) {
						System.out.println(iterator.next());
					}
			B. Stream<T> distinct();
				a. 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素
				b. 举例：
					list.stream()
							.filter(e -> e.getSalary() > 7000)
							.distinct()
							.forEach(System.out::println);
				c. 需要重写 equals() 和hashCode() 方法
			C. Stream<T> limit(long maxSize);
				a. 截断流，使其元素不超过给定的数量
				b. 举例：
					list.stream()
							.filter(e -> e.getSalary() > 7000)
							.limit(2)
							.forEach(System.out::println);
				c. 若迭代次数满足条件，则会出现短路现在，即满足条件往后得迭代将不执行
			D. Stream<T> skip(long n);
				a. 跳过元素，返回一个扔掉前 n 个元素的流。若流中的元素不足 n 个，则返回一个空流。与limit(long maxSize)互补
				b. 举例：
					list.stream()
							.filter(e -> e.getSalary() > 7000)
							.skip(2)
							.forEach(System.out::println);
		③ 映射
			A. <R> Stream<R> map(Function<? super T, ? extends R> mapper);
				a. 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的流，将元素转换成其他形式或提取信息。
				b. 举例：
					// 将元素转换成其他形式
					List<String> strList = Arrays.asList("lixl", "yucx", "lilx");
					strList.stream()
							.map(str -> str.toUpperCase())
							.forEach(System.out::println);

					// 提取信息
					list.stream()
							.map(Employee::getEmpName)
							.distinct()
							.forEach(System.out::println);
			B. IntStream mapToInt(ToIntFunction<? super T> mapper);
				a. 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream
			C. LongStream mapToLong(ToLongFunction<? super T> mapper);
				a. 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream
			D. DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper);
				a. 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream
			E. <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
				a. 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流
				b. 方式一：该方式相当于List<List<Character>>.add(List<Character>)
					list.stream()
							.map(Employee::getEmpName) // 获取集合中员工名字组成得新流
							.map(TestStreamApi::getStream) // 获取每个名字转换成Character流的新流
							.forEach(s -> { // 遍历新流中的每个Character流
								s.forEach(System.out::println); // 遍历Character流
								System.out.println("-------------------");
							});
					private static Stream<Character> getStream(String str) {
						List<Character> charList = new ArrayList<>();

						for (Character c: str.toCharArray()) {
							charList.add(c);
						}
						return  charList.stream();
					}
				c. 方式二：该方式相当于List<Character>.addAll(List<Character>)
					list.stream()
							.map(Employee::getEmpName)
							.flatMap(TestStreamApi::getStream)
							.forEach(System.out::println);
		④ 排序
			A. Stream<T> sorted();
				a. 产生一个新流，其中按自然顺序排序（Comparable<T>）
				b. 举例：
					list.stream()
							.map(Employee::getSalary)
							.distinct()
							.sorted()
							.forEach(System.out::println);
			B. Stream<T> sorted(Comparator<? super T> comparator);
				a. 产生一个新流，其中按比较器顺序排序（Comparator<T>）
				b. 举例：
					list.stream()
							.sorted((e1, e2) -> {
								if (e1.getAge() == e2.getAge()) {
									return e1.getEmpName().compareTo(e2.getEmpName());
								} else {
									return Integer.compare(e1.getAge(), e2.getAge());
								}
							})
							.distinct()
							.forEach(System.out::println);
	6. 终止操作
		① 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List，Integer，甚至是void
		② 查找与匹配
			A. boolean allMatch(Predicate<? super T> predicate);
				a. 检查是否匹配所有元素
				b. 举例：
					boolean allMatch = list.stream()
							.allMatch(e -> e.getStatus().equals(Employee.Status.BUSY));
					System.out.println(allMatch);
			B. boolean anyMatch(Predicate<? super T> predicate);
				a. 检查是否至少匹配一个元素
				b. 举例：
					boolean anyMatch = list.stream()
							.anyMatch(e -> e.getStatus().equals(Employee.Status.FREE));
					System.out.println(anyMatch);
			C. boolean noneMatch(Predicate<? super T> predicate);
				a. 检查是否没有匹配所有元素
				b. 举例：
					boolean noneMatch = list.stream()
							.noneMatch(e -> e.getStatus().equals(Employee.Status.VOCATION));
					System.out.println(noneMatch);
			D. Optional<T> findFirst();
				a. 返回第一个元素
				b. 举例：
					Optional<Employee> optional = list.stream()
							.filter(e -> e.getStatus().equals(Employee.Status.FREE))
							.findFirst();
					System.out.println(optional.get());
				c. 返回一个Optional容器类，有效地避免空指针异常
			E. Optional<T> findAny();
				a. 返回当前流中的任意元素
				b. 举例：
					Optional<Employee> any = list.parallelStream()
							.filter(e -> e.getStatus().equals(Employee.Status.BUSY))
							.findAny();
					System.out.println(any.get());
				c. 使用并行流可以增加随机性
			F. long count();
				a. 返回流中元素地总数
				b. 举例：
					long count = list.stream()
							.filter(e -> e.getEmpName().startsWith("Li"))
							.count();
					System.out.println(count);
			G. Optional<T> max(Comparator<? super T> comparator);
				a. 获取流中的最大值
				b. 举例：
					Optional<Employee> optional = list.stream()
							.filter(e -> e.getEmpName().startsWith("Li"))
							.max((e1, e2) -> e1.getAge().compareTo(e2.getAge()));
					System.out.println(optional.get());
			H. Optional<T> 	(Comparator<? super T> comparator);
				a. 获取流中的最小值
				b. 举例：
					@Test
					public void testMin() {
						Optional<Employee> optional = list.stream()
								.filter(e -> e.getEmpName().startsWith("Li"))
								.min((e1, e2) -> e1.getAge().compareTo(e2.getAge()));
						System.out.println(optional.get());
					}
		③ 归约（reduce）：将流中的每个元素反复结合起来，得到一个值
			A. Optional<T> reduce(BinaryOperator<T> accumulator);
				a. 只需一个二元运算函数式接口
				b. 举例：
					Optional<Double> reduce = list.stream()
							.map(Employee::getSalary)
							.reduce(Double::sum);
					System.out.println(reduce.get());
				c. 结果返回一个Optional，原因是该方法没有起始值，而流中可能不存在一个元素。
			B. T reduce(T identity, BinaryOperator<T> accumulator);
				a. 需要两个参数，
					(1) identity：起始值
					(2) BinaryOperator：二元运算函数式接口
				b. 举例：
					Double reduce = list.stream()
							.map(Employee::getSalary)
							.reduce(0D, (x, y) -> x + y);
					System.out.println(reduce);
				c. 执行流程，将起始值作为x，将流中的第一个元素作为y，得到结果继续作为x，直到最终获取到总值。
			C. <U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner);
			D. 注：map 和reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名
		④ 收集（collect）：将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法
			A. Collector 接口方法的实现决定了如何对流执行收集操作（如收集到List，Set和Map）。但是Collectors实现类提供了很多静态方法，
			可以方便地创建常见收集器实例，具体方法与实例如下
			B. Collectors.toList():
				a. 将流中地元素收集到List中
				b. 举例：
					List<String> names = list.stream()
							.map(Employee::getEmpName)
							.distinct()
							.collect(Collectors.toList());
					names.forEach(System.out::println);
			C. Collectors.toSet():
				a. 将流中的元素收集到set中，去除重复元素
				b. 举例：
					Set<String> set = list.stream()
							.map(Employee::getEmpName)
							.collect(Collectors.toSet());
					set.forEach(System.out::println);
			D. Collectors.toCollection(Supplier<T> supplie)
				a. 如果需要收集到一些特殊的数据结构，则可以使用Collectors.toCollection(Supplier<T> supplie)
				b. Collectors.toCollection(Supplier<T> supplie) 方法需要一个供给型接口，用于提供对象
				c. 举例：
					HashSet<String> hashSet = list.stream()
							.map(Employee::getEmpName)
							.collect(Collectors.toCollection(HashSet::new));
					hashSet.forEach(System.out::println);
			E. Collectors.counting()
				a. 收集流中元素的总数
				b. 举例：
					Long counting = list.stream()
						.map(Employee::getAge)
						.distinct()
						.collect(Collectors.counting());
					System.out.println(counting);
			F. Collectors.averagingDouble/Collectors.averagingInteger/Collectors.averagingLong
				a. 获取流中元素的平均值
				b. 举例：
					Double averaging = list.stream()
							.collect(Collectors.averagingDouble(Employee::getSalary));
					System.out.println(averaging);
				c. Collectors.averagingDouble方法需要传入提取用于求平均值的元素，不需要额外提取
			G. Collectors.summingDouble/Collectors.summingInteger/Collectors.summingLong
				a. 获取流中元素的总和
				b. 举例：
					Double sum = list.stream()
							.collect(Collectors.summingDouble(Employee::getSalary));
					System.out.println(sum);
			H. Collectors.maxBy
				a. 获取流中的最大值
				b. 举例：
					Optional<Double> max = list.stream()
							.map(Employee::getSalary)
							.collect(Collectors.maxBy(Double::compareTo));
					System.out.println(max.get());
			I. Collectors.minBy
				a. 获取流中的最小值
				b. 举例：
					Optional<Integer> min = list.stream()
							.map(Employee::getAge)
							.collect(Collectors.minBy(Integer::compareTo));
					System.out.println(min.get());
			J. Collectors.groupingBy(Function<? super T, ? extends K> classifier)
				a. 分组
				b. 举例：
					 Map<Employee.Status, List<Employee>> map = list.stream()
							.collect(Collectors.groupingBy(Employee::getStatus));
					System.out.println(map);
			K. Function<? super T, ? extends K> classifier, Collector<? super T, A, D> downstream
				a. 多级分组
				b. 举例：
					Map<Employee.Status, Map<Integer, List<Employee>>> map = list.stream()
							.collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy(Employee::getAge)));
					System.out.println(map);
			L. Collectors.partitioningBy
				a. 分区/分片
				b. 举例：
					Map<Boolean, List<Employee>> map = list.stream()
							.collect(Collectors.partitioningBy(e -> e.getEmpName().startsWith("Li")));
					System.out.println(map);
			M. Collectors.summarizingDouble/Collectors.summarizingInteger/Collectors.summarizingLong
				a. 收集流中元素的最大值/最小值等封装的对象
				b. 举例：
					DoubleSummaryStatistics summaryStatistics = list.stream()
							.collect(Collectors.summarizingDouble(Employee::getSalary));
					System.out.println(summaryStatistics.getMax());
					System.out.println(summaryStatistics.getAverage());
					System.out.println(summaryStatistics.getCount());
					System.out.println(summaryStatistics.getMin());
					System.out.println(summaryStatistics.getSum());
			N. Collectors.joining
				a. 连接字符串
				b. 举例：
					String join = list.stream()
							.map(employee -> employee.getId().toString())
							.collect(Collectors.joining(";"));
					System.out.println(join);
	7. 练习：
		① 给定一个数组列表，如何返回一个由每个元素的平方构成的列表，给定[1, 2, 3, 4]，返回[1, 4, 9, 16]
			List<Integer> list = Arrays.asList(1, 2, 3, 4);
			list.stream()
					.map(i -> i * i)
					.forEach(System.out::println);
		② 怎么使用map和reduce计算流中的Employee个数
			Integer reduce = list.stream()
					.map(employee -> 1)
					.reduce(0, (x, y) -> Integer::sum);
			System.out.println(reduce);
		③ 交易与交易员
			A. 交易员类
				public class Trader {

				private String name;
				private String city;

				public Trader() {
				}

				public Trader(String name, String city) {
					this.name = name;
					this.city = city;
				}

				public String getName() {
					return name;
				}

				public void setName(String name) {
					this.name = name;
				}

				public String getCity() {
					return city;
				}

				public void setCity(String city) {
					this.city = city;
				}

				@Override
				public boolean equals(Object o) {
					if (this == o) return true;
					if (o == null || getClass() != o.getClass()) return false;
					Trader trader = (Trader) o;
					return Objects.equals(name, trader.name) &&
							Objects.equals(city, trader.city);
				}

				@Override
				public int hashCode() {
					return Objects.hash(name, city);
				}

				@Override
				public String toString() {
					return "Trader{" +
							"name='" + name + '\'' +
							", city='" + city + '\'' +
							'}';
				}
			}
		B. 交易类
			public class Transaction {

				private Trader trader;
				private Integer year;
				private Integer value;

				public Transaction() {
				}

				public Transaction(Trader trader, Integer year, Integer value) {
					this.trader = trader;
					this.year = year;
					this.value = value;
				}

				public Trader getTrader() {
					return trader;
				}

				public void setTrader(Trader trader) {
					this.trader = trader;
				}

				public Integer getYear() {
					return year;
				}

				public void setYear(Integer year) {
					this.year = year;
				}

				public Integer getValue() {
					return value;
				}

				public void setValue(Integer value) {
					this.value = value;
				}

				@Override
				public boolean equals(Object o) {
					if (this == o) return true;
					if (o == null || getClass() != o.getClass()) return false;
					Transaction that = (Transaction) o;
					return Objects.equals(trader, that.trader) &&
							Objects.equals(year, that.year) &&
							Objects.equals(value, that.value);
				}

				@Override
				public int hashCode() {
					return Objects.hash(trader, year, value);
				}

				@Override
				public String toString() {
					return "Transaction{" +
							"trader=" + trader +
							", year=" + year +
							", value=" + value +
							'}';
				}
			}
		C. 交易：
			List<Transaction> transactions = Arrays.asList(
					new Transaction(new Trader("LiXL", "广州"), 1996, 48),
					new Transaction(new Trader("YuCX", "广州"), 1995, 29),
					new Transaction(new Trader("LiLX", "东莞"), 1996, 30),
					new Transaction(new Trader("LinK", "广州"), 1996, 18),
					new Transaction(new Trader("LinZH", "广州"), 1996, 20),
					new Transaction(new Trader("LiXC", "深圳"), 1992, 27)
			);
		D. 找出1996年发生的所有交易，并按交易额排序（从低到高）
			transactions.stream()
                .filter(t -> t.getYear() == 1996)
                .sorted((t1, t2) -> Integer.compare(t1.getValue(), t2.getValue()))
                .forEach(System.out::println);
		E. 交易员都在哪些不同的城市工作过
			transactions.stream()
                .map(Transaction::getTrader)
                .map(Trader::getCity)
                .collect(Collectors.toSet())
                .forEach(System.out::println);
		F. 查找所有来自广州的交易员，并按照姓名排序
			transactions.stream()
                .map(Transaction::getTrader)
                .filter(t -> t.getCity().equals("广州"))
                .sorted((t1, t2) -> t1.getName().compareTo(t2.getName()))
                .forEach(System.out::println);
		G. 返回所有交易员姓名的字符串，按字母顺序排序
		H. 有没有交易员在东莞工作的
		I. 打印生活在广州的交易员的所有交易额
		J. 所有交易中，最高的交易额是多少
		K. 找到交易额最小的交易













































































































