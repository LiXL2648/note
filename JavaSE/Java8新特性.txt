一. Java 8 新特性
	1. 主要内容
		① Lambda 表达式
		② 函数式接口
		③ 方法引用与构造器引用
		④ Stream API
		⑤ 接口中的默认方法与静态方法
		⑥ 新时间日期API
		⑦ 其他新特性
	2. 简介
		① 速度更快
			A. Hashmap 底层结构/原理
			B. 并发hashmap
			C. Java虚拟机
			D. Java内存模型
		② 代码更少（增加新语法Lambda表达式）
		③ 强大的 Steam API
		④ 便于并行
		⑤ 最大化减少空指针异常 OPtional
	3. 其中最核心的是Lambda表达式与 Stream API
二. Lambda表达式
	1. 为什么使用 Lambda 表达式
		① Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁，更灵活的代码。
		作为一种更为紧凑的代码风格，使Java的语言表达能力得到提升
			A. 匿名内部类
				Comparator<Integer> comparator = new Comparator<Integer>() {
					@Override
					public int compare(Integer o1, Integer o2) {
						return Integer.compare(o1, 02);
					}
				};
			B. Lambda表达式
				Comparator<Integer> comparator1 = (o1, o2) -> Integer.compare(o1, o2);
			C. 获取当前公司员工年龄小于18的员工信息
				a. 传统方式
					List<Employee> list = Arrays.asList(
						new Employee(1, "LiXL", 1, 18, 8000.00),
						new Employee(2, "YuCX", 0, 19, 9000.00),
						new Employee(3, "LinK", 1, 17, 7000.00),
						new Employee(4, "LinZH", 1, 18, 8000.00),
						new Employee(4, "LiLX", 0, 16, 9000.00)
					);
					private List<Employee> filterEmployee(List<Employee> list) {
						List<Employee> newList = new ArrayList<>();

						for (Employee employee: list) {
							if (employee.getAge() < 18) {
								newList.add(employee);
							}
						}

						return newList;
					}
				b. 优化方式一：策略设计模式，每多一个策略，则需要重新实现MyPredicate接口
					public interface MyPredicate<T> {

						boolean test(T t);
					}
					
					public class FilterEmployeeByAge implements MyPredicate<Employee> {

						@Override
						public boolean test(Employee employee) {
							return employee.getAge() < 18;
						}
					}
					
					private List<Employee> filterEmployeeByAge1(List<Employee> list, MyPredicate<Employee> myPredicate) {
						List<Employee> emps = new ArrayList<>();

						for (Employee employee: list) {
							if (myPredicate.test(employee)) {
								emps.add(employee);
							}
						}
						return  emps;
					}
				c. 优化方式二：匿名内部类，每增加一个策略，不需要实现MyPredicate接口，而是提供一个匿名内部类
					filterEmployeeByAge1(list, new MyPredicate<Employee>() {
						@Override
						public boolean test(Employee employee) {
							return employee.getSalary() > 8000;
						}
					})
				d. 优化方式三：lambda表达式
					List<Employee> emps = filterEmployeeByAge1(list, employee -> employee.getGender() == 0);
					emps.forEach(System.out::println);
				e. 优化方式四：Stream API
					list.stream().filter(employee -> employee.getGender() == 1).forEach(System.out::println);
		② Lambda表达式被称为语法糖或者糖衣语法。
	2. 基础语法：
		① Java 8 中引入了一个新的操作符 “->”，该操作符称为箭头操作符或者Lambda操作符，箭头操作符将 Lambda 表达式拆分为两部分
			A. 左侧：Lambda 表达式中的参数列表
			B. 右侧：Lambda 表达式中所需要执行的功能，即 Lambda 体
		② 语法格式：
			A. 无参数，无返回值：
				a. 语法：() -> {}，如果Lambda体中只有一条语句，则大括号可以省略
				b. 对应的函数式接口：Runnable
				c. 举例：
					Runnable runnable = new Runnable() {
						@Override
						public void run() {
							System.out.println("hello");
						}
					};
					runnable.run();
					
					Runnable runnable = () -> System.out.println("Hello");
					runnable.run();
				d. 注意：在局部内部类中使用了同级的局部变量时，需要声明该变量为 final，但是在 Java8 中，会隐式默认该变量为final修饰，不需要显示
				修饰，在Java 8 或者 Java 7中的局部内部类中，都不允许修改该变量。
			B. 有参数，无返回值：
				a. 语法：(T t) -> {}，如果只有一个参数，小括号可以省略，一般默认带上小括号
				b. 对应的函数式接口：Consumer
				c. 举例：
					Consumer<String> consumer = new Consumer<String>() {
						@Override
						public void accept(String str) {
							System.out.println(str);
						}
					};
					consumer.accept("Hello");

					Consumer<String> consumer1 = str -> System.out.println(str);
					consumer1.accept("World");
			C. 有两个以上的参数，并且有返回值，并且Lambda表达式中有多条语句
				a. 语法：(T t1, T t2) -> {} ，有多条语句时，大括号不能省略；只有一条语句时，return 可以省略不写；参数列表有多个时，小括号不能省略。
				b. 对应的函数式接口为：
				c. 举例：
					Comparator<Integer> comparator = new Comparator<Integer>() {
						@Override
						public int compare(Integer o1, Integer o2) {
							return Integer.compare(o1, o2);
						}
					};

					Comparator<Double> comparator1 = (d1, d2) -> {
						System.out.println("Comparator函数式接口");
						return Double.compare(d1, d2);
					};
			D. Lambda表达式参数列表的数据类型可以省略不写，因为Java 的 JVM编译器通过上下文可以推断出参数列表的数据类型，即“类型推断”，当接口中的泛型
			指明了参数列表中的数据类型时，此时Lambda表达式中参数列表的数据类型就可以省略不写
		③ Lambda表达式需要“函数式接口”的支持
			A. 函数式接口：接口中有只有一个抽象方法，则称为“函数式接口”
			B. 可以使用@FunctionalInterface注解检查其标注的接口是否为“函数式接口”
		④ 练习：对一个数进行数学运算
			public interface MyFunction<T> {

				T operator(T t);
			}
		
			MyFunction<Integer> myFunction = x -> x * x;
			System.out.println( myFunction.operator(10));































































































































































































